{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":195,"byte_end":221,"line_start":8,"line_end":8,"column_start":1,"column_end":27,"is_primary":true,"text":[{"text":"#![feature(register_tool)]","highlight_start":1,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:8:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(register_tool)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":248,"byte_end":278,"line_start":10,"line_end":10,"column_start":1,"column_end":31,"is_primary":true,"text":[{"text":"#![feature(strict_provenance)]","highlight_start":1,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:10:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(strict_provenance)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":279,"byte_end":307,"line_start":11,"line_end":11,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"#![feature(core_intrinsics)]","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:11:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(core_intrinsics)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":308,"byte_end":331,"line_start":12,"line_end":12,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"#![feature(raw_ref_op)]","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:12:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(raw_ref_op)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":7781,"byte_end":9440,"line_start":242,"line_end":274,"column_start":20,"column_end":14,"is_primary":true,"text":[{"text":"            } else {","highlight_start":20,"highlight_end":21},{"text":"                if '*' as i32","highlight_start":1,"highlight_end":30},{"text":"                    == *((*state).src).offset(((*state).offset).wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let ref mut fresh6 = (*state).offset;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh6 = (*fresh6).wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    let ref mut fresh7 = (*state).offset;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh7 = (*fresh7).wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    while ((*state).offset).wrapping_add(1) < (*state).size {","highlight_start":1,"highlight_end":78},{"text":"                        if '*' as i32 == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && '/' as i32","highlight_start":1,"highlight_end":42},{"text":"                                == *((*state).src)","highlight_start":1,"highlight_end":51},{"text":"                                    .offset(((*state).offset).wrapping_add(1) as isize)","highlight_start":1,"highlight_end":88},{"text":"                                    as i32","highlight_start":1,"highlight_end":43},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            let ref mut fresh8 = (*state).offset;","highlight_start":1,"highlight_end":66},{"text":"                            *fresh8 = (*fresh8 as u64).wrapping_add(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                            return 1;","highlight_start":1,"highlight_end":38},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if '\\n' as i32","highlight_start":1,"highlight_end":43},{"text":"                                == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":91},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh9 = (*state).line_no;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh9 = (*fresh9).wrapping_add(1);","highlight_start":1,"highlight_end":69},{"text":"                                (*state).line_offset = (*state).offset;","highlight_start":1,"highlight_end":72},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        let ref mut fresh10 = (*state).offset;","highlight_start":1,"highlight_end":63},{"text":"                        *fresh10 = (*fresh10).wrapping_add(1);","highlight_start":1,"highlight_end":63},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    return 1;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::collapsible_else_if)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":7781,"byte_end":9440,"line_start":242,"line_end":274,"column_start":20,"column_end":14,"is_primary":true,"text":[{"text":"            } else {","highlight_start":20,"highlight_end":21},{"text":"                if '*' as i32","highlight_start":1,"highlight_end":30},{"text":"                    == *((*state).src).offset(((*state).offset).wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let ref mut fresh6 = (*state).offset;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh6 = (*fresh6).wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    let ref mut fresh7 = (*state).offset;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh7 = (*fresh7).wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    while ((*state).offset).wrapping_add(1) < (*state).size {","highlight_start":1,"highlight_end":78},{"text":"                        if '*' as i32 == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && '/' as i32","highlight_start":1,"highlight_end":42},{"text":"                                == *((*state).src)","highlight_start":1,"highlight_end":51},{"text":"                                    .offset(((*state).offset).wrapping_add(1) as isize)","highlight_start":1,"highlight_end":88},{"text":"                                    as i32","highlight_start":1,"highlight_end":43},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            let ref mut fresh8 = (*state).offset;","highlight_start":1,"highlight_end":66},{"text":"                            *fresh8 = (*fresh8 as u64).wrapping_add(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                            return 1;","highlight_start":1,"highlight_end":38},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if '\\n' as i32","highlight_start":1,"highlight_end":43},{"text":"                                == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":91},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh9 = (*state).line_no;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh9 = (*fresh9).wrapping_add(1);","highlight_start":1,"highlight_end":69},{"text":"                                (*state).line_offset = (*state).offset;","highlight_start":1,"highlight_end":72},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        let ref mut fresh10 = (*state).offset;","highlight_start":1,"highlight_end":63},{"text":"                        *fresh10 = (*fresh10).wrapping_add(1);","highlight_start":1,"highlight_end":63},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    return 1;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if '*' as i32\n                == *((*state).src).offset(((*state).offset).wrapping_add(1) as isize) as i32\n            {\n                let ref mut fresh6 = (*state).offset;\n                *fresh6 = (*fresh6).wrapping_add(1);\n                let ref mut fresh7 = (*state).offset;\n                *fresh7 = (*fresh7).wrapping_add(1);\n                while ((*state).offset).wrapping_add(1) < (*state).size {\n                    if '*' as i32 == *((*state).src).offset((*state).offset as isize) as i32\n                        && '/' as i32\n                            == *((*state).src)\n                                .offset(((*state).offset).wrapping_add(1) as isize)\n                                as i32\n                    {\n                        let ref mut fresh8 = (*state).offset;\n                        *fresh8 = (*fresh8 as u64).wrapping_add(2) as u64;\n                        return 1;\n                    } else {\n                        if '\\n' as i32\n                            == *((*state).src).offset((*state).offset as isize) as i32\n                        {\n                            let ref mut fresh9 = (*state).line_no;\n                            *fresh9 = (*fresh9).wrapping_add(1);\n                            (*state).line_offset = (*state).offset;\n                        }\n                    }\n                    let ref mut fresh10 = (*state).offset;\n                    *fresh10 = (*fresh10).wrapping_add(1);\n                }\n                return 1;\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:242:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            } else {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if '*' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    == *((*state).src).offset(((*state).offset).wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m273\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::collapsible_else_if)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            } else \u001b[0m\u001b[0m\u001b[38;5;10mif '*' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 == *((*state).src).offset(((*state).offset).wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh6 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh6 = (*fresh6).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh7 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m248\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh7 = (*fresh7).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m249\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while ((*state).offset).wrapping_add(1) < (*state).size {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m250\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if '*' as i32 == *((*state).src).offset((*state).offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         && '/' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             == *((*state).src)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m253\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 .offset(((*state).offset).wrapping_add(1) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m254\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m256\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let ref mut fresh8 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m257\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *fresh8 = (*fresh8 as u64).wrapping_add(2) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m259\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m260\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if '\\n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m261\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             == *((*state).src).offset((*state).offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let ref mut fresh9 = (*state).line_no;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *fresh9 = (*fresh9).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*state).line_offset = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let ref mut fresh10 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *fresh10 = (*fresh10).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m271\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m272\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":8797,"byte_end":9230,"line_start":260,"line_end":268,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if '\\n' as i32","highlight_start":1,"highlight_end":43},{"text":"                                == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":91},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh9 = (*state).line_no;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh9 = (*fresh9).wrapping_add(1);","highlight_start":1,"highlight_end":69},{"text":"                                (*state).line_offset = (*state).offset;","highlight_start":1,"highlight_end":72},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":8797,"byte_end":9230,"line_start":260,"line_end":268,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if '\\n' as i32","highlight_start":1,"highlight_end":43},{"text":"                                == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":91},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh9 = (*state).line_no;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh9 = (*fresh9).wrapping_add(1);","highlight_start":1,"highlight_end":69},{"text":"                                (*state).line_offset = (*state).offset;","highlight_start":1,"highlight_end":72},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if '\\n' as i32\n                            == *((*state).src).offset((*state).offset as isize) as i32\n                        {\n                            let ref mut fresh9 = (*state).line_no;\n                            *fresh9 = (*fresh9).wrapping_add(1);\n                            (*state).line_offset = (*state).offset;\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:260:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m260\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m261\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if '\\n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                == *((*state).src).offset((*state).offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m260\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif '\\n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m261\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             == *((*state).src).offset((*state).offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let ref mut fresh9 = (*state).line_no;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *fresh9 = (*fresh9).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*state).line_offset = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":12033,"byte_end":12404,"line_start":347,"line_end":355,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if '\"' as i32 != *src.offset(offset as isize) as i32 {","highlight_start":9,"highlight_end":63},{"text":"            if !(json_parse_flags_allow_single_quoted_strings as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":89},{"text":"                && is_single_quote != 0)","highlight_start":1,"highlight_end":41},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                (*state).error = json_parse_error_expected_opening_quote as u64;","highlight_start":1,"highlight_end":81},{"text":"                (*state).offset = offset;","highlight_start":1,"highlight_end":42},{"text":"                return 1;","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::collapsible_if)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":12033,"byte_end":12404,"line_start":347,"line_end":355,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if '\"' as i32 != *src.offset(offset as isize) as i32 {","highlight_start":9,"highlight_end":63},{"text":"            if !(json_parse_flags_allow_single_quoted_strings as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":89},{"text":"                && is_single_quote != 0)","highlight_start":1,"highlight_end":41},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                (*state).error = json_parse_error_expected_opening_quote as u64;","highlight_start":1,"highlight_end":81},{"text":"                (*state).offset = offset;","highlight_start":1,"highlight_end":42},{"text":"                return 1;","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if '\"' as i32 != *src.offset(offset as isize) as i32 && !(json_parse_flags_allow_single_quoted_strings as u64 & flags_bitset != 0\n                && is_single_quote != 0) {\n            (*state).error = json_parse_error_expected_opening_quote as u64;\n            (*state).offset = offset;\n            return 1;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:347:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m347\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if '\"' as i32 != *src.offset(offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m348\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if !(json_parse_flags_allow_single_quoted_strings as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m349\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && is_single_quote != 0)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m350\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m354\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m355\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::collapsible_if)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m347\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif '\"' as i32 != *src.offset(offset as isize) as i32 && !(json_parse_flags_allow_single_quoted_strings as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m348\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && is_single_quote != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m349\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             (*state).error = json_parse_error_expected_opening_quote as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m350\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             (*state).offset = offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m351\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m352\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":20248,"byte_end":20491,"line_start":527,"line_end":533,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if is_global_object != 0 {","highlight_start":9,"highlight_end":35},{"text":"            if json_skip_all_skippables(state) == 0","highlight_start":1,"highlight_end":52},{"text":"                && '{' as i32 == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":89},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                is_global_object = 0;","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":20248,"byte_end":20491,"line_start":527,"line_end":533,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if is_global_object != 0 {","highlight_start":9,"highlight_end":35},{"text":"            if json_skip_all_skippables(state) == 0","highlight_start":1,"highlight_end":52},{"text":"                && '{' as i32 == *((*state).src).offset((*state).offset as isize) as i32","highlight_start":1,"highlight_end":89},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                is_global_object = 0;","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if is_global_object != 0 && json_skip_all_skippables(state) == 0 && '{' as i32 == *((*state).src).offset((*state).offset as isize) as i32 {\n            is_global_object = 0;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:527:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if is_global_object != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if json_skip_all_skippables(state) == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m529\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && '{' as i32 == *((*state).src).offset((*state).offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m530\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m531\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                is_global_object = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m532\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m533\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif is_global_object != 0 && json_skip_all_skippables(state) == 0 && '{' as i32 == *((*state).src).offset((*state).offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             is_global_object = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m529\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":31670,"byte_end":32217,"line_start":779,"line_end":790,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if inf_or_nan != 0 {","highlight_start":17,"highlight_end":37},{"text":"                    if offset < size {","highlight_start":1,"highlight_end":39},{"text":"                        match *src.offset(offset as isize) as i32 {","highlight_start":1,"highlight_end":68},{"text":"                            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 101 | 69 => {","highlight_start":1,"highlight_end":92},{"text":"                                (*state).error = json_parse_error_invalid_number_format as u64;","highlight_start":1,"highlight_end":96},{"text":"                                (*state).offset = offset;","highlight_start":1,"highlight_end":58},{"text":"                                return 1;","highlight_start":1,"highlight_end":42},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            _ => {}","highlight_start":1,"highlight_end":36},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":31670,"byte_end":32217,"line_start":779,"line_end":790,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if inf_or_nan != 0 {","highlight_start":17,"highlight_end":37},{"text":"                    if offset < size {","highlight_start":1,"highlight_end":39},{"text":"                        match *src.offset(offset as isize) as i32 {","highlight_start":1,"highlight_end":68},{"text":"                            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 101 | 69 => {","highlight_start":1,"highlight_end":92},{"text":"                                (*state).error = json_parse_error_invalid_number_format as u64;","highlight_start":1,"highlight_end":96},{"text":"                                (*state).offset = offset;","highlight_start":1,"highlight_end":58},{"text":"                                return 1;","highlight_start":1,"highlight_end":42},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            _ => {}","highlight_start":1,"highlight_end":36},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if inf_or_nan != 0 && offset < size {\n                    match *src.offset(offset as isize) as i32 {\n                        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 101 | 69 => {\n                            (*state).error = json_parse_error_invalid_number_format as u64;\n                            (*state).offset = offset;\n                            return 1;\n                        }\n                        _ => {}\n                    }\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:779:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m779\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if inf_or_nan != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m780\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if offset < size {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m781\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        match *src.offset(offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m782\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 101 | 69 => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m789\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m790\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m779\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10mif inf_or_nan != 0 && offset < size {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m780\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     match *src.offset(offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m781\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 101 | 69 => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m782\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*state).error = json_parse_error_invalid_number_format as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m783\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*state).offset = offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m784\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m785\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m786\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         _ => {}\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m787\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m788\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":32244,"byte_end":32895,"line_start":792,"line_end":806,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if found_sign != 0","highlight_start":13,"highlight_end":31},{"text":"                && inf_or_nan == 0","highlight_start":1,"highlight_end":35},{"text":"                && offset < size","highlight_start":1,"highlight_end":33},{"text":"                && !('0' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":71},{"text":"                    && *src.offset(offset as isize) as i32 <= '9' as i32)","highlight_start":1,"highlight_end":74},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if json_parse_flags_allow_leading_or_trailing_decimal_point as u64 & flags_bitset","highlight_start":1,"highlight_end":98},{"text":"                    == 0","highlight_start":1,"highlight_end":25},{"text":"                    || '.' as i32 != *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":73},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    (*state).error = json_parse_error_invalid_number_format as u64;","highlight_start":1,"highlight_end":84},{"text":"                    (*state).offset = offset;","highlight_start":1,"highlight_end":46},{"text":"                    return 1;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":32244,"byte_end":32895,"line_start":792,"line_end":806,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if found_sign != 0","highlight_start":13,"highlight_end":31},{"text":"                && inf_or_nan == 0","highlight_start":1,"highlight_end":35},{"text":"                && offset < size","highlight_start":1,"highlight_end":33},{"text":"                && !('0' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":71},{"text":"                    && *src.offset(offset as isize) as i32 <= '9' as i32)","highlight_start":1,"highlight_end":74},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if json_parse_flags_allow_leading_or_trailing_decimal_point as u64 & flags_bitset","highlight_start":1,"highlight_end":98},{"text":"                    == 0","highlight_start":1,"highlight_end":25},{"text":"                    || '.' as i32 != *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":73},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    (*state).error = json_parse_error_invalid_number_format as u64;","highlight_start":1,"highlight_end":84},{"text":"                    (*state).offset = offset;","highlight_start":1,"highlight_end":46},{"text":"                    return 1;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if found_sign != 0\n                && inf_or_nan == 0\n                && offset < size && !('0' as i32 <= *src.offset(offset as isize) as i32\n                    && *src.offset(offset as isize) as i32 <= '9' as i32) && (json_parse_flags_allow_leading_or_trailing_decimal_point as u64 & flags_bitset\n                    == 0 || '.' as i32 != *src.offset(offset as isize) as i32) {\n                (*state).error = json_parse_error_invalid_number_format as u64;\n                (*state).offset = offset;\n                return 1;\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:792:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m792\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if found_sign != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m793\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && inf_or_nan == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m794\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && offset < size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m795\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && !('0' as i32 <= *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m805\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m806\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m792\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif found_sign != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m793\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && inf_or_nan == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m794\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && offset < size && !('0' as i32 <= *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m795\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && *src.offset(offset as isize) as i32 <= '9' as i32) && (json_parse_flags_allow_leading_or_trailing_decimal_point as u64 & flags_bitset\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m796\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     == 0 || '.' as i32 != *src.offset(offset as isize) as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m797\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*state).error = json_parse_error_invalid_number_format as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m798\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*state).offset = offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m799\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m800\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":33906,"byte_end":34534,"line_start":828,"line_end":841,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if offset >= size","highlight_start":17,"highlight_end":34},{"text":"                    || !('0' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":75},{"text":"                        && *src.offset(offset as isize) as i32 <= '9' as i32)","highlight_start":1,"highlight_end":78},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    if json_parse_flags_allow_leading_or_trailing_decimal_point as u64","highlight_start":1,"highlight_end":87},{"text":"                        & flags_bitset","highlight_start":1,"highlight_end":39},{"text":"                        == 0","highlight_start":1,"highlight_end":29},{"text":"                        || had_leading_digits == 0","highlight_start":1,"highlight_end":51},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        (*state).error = json_parse_error_invalid_number_format as u64;","highlight_start":1,"highlight_end":88},{"text":"                        (*state).offset = offset;","highlight_start":1,"highlight_end":50},{"text":"                        return 1;","highlight_start":1,"highlight_end":34},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":33906,"byte_end":34534,"line_start":828,"line_end":841,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if offset >= size","highlight_start":17,"highlight_end":34},{"text":"                    || !('0' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":75},{"text":"                        && *src.offset(offset as isize) as i32 <= '9' as i32)","highlight_start":1,"highlight_end":78},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    if json_parse_flags_allow_leading_or_trailing_decimal_point as u64","highlight_start":1,"highlight_end":87},{"text":"                        & flags_bitset","highlight_start":1,"highlight_end":39},{"text":"                        == 0","highlight_start":1,"highlight_end":29},{"text":"                        || had_leading_digits == 0","highlight_start":1,"highlight_end":51},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        (*state).error = json_parse_error_invalid_number_format as u64;","highlight_start":1,"highlight_end":88},{"text":"                        (*state).offset = offset;","highlight_start":1,"highlight_end":50},{"text":"                        return 1;","highlight_start":1,"highlight_end":34},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if (offset >= size || !('0' as i32 <= *src.offset(offset as isize) as i32\n                        && *src.offset(offset as isize) as i32 <= '9' as i32)) && (json_parse_flags_allow_leading_or_trailing_decimal_point as u64\n                        & flags_bitset\n                        == 0 || had_leading_digits == 0) {\n                    (*state).error = json_parse_error_invalid_number_format as u64;\n                    (*state).offset = offset;\n                    return 1;\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:828:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m828\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if offset >= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m829\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    || !('0' as i32 <= *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m830\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        && *src.offset(offset as isize) as i32 <= '9' as i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m840\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m828\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10mif (offset >= size || !('0' as i32 <= *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m829\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         && *src.offset(offset as isize) as i32 <= '9' as i32)) && (json_parse_flags_allow_leading_or_trailing_decimal_point as u64\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m830\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         & flags_bitset\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         == 0 || had_leading_digits == 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m832\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*state).error = json_parse_error_invalid_number_format as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m833\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*state).offset = offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m834\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":40450,"byte_end":44730,"line_start":977,"line_end":1042,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else {","highlight_start":28,"highlight_end":29},{"text":"                        if offset.wrapping_add(5) <= size","highlight_start":1,"highlight_end":58},{"text":"                            && 'f' as i32 == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 'a' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 'l' as i32 == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 's' as i32 == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 'e' as i32 == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            let ref mut fresh34 = (*state).offset;","highlight_start":1,"highlight_end":67},{"text":"                            *fresh34 = (*fresh34 as u64).wrapping_add(5) as u64;","highlight_start":1,"highlight_end":81},{"text":"                            return 0;","highlight_start":1,"highlight_end":38},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if offset.wrapping_add(4) <= size","highlight_start":1,"highlight_end":62},{"text":"                                && 'n' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(0) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'u' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(1) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(2) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(3) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh35 = (*state).offset;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;","highlight_start":1,"highlight_end":85},{"text":"                                return 0;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":97},{"text":"                                    && offset.wrapping_add(3) <= size","highlight_start":1,"highlight_end":70},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'a' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    return json_get_number_size(state);","highlight_start":1,"highlight_end":72},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    };","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":40450,"byte_end":44730,"line_start":977,"line_end":1042,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else {","highlight_start":28,"highlight_end":29},{"text":"                        if offset.wrapping_add(5) <= size","highlight_start":1,"highlight_end":58},{"text":"                            && 'f' as i32 == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 'a' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 'l' as i32 == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 's' as i32 == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                            && 'e' as i32 == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":97},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            let ref mut fresh34 = (*state).offset;","highlight_start":1,"highlight_end":67},{"text":"                            *fresh34 = (*fresh34 as u64).wrapping_add(5) as u64;","highlight_start":1,"highlight_end":81},{"text":"                            return 0;","highlight_start":1,"highlight_end":38},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if offset.wrapping_add(4) <= size","highlight_start":1,"highlight_end":62},{"text":"                                && 'n' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(0) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'u' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(1) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(2) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(3) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh35 = (*state).offset;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;","highlight_start":1,"highlight_end":85},{"text":"                                return 0;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":97},{"text":"                                    && offset.wrapping_add(3) <= size","highlight_start":1,"highlight_end":70},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'a' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    return json_get_number_size(state);","highlight_start":1,"highlight_end":72},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    };","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if offset.wrapping_add(5) <= size\n                        && 'f' as i32 == *src.offset(offset.wrapping_add(0) as isize) as i32\n                        && 'a' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32\n                        && 'l' as i32 == *src.offset(offset.wrapping_add(2) as isize) as i32\n                        && 's' as i32 == *src.offset(offset.wrapping_add(3) as isize) as i32\n                        && 'e' as i32 == *src.offset(offset.wrapping_add(4) as isize) as i32\n                    {\n                        let ref mut fresh34 = (*state).offset;\n                        *fresh34 = (*fresh34 as u64).wrapping_add(5) as u64;\n                        return 0;\n                    } else {\n                        if offset.wrapping_add(4) <= size\n                            && 'n' as i32\n                                == *((*state).src).offset(offset.wrapping_add(0) as isize)\n                                    as i32\n                            && 'u' as i32\n                                == *((*state).src).offset(offset.wrapping_add(1) as isize)\n                                    as i32\n                            && 'l' as i32\n                                == *((*state).src).offset(offset.wrapping_add(2) as isize)\n                                    as i32\n                            && 'l' as i32\n                                == *((*state).src).offset(offset.wrapping_add(3) as isize)\n                                    as i32\n                        {\n                            let ref mut fresh35 = (*state).offset;\n                            *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;\n                            return 0;\n                        } else {\n                            if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\n                                && offset.wrapping_add(3) <= size\n                                && 'N' as i32\n                                    == *src.offset(offset.wrapping_add(0) as isize) as i32\n                                && 'a' as i32\n                                    == *src.offset(offset.wrapping_add(1) as isize) as i32\n                                && 'N' as i32\n                                    == *src.offset(offset.wrapping_add(2) as isize) as i32\n                            {\n                                return json_get_number_size(state);\n                            } else {\n                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\n                                    && offset.wrapping_add(8) <= size\n                                    && 'I' as i32\n                                        == *src.offset(offset.wrapping_add(0) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(1) as isize) as i32\n                                    && 'f' as i32\n                                        == *src.offset(offset.wrapping_add(2) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(3) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(4) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(5) as isize) as i32\n                                    && 't' as i32\n                                        == *src.offset(offset.wrapping_add(6) as isize) as i32\n                                    && 'y' as i32\n                                        == *src.offset(offset.wrapping_add(7) as isize) as i32\n                                {\n                                    return json_get_number_size(state);\n                                }\n                            }\n                        }\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:977:28\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m977\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m978\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if offset.wrapping_add(5) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m979\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            && 'f' as i32 == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m980\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            && 'a' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1041\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1042\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    };\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m977\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    } else \u001b[0m\u001b[0m\u001b[38;5;10mif offset.wrapping_add(5) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m978\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         && 'f' as i32 == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m979\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         && 'a' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m980\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         && 'l' as i32 == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m981\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         && 's' as i32 == *src.offset(offset.wrapping_add(3) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m982\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         && 'e' as i32 == *src.offset(offset.wrapping_add(4) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m983\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m984\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         let ref mut fresh34 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m985\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         *fresh34 = (*fresh34 as u64).wrapping_add(5) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m986\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m987\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m988\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         if offset.wrapping_add(4) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m989\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m990\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(0) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m991\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m992\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'u' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m993\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(1) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m994\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m995\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'l' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m996\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(2) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m997\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m998\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'l' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m999\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(3) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1000\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1001\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1002\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let ref mut fresh35 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1004\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1005\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1006\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1007\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && offset.wrapping_add(3) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1008\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'N' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1009\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1010\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'a' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1011\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1012\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'N' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1013\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1014\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1015\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return json_get_number_size(state);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1016\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1017\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1018\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && offset.wrapping_add(8) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1019\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'I' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1020\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1021\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1022\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1023\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'f' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1024\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1025\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(3) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(4) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1030\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(5) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1031\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1032\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(6) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1033\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'y' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1034\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(7) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1035\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1036\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return json_get_number_size(state);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1037\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1038\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1039\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1040\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~                     }\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":41238,"byte_end":44708,"line_start":988,"line_end":1041,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if offset.wrapping_add(4) <= size","highlight_start":1,"highlight_end":62},{"text":"                                && 'n' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(0) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'u' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(1) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(2) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(3) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh35 = (*state).offset;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;","highlight_start":1,"highlight_end":85},{"text":"                                return 0;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":97},{"text":"                                    && offset.wrapping_add(3) <= size","highlight_start":1,"highlight_end":70},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'a' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    return json_get_number_size(state);","highlight_start":1,"highlight_end":72},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":41238,"byte_end":44708,"line_start":988,"line_end":1041,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if offset.wrapping_add(4) <= size","highlight_start":1,"highlight_end":62},{"text":"                                && 'n' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(0) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'u' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(1) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(2) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                                && 'l' as i32","highlight_start":1,"highlight_end":46},{"text":"                                    == *((*state).src).offset(offset.wrapping_add(3) as isize)","highlight_start":1,"highlight_end":95},{"text":"                                        as i32","highlight_start":1,"highlight_end":47},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                let ref mut fresh35 = (*state).offset;","highlight_start":1,"highlight_end":71},{"text":"                                *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;","highlight_start":1,"highlight_end":85},{"text":"                                return 0;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":97},{"text":"                                    && offset.wrapping_add(3) <= size","highlight_start":1,"highlight_end":70},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'a' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    return json_get_number_size(state);","highlight_start":1,"highlight_end":72},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if offset.wrapping_add(4) <= size\n                            && 'n' as i32\n                                == *((*state).src).offset(offset.wrapping_add(0) as isize)\n                                    as i32\n                            && 'u' as i32\n                                == *((*state).src).offset(offset.wrapping_add(1) as isize)\n                                    as i32\n                            && 'l' as i32\n                                == *((*state).src).offset(offset.wrapping_add(2) as isize)\n                                    as i32\n                            && 'l' as i32\n                                == *((*state).src).offset(offset.wrapping_add(3) as isize)\n                                    as i32\n                        {\n                            let ref mut fresh35 = (*state).offset;\n                            *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;\n                            return 0;\n                        } else {\n                            if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\n                                && offset.wrapping_add(3) <= size\n                                && 'N' as i32\n                                    == *src.offset(offset.wrapping_add(0) as isize) as i32\n                                && 'a' as i32\n                                    == *src.offset(offset.wrapping_add(1) as isize) as i32\n                                && 'N' as i32\n                                    == *src.offset(offset.wrapping_add(2) as isize) as i32\n                            {\n                                return json_get_number_size(state);\n                            } else {\n                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\n                                    && offset.wrapping_add(8) <= size\n                                    && 'I' as i32\n                                        == *src.offset(offset.wrapping_add(0) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(1) as isize) as i32\n                                    && 'f' as i32\n                                        == *src.offset(offset.wrapping_add(2) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(3) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(4) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(5) as isize) as i32\n                                    && 't' as i32\n                                        == *src.offset(offset.wrapping_add(6) as isize) as i32\n                                    && 'y' as i32\n                                        == *src.offset(offset.wrapping_add(7) as isize) as i32\n                                {\n                                    return json_get_number_size(state);\n                                }\n                            }\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:988:32\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m988\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m989\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if offset.wrapping_add(4) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m990\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m991\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                    == *((*state).src).offset(offset.wrapping_add(0) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1040\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1041\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m988\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif offset.wrapping_add(4) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m989\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m990\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(0) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m991\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m992\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'u' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m993\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(1) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m994\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m995\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'l' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m996\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(2) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m997\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m998\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             && 'l' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m999\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                                 == *((*state).src).offset(offset.wrapping_add(3) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1000\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1001\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1002\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let ref mut fresh35 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *fresh35 = (*fresh35 as u64).wrapping_add(4) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1004\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1005\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1006\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1007\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && offset.wrapping_add(3) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1008\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'N' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1009\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1010\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'a' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1011\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1012\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'N' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1013\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1014\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1015\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return json_get_number_size(state);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1016\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1017\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1018\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && offset.wrapping_add(8) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1019\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'I' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1020\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1021\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1022\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1023\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'f' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1024\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1025\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(3) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(4) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1030\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(5) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1031\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1032\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(6) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1033\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'y' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1034\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(7) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1035\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1036\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return json_get_number_size(state);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1037\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1038\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1039\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":42317,"byte_end":44682,"line_start":1006,"line_end":1040,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else {","highlight_start":36,"highlight_end":37},{"text":"                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":97},{"text":"                                    && offset.wrapping_add(3) <= size","highlight_start":1,"highlight_end":70},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'a' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    return json_get_number_size(state);","highlight_start":1,"highlight_end":72},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":42317,"byte_end":44682,"line_start":1006,"line_end":1040,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else {","highlight_start":36,"highlight_end":37},{"text":"                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":97},{"text":"                                    && offset.wrapping_add(3) <= size","highlight_start":1,"highlight_end":70},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'a' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                    && 'N' as i32","highlight_start":1,"highlight_end":50},{"text":"                                        == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":95},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    return json_get_number_size(state);","highlight_start":1,"highlight_end":72},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\n                                && offset.wrapping_add(3) <= size\n                                && 'N' as i32\n                                    == *src.offset(offset.wrapping_add(0) as isize) as i32\n                                && 'a' as i32\n                                    == *src.offset(offset.wrapping_add(1) as isize) as i32\n                                && 'N' as i32\n                                    == *src.offset(offset.wrapping_add(2) as isize) as i32\n                            {\n                                return json_get_number_size(state);\n                            } else {\n                                if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\n                                    && offset.wrapping_add(8) <= size\n                                    && 'I' as i32\n                                        == *src.offset(offset.wrapping_add(0) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(1) as isize) as i32\n                                    && 'f' as i32\n                                        == *src.offset(offset.wrapping_add(2) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(3) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(4) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(5) as isize) as i32\n                                    && 't' as i32\n                                        == *src.offset(offset.wrapping_add(6) as isize) as i32\n                                    && 'y' as i32\n                                        == *src.offset(offset.wrapping_add(7) as isize) as i32\n                                {\n                                    return json_get_number_size(state);\n                                }\n                            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1006:36\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1006\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m______________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1007\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1008\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && offset.wrapping_add(3) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1009\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && 'N' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1039\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1040\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_______________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1006\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                            } else \u001b[0m\u001b[0m\u001b[38;5;10mif json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1007\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && offset.wrapping_add(3) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1008\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'N' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1009\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1010\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'a' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1011\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1012\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && 'N' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1013\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1014\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1015\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return json_get_number_size(state);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1016\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1017\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1018\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && offset.wrapping_add(8) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1019\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'I' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1020\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1021\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1022\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1023\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'f' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1024\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1025\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(3) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(4) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1030\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(5) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1031\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1032\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(6) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1033\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'y' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1034\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(7) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1035\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1036\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return json_get_number_size(state);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1037\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1038\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":43066,"byte_end":44652,"line_start":1017,"line_end":1039,"column_start":40,"column_end":34,"is_primary":true,"text":[{"text":"                                } else {","highlight_start":40,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":43066,"byte_end":44652,"line_start":1017,"line_end":1039,"column_start":40,"column_end":34,"is_primary":true,"text":[{"text":"                                } else {","highlight_start":40,"highlight_end":41},{"text":"                                    if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0","highlight_start":1,"highlight_end":101},{"text":"                                        && offset.wrapping_add(8) <= size","highlight_start":1,"highlight_end":74},{"text":"                                        && 'I' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(0) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'f' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(2) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(3) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'n' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(4) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'i' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(5) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 't' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(6) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                        && 'y' as i32","highlight_start":1,"highlight_end":54},{"text":"                                            == *src.offset(offset.wrapping_add(7) as isize) as i32","highlight_start":1,"highlight_end":99},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        return json_get_number_size(state);","highlight_start":1,"highlight_end":76},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":"if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\n                                    && offset.wrapping_add(8) <= size\n                                    && 'I' as i32\n                                        == *src.offset(offset.wrapping_add(0) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(1) as isize) as i32\n                                    && 'f' as i32\n                                        == *src.offset(offset.wrapping_add(2) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(3) as isize) as i32\n                                    && 'n' as i32\n                                        == *src.offset(offset.wrapping_add(4) as isize) as i32\n                                    && 'i' as i32\n                                        == *src.offset(offset.wrapping_add(5) as isize) as i32\n                                    && 't' as i32\n                                        == *src.offset(offset.wrapping_add(6) as isize) as i32\n                                    && 'y' as i32\n                                        == *src.offset(offset.wrapping_add(7) as isize) as i32\n                                {\n                                    return json_get_number_size(state);\n                                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1017:40\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1017\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m______________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1018\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       if json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1019\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && offset.wrapping_add(8) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1020\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && 'I' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1038\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1039\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_______________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1017\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                                } else \u001b[0m\u001b[0m\u001b[38;5;10mif json_parse_flags_allow_inf_and_nan as u64 & flags_bitset != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1018\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && offset.wrapping_add(8) <= size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1019\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'I' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1020\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(0) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1021\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1022\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1023\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'f' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1024\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(2) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1025\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(3) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'n' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(4) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1030\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(5) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1031\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1032\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(6) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1033\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && 'y' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1034\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         == *src.offset(offset.wrapping_add(7) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1035\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1036\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return json_get_number_size(state);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1037\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":54892,"byte_end":55056,"line_start":1261,"line_end":1265,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if is_global_object != 0 {","highlight_start":9,"highlight_end":35},{"text":"            if '{' as i32 == *src.offset((*state).offset as isize) as i32 {","highlight_start":1,"highlight_end":76},{"text":"                is_global_object = 0;","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":54892,"byte_end":55056,"line_start":1261,"line_end":1265,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if is_global_object != 0 {","highlight_start":9,"highlight_end":35},{"text":"            if '{' as i32 == *src.offset((*state).offset as isize) as i32 {","highlight_start":1,"highlight_end":76},{"text":"                is_global_object = 0;","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if is_global_object != 0 && '{' as i32 == *src.offset((*state).offset as isize) as i32 {\n            is_global_object = 0;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1261:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1261\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if is_global_object != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if '{' as i32 == *src.offset((*state).offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                is_global_object = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1261\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif is_global_object != 0 && '{' as i32 == *src.offset((*state).offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             is_global_object = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":55916,"byte_end":56234,"line_start":1286,"line_end":1293,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if allow_comma != 0 {","highlight_start":13,"highlight_end":34},{"text":"                if ',' as i32 == *src.offset((*state).offset as isize) as i32 {","highlight_start":1,"highlight_end":80},{"text":"                    let ref mut fresh70 = (*state).offset;","highlight_start":1,"highlight_end":59},{"text":"                    *fresh70 = (*fresh70).wrapping_add(1);","highlight_start":1,"highlight_end":59},{"text":"                    allow_comma = 0;","highlight_start":1,"highlight_end":37},{"text":"                    continue;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":55916,"byte_end":56234,"line_start":1286,"line_end":1293,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if allow_comma != 0 {","highlight_start":13,"highlight_end":34},{"text":"                if ',' as i32 == *src.offset((*state).offset as isize) as i32 {","highlight_start":1,"highlight_end":80},{"text":"                    let ref mut fresh70 = (*state).offset;","highlight_start":1,"highlight_end":59},{"text":"                    *fresh70 = (*fresh70).wrapping_add(1);","highlight_start":1,"highlight_end":59},{"text":"                    allow_comma = 0;","highlight_start":1,"highlight_end":37},{"text":"                    continue;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if allow_comma != 0 && ',' as i32 == *src.offset((*state).offset as isize) as i32 {\n                let ref mut fresh70 = (*state).offset;\n                *fresh70 = (*fresh70).wrapping_add(1);\n                allow_comma = 0;\n                continue;\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1286:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1286\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if allow_comma != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if ',' as i32 == *src.offset((*state).offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1288\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let ref mut fresh70 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1289\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    *fresh70 = (*fresh70).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1292\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1286\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif allow_comma != 0 && ',' as i32 == *src.offset((*state).offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh70 = (*state).offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1288\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh70 = (*fresh70).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1289\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 allow_comma = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1290\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 continue;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1291\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":63983,"byte_end":65325,"line_start":1469,"line_end":1491,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if json_parse_flags_allow_hexadecimal_numbers as u64 & flags_bitset != 0 {","highlight_start":9,"highlight_end":83},{"text":"            if '0' as i32 == *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":65},{"text":"                && ('x' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":86},{"text":"                    || 'X' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32)","highlight_start":1,"highlight_end":90},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                while offset < size","highlight_start":1,"highlight_end":36},{"text":"                    && ('0' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":74},{"text":"                        && *src.offset(offset as isize) as i32 <= '9' as i32","highlight_start":1,"highlight_end":77},{"text":"                        || 'a' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":77},{"text":"                            && *src.offset(offset as isize) as i32 <= 'f' as i32","highlight_start":1,"highlight_end":81},{"text":"                        || 'A' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":77},{"text":"                            && *src.offset(offset as isize) as i32 <= 'F' as i32","highlight_start":1,"highlight_end":81},{"text":"                        || 'x' as i32 == *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":77},{"text":"                        || 'X' as i32 == *src.offset(offset as isize) as i32)","highlight_start":1,"highlight_end":78},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let fresh95 = offset;","highlight_start":1,"highlight_end":42},{"text":"                    offset = offset.wrapping_add(1);","highlight_start":1,"highlight_end":53},{"text":"                    let fresh96 = bytes_written;","highlight_start":1,"highlight_end":49},{"text":"                    bytes_written = bytes_written.wrapping_add(1);","highlight_start":1,"highlight_end":67},{"text":"                    *data.offset(fresh96 as isize) = *src.offset(fresh95 as isize);","highlight_start":1,"highlight_end":84},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":63983,"byte_end":65325,"line_start":1469,"line_end":1491,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if json_parse_flags_allow_hexadecimal_numbers as u64 & flags_bitset != 0 {","highlight_start":9,"highlight_end":83},{"text":"            if '0' as i32 == *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":65},{"text":"                && ('x' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32","highlight_start":1,"highlight_end":86},{"text":"                    || 'X' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32)","highlight_start":1,"highlight_end":90},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                while offset < size","highlight_start":1,"highlight_end":36},{"text":"                    && ('0' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":74},{"text":"                        && *src.offset(offset as isize) as i32 <= '9' as i32","highlight_start":1,"highlight_end":77},{"text":"                        || 'a' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":77},{"text":"                            && *src.offset(offset as isize) as i32 <= 'f' as i32","highlight_start":1,"highlight_end":81},{"text":"                        || 'A' as i32 <= *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":77},{"text":"                            && *src.offset(offset as isize) as i32 <= 'F' as i32","highlight_start":1,"highlight_end":81},{"text":"                        || 'x' as i32 == *src.offset(offset as isize) as i32","highlight_start":1,"highlight_end":77},{"text":"                        || 'X' as i32 == *src.offset(offset as isize) as i32)","highlight_start":1,"highlight_end":78},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let fresh95 = offset;","highlight_start":1,"highlight_end":42},{"text":"                    offset = offset.wrapping_add(1);","highlight_start":1,"highlight_end":53},{"text":"                    let fresh96 = bytes_written;","highlight_start":1,"highlight_end":49},{"text":"                    bytes_written = bytes_written.wrapping_add(1);","highlight_start":1,"highlight_end":67},{"text":"                    *data.offset(fresh96 as isize) = *src.offset(fresh95 as isize);","highlight_start":1,"highlight_end":84},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if json_parse_flags_allow_hexadecimal_numbers as u64 & flags_bitset != 0 && '0' as i32 == *src.offset(offset as isize) as i32 && ('x' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32\n                    || 'X' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32) {\n            while offset < size\n                && ('0' as i32 <= *src.offset(offset as isize) as i32\n                    && *src.offset(offset as isize) as i32 <= '9' as i32\n                    || 'a' as i32 <= *src.offset(offset as isize) as i32\n                        && *src.offset(offset as isize) as i32 <= 'f' as i32\n                    || 'A' as i32 <= *src.offset(offset as isize) as i32\n                        && *src.offset(offset as isize) as i32 <= 'F' as i32\n                    || 'x' as i32 == *src.offset(offset as isize) as i32\n                    || 'X' as i32 == *src.offset(offset as isize) as i32)\n            {\n                let fresh95 = offset;\n                offset = offset.wrapping_add(1);\n                let fresh96 = bytes_written;\n                bytes_written = bytes_written.wrapping_add(1);\n                *data.offset(fresh96 as isize) = *src.offset(fresh95 as isize);\n            }\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1469:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if json_parse_flags_allow_hexadecimal_numbers as u64 & flags_bitset != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1470\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if '0' as i32 == *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && ('x' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    || 'X' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1490\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif json_parse_flags_allow_hexadecimal_numbers as u64 & flags_bitset != 0 && '0' as i32 == *src.offset(offset as isize) as i32 && ('x' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1470\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || 'X' as i32 == *src.offset(offset.wrapping_add(1) as isize) as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             while offset < size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && ('0' as i32 <= *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1473\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && *src.offset(offset as isize) as i32 <= '9' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1474\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || 'a' as i32 <= *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         && *src.offset(offset as isize) as i32 <= 'f' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || 'A' as i32 <= *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         && *src.offset(offset as isize) as i32 <= 'F' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || 'x' as i32 == *src.offset(offset as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1479\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || 'X' as i32 == *src.offset(offset as isize) as i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1480\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1481\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let fresh95 = offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1482\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 offset = offset.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1483\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let fresh96 = bytes_written;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1484\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1485\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *data.offset(fresh96 as isize) = *src.offset(fresh95 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1486\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":66157,"byte_end":66799,"line_start":1513,"line_end":1526,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if offset.wrapping_add(inf_strlen) < size {","highlight_start":13,"highlight_end":56},{"text":"                if 'I' as i32 == *src.offset(offset as isize) as i32 {","highlight_start":1,"highlight_end":71},{"text":"                    let mut i: u64 = 0;","highlight_start":1,"highlight_end":40},{"text":"                    i = 0;","highlight_start":1,"highlight_end":27},{"text":"                    while i < inf_strlen {","highlight_start":1,"highlight_end":43},{"text":"                        let fresh99 = offset;","highlight_start":1,"highlight_end":46},{"text":"                        offset = offset.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                        let fresh100 = bytes_written;","highlight_start":1,"highlight_end":54},{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":1,"highlight_end":71},{"text":"                        *data.offset(fresh100 as isize) = *src.offset(fresh99 as isize);","highlight_start":1,"highlight_end":89},{"text":"                        i = i.wrapping_add(1);","highlight_start":1,"highlight_end":47},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":66157,"byte_end":66799,"line_start":1513,"line_end":1526,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if offset.wrapping_add(inf_strlen) < size {","highlight_start":13,"highlight_end":56},{"text":"                if 'I' as i32 == *src.offset(offset as isize) as i32 {","highlight_start":1,"highlight_end":71},{"text":"                    let mut i: u64 = 0;","highlight_start":1,"highlight_end":40},{"text":"                    i = 0;","highlight_start":1,"highlight_end":27},{"text":"                    while i < inf_strlen {","highlight_start":1,"highlight_end":43},{"text":"                        let fresh99 = offset;","highlight_start":1,"highlight_end":46},{"text":"                        offset = offset.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                        let fresh100 = bytes_written;","highlight_start":1,"highlight_end":54},{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":1,"highlight_end":71},{"text":"                        *data.offset(fresh100 as isize) = *src.offset(fresh99 as isize);","highlight_start":1,"highlight_end":89},{"text":"                        i = i.wrapping_add(1);","highlight_start":1,"highlight_end":47},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if offset.wrapping_add(inf_strlen) < size && 'I' as i32 == *src.offset(offset as isize) as i32 {\n                let mut i: u64 = 0;\n                i = 0;\n                while i < inf_strlen {\n                    let fresh99 = offset;\n                    offset = offset.wrapping_add(1);\n                    let fresh100 = bytes_written;\n                    bytes_written = bytes_written.wrapping_add(1);\n                    *data.offset(fresh100 as isize) = *src.offset(fresh99 as isize);\n                    i = i.wrapping_add(1);\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1513:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if offset.wrapping_add(inf_strlen) < size {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if 'I' as i32 == *src.offset(offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut i: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    i = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1525\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1526\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif offset.wrapping_add(inf_strlen) < size && 'I' as i32 == *src.offset(offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut i: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 i = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while i < inf_strlen {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let fresh99 = offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     offset = offset.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let fresh100 = bytes_written;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1520\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *data.offset(fresh100 as isize) = *src.offset(fresh99 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1522\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     i = i.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1523\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1524\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/json.rs","byte_start":66812,"byte_end":67466,"line_start":1527,"line_end":1540,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if offset.wrapping_add(nan_strlen) < size {","highlight_start":13,"highlight_end":56},{"text":"                if 'N' as i32 == *src.offset(offset as isize) as i32 {","highlight_start":1,"highlight_end":71},{"text":"                    let mut i_0: u64 = 0;","highlight_start":1,"highlight_end":42},{"text":"                    i_0 = 0;","highlight_start":1,"highlight_end":29},{"text":"                    while i_0 < nan_strlen {","highlight_start":1,"highlight_end":45},{"text":"                        let fresh101 = offset;","highlight_start":1,"highlight_end":47},{"text":"                        offset = offset.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                        let fresh102 = bytes_written;","highlight_start":1,"highlight_end":54},{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":1,"highlight_end":71},{"text":"                        *data.offset(fresh102 as isize) = *src.offset(fresh101 as isize);","highlight_start":1,"highlight_end":90},{"text":"                        i_0 = i_0.wrapping_add(1);","highlight_start":1,"highlight_end":51},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":66812,"byte_end":67466,"line_start":1527,"line_end":1540,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if offset.wrapping_add(nan_strlen) < size {","highlight_start":13,"highlight_end":56},{"text":"                if 'N' as i32 == *src.offset(offset as isize) as i32 {","highlight_start":1,"highlight_end":71},{"text":"                    let mut i_0: u64 = 0;","highlight_start":1,"highlight_end":42},{"text":"                    i_0 = 0;","highlight_start":1,"highlight_end":29},{"text":"                    while i_0 < nan_strlen {","highlight_start":1,"highlight_end":45},{"text":"                        let fresh101 = offset;","highlight_start":1,"highlight_end":47},{"text":"                        offset = offset.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                        let fresh102 = bytes_written;","highlight_start":1,"highlight_end":54},{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":1,"highlight_end":71},{"text":"                        *data.offset(fresh102 as isize) = *src.offset(fresh101 as isize);","highlight_start":1,"highlight_end":90},{"text":"                        i_0 = i_0.wrapping_add(1);","highlight_start":1,"highlight_end":51},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if offset.wrapping_add(nan_strlen) < size && 'N' as i32 == *src.offset(offset as isize) as i32 {\n                let mut i_0: u64 = 0;\n                i_0 = 0;\n                while i_0 < nan_strlen {\n                    let fresh101 = offset;\n                    offset = offset.wrapping_add(1);\n                    let fresh102 = bytes_written;\n                    bytes_written = bytes_written.wrapping_add(1);\n                    *data.offset(fresh102 as isize) = *src.offset(fresh101 as isize);\n                    i_0 = i_0.wrapping_add(1);\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1527:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if offset.wrapping_add(nan_strlen) < size {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if 'N' as i32 == *src.offset(offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1529\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut i_0: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1530\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    i_0 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1539\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1540\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif offset.wrapping_add(nan_strlen) < size && 'N' as i32 == *src.offset(offset as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut i_0: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1529\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 i_0 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1530\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while i_0 < nan_strlen {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1531\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let fresh101 = offset;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1532\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     offset = offset.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1533\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let fresh102 = bytes_written;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1534\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1535\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *data.offset(fresh102 as isize) = *src.offset(fresh101 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1536\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     i_0 = i_0.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1537\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1538\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":290,"byte_end":305,"line_start":11,"line_end":11,"column_start":12,"column_end":27,"is_primary":true,"text":[{"text":"#![feature(core_intrinsics)]","highlight_start":12,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:11:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(core_intrinsics)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":12572,"byte_end":12584,"line_start":358,"line_end":358,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"            data_size = data_size.wrapping_add(1);","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":11136,"byte_end":11136,"line_start":326,"line_end":326,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"        let mut data_size = 0;","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:358:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m358\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            data_size = data_size.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut data_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":24537,"byte_end":24549,"line_start":617,"line_end":617,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"                    elements = elements.wrapping_add(1);","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":20160,"byte_end":20160,"line_start":524,"line_end":524,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"        let mut elements = 0;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:617:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m617\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    elements = elements.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m524\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut elements\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":46396,"byte_end":46408,"line_start":1087,"line_end":1087,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1087:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1087\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":46661,"byte_end":46673,"line_start":1091,"line_end":1091,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1091:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1091\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":46888,"byte_end":46900,"line_start":1094,"line_end":1094,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1094:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1094\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":47717,"byte_end":47729,"line_start":1106,"line_end":1106,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1106:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":47945,"byte_end":47957,"line_start":1109,"line_end":1109,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1109:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":48212,"byte_end":48224,"line_start":1113,"line_end":1113,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1113:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":48478,"byte_end":48490,"line_start":1117,"line_end":1117,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1117:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":48740,"byte_end":48752,"line_start":1121,"line_end":1121,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1121:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":48968,"byte_end":48980,"line_start":1124,"line_end":1124,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1124:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1124\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":49234,"byte_end":49246,"line_start":1128,"line_end":1128,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1128:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1128\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":49531,"byte_end":49543,"line_start":1134,"line_end":1134,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1134:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":49773,"byte_end":49785,"line_start":1139,"line_end":1139,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1139:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":50016,"byte_end":50028,"line_start":1144,"line_end":1144,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1144:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":50258,"byte_end":50270,"line_start":1149,"line_end":1149,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1149:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":50505,"byte_end":50517,"line_start":1154,"line_end":1154,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1154:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1154\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":50752,"byte_end":50764,"line_start":1159,"line_end":1159,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1159:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1159\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":50996,"byte_end":51008,"line_start":1164,"line_end":1164,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1164:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":51240,"byte_end":51252,"line_start":1169,"line_end":1169,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1169:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1169\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":51483,"byte_end":51495,"line_start":1174,"line_end":1174,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1174:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":51764,"byte_end":51776,"line_start":1178,"line_end":1178,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                            bytes_written = bytes_written.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1178:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":52098,"byte_end":52110,"line_start":1185,"line_end":1185,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1185:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1185\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":52456,"byte_end":52468,"line_start":1194,"line_end":1194,"column_start":47,"column_end":59,"is_primary":true,"text":[{"text":"                bytes_written = bytes_written.wrapping_add(1);","highlight_start":47,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":45104,"byte_end":45104,"line_start":1058,"line_end":1058,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1194:47\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":53911,"byte_end":53923,"line_start":1231,"line_end":1231,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                    size = size.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":53554,"byte_end":53554,"line_start":1224,"line_end":1224,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                let mut size = 0;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1231:33\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    size = size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":54152,"byte_end":54164,"line_start":1236,"line_end":1236,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"                size = size.wrapping_add(1);","highlight_start":29,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":53554,"byte_end":53554,"line_start":1224,"line_end":1224,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                let mut size = 0;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1236:29\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                size = size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":58933,"byte_end":58945,"line_start":1345,"line_end":1345,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"            elements = elements.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":54785,"byte_end":54785,"line_start":1258,"line_end":1258,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"        let mut elements = 0;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1345:33\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1345\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            elements = elements.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut elements\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":62948,"byte_end":62960,"line_start":1433,"line_end":1433,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"                        elements = elements.wrapping_add(1);","highlight_start":45,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":59561,"byte_end":59561,"line_start":1368,"line_end":1368,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"        let mut elements = 0;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1433:45\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1433\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        elements = elements.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1368\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut elements\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":65183,"byte_end":65195,"line_start":1487,"line_end":1487,"column_start":51,"column_end":63,"is_primary":true,"text":[{"text":"                    bytes_written = bytes_written.wrapping_add(1);","highlight_start":51,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":63826,"byte_end":63826,"line_start":1464,"line_end":1464,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1487:51\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":65730,"byte_end":65742,"line_start":1499,"line_end":1499,"column_start":51,"column_end":63,"is_primary":true,"text":[{"text":"                    bytes_written = bytes_written.wrapping_add(1);","highlight_start":51,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":63826,"byte_end":63826,"line_start":1464,"line_end":1464,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1499:51\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":66593,"byte_end":66605,"line_start":1521,"line_end":1521,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":63826,"byte_end":63826,"line_start":1464,"line_end":1464,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1521:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":67255,"byte_end":67267,"line_start":1535,"line_end":1535,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                        bytes_written = bytes_written.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":63826,"byte_end":63826,"line_start":1464,"line_end":1464,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut bytes_written = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:1535:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1535\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        bytes_written = bytes_written.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bytes_written\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":129904,"byte_end":129916,"line_start":3196,"line_end":3196,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"            indent_size = indent_size.wrapping_add(1);","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":129397,"byte_end":129397,"line_start":3182,"line_end":3182,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"        let mut indent_size = 0;","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:3196:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3196\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            indent_size = indent_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3182\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut indent_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/json.rs","byte_start":130048,"byte_end":130060,"line_start":3199,"line_end":3199,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"            newline_size = newline_size.wrapping_add(1);","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/json.rs","byte_start":129431,"byte_end":129431,"line_start":3183,"line_end":3183,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"        let mut newline_size = 0;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/json.rs:3199:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            newline_size = newline_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut newline_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"aborting due to 39 previous errors; 16 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 39 previous errors; 16 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0554, E0689.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0554, E0689.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0554`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0554`.\u001b[0m\n"}
