{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":195,"byte_end":220,"line_start":8,"line_end":8,"column_start":1,"column_end":26,"is_primary":true,"text":[{"text":"#![feature(extern_types)]","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:8:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(extern_types)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":221,"byte_end":251,"line_start":9,"line_end":9,"column_start":1,"column_end":31,"is_primary":true,"text":[{"text":"#![feature(label_break_value)]","highlight_start":1,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the feature `label_break_value` has been stable since `1.65.0` and no longer requires an attribute to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"remove the attribute","code":null,"level":"help","spans":[{"file_name":"lib.rs","byte_start":221,"byte_end":251,"line_start":9,"line_end":9,"column_start":1,"column_end":31,"is_primary":true,"text":[{"text":"#![feature(label_break_value)]","highlight_start":1,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:9:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(label_break_value)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: remove the attribute\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the feature `label_break_value` has been stable since `1.65.0` and no longer requires an attribute to enable\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":252,"byte_end":278,"line_start":10,"line_end":10,"column_start":1,"column_end":27,"is_primary":true,"text":[{"text":"#![feature(register_tool)]","highlight_start":1,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:10:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(register_tool)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":305,"byte_end":335,"line_start":12,"line_end":12,"column_start":1,"column_end":31,"is_primary":true,"text":[{"text":"#![feature(strict_provenance)]","highlight_start":1,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:12:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(strict_provenance)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":336,"byte_end":364,"line_start":13,"line_end":13,"column_start":1,"column_end":29,"is_primary":true,"text":[{"text":"#![feature(core_intrinsics)]","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:13:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(core_intrinsics)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":365,"byte_end":388,"line_start":14,"line_end":14,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"#![feature(raw_ref_op)]","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:14:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(raw_ref_op)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/common/constants.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/common/constants.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/common/constants.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/common/context.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/common/context.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/common/context.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/common/transform.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/common/transform.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/common/transform.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/common/transform.rs","byte_start":10705,"byte_end":14000,"line_start":459,"line_end":520,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if (*word.offset(0 as isize) as i32) < 0xc0 {","highlight_start":1,"highlight_end":58},{"text":"                return 1;","highlight_start":1,"highlight_end":26},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                if (*word.offset(0 as isize) as i32) < 0xe0 {","highlight_start":1,"highlight_end":62},{"text":"                    if word_len < 2 {","highlight_start":1,"highlight_end":38},{"text":"                        return 1;","highlight_start":1,"highlight_end":34},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":59},{"text":"                        *word.offset(1 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":63},{"text":"                            | (*word.offset(0 as isize) as u32 & 0x1f) << 6,","highlight_start":1,"highlight_end":77},{"text":"                    ) as u32;","highlight_start":1,"highlight_end":30},{"text":"                    *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;","highlight_start":1,"highlight_end":85},{"text":"                    *word.offset(1 as isize) =","highlight_start":1,"highlight_end":47},{"text":"                        ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;","highlight_start":1,"highlight_end":100},{"text":"                    return 2;","highlight_start":1,"highlight_end":30},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if (*word.offset(0 as isize) as i32) < 0xf0 {","highlight_start":1,"highlight_end":66},{"text":"                        if word_len < 3 {","highlight_start":1,"highlight_end":42},{"text":"                            return word_len;","highlight_start":1,"highlight_end":45},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":63},{"text":"                            *word.offset(2 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":67},{"text":"                                | (*word.offset(1 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":80},{"text":"                                | (*word.offset(0 as isize) as u32 & 0xf) << 12,","highlight_start":1,"highlight_end":81},{"text":"                        ) as u32;","highlight_start":1,"highlight_end":34},{"text":"                        *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;","highlight_start":1,"highlight_end":89},{"text":"                        *word.offset(1 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":80},{"text":"                                | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":61},{"text":"                        *word.offset(2 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)","highlight_start":1,"highlight_end":97},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                        return 3;","highlight_start":1,"highlight_end":34},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::collapsible_else_if)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/common/transform.rs","byte_start":10705,"byte_end":14000,"line_start":459,"line_end":520,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if (*word.offset(0 as isize) as i32) < 0xc0 {","highlight_start":1,"highlight_end":58},{"text":"                return 1;","highlight_start":1,"highlight_end":26},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                if (*word.offset(0 as isize) as i32) < 0xe0 {","highlight_start":1,"highlight_end":62},{"text":"                    if word_len < 2 {","highlight_start":1,"highlight_end":38},{"text":"                        return 1;","highlight_start":1,"highlight_end":34},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":59},{"text":"                        *word.offset(1 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":63},{"text":"                            | (*word.offset(0 as isize) as u32 & 0x1f) << 6,","highlight_start":1,"highlight_end":77},{"text":"                    ) as u32;","highlight_start":1,"highlight_end":30},{"text":"                    *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;","highlight_start":1,"highlight_end":85},{"text":"                    *word.offset(1 as isize) =","highlight_start":1,"highlight_end":47},{"text":"                        ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;","highlight_start":1,"highlight_end":100},{"text":"                    return 2;","highlight_start":1,"highlight_end":30},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if (*word.offset(0 as isize) as i32) < 0xf0 {","highlight_start":1,"highlight_end":66},{"text":"                        if word_len < 3 {","highlight_start":1,"highlight_end":42},{"text":"                            return word_len;","highlight_start":1,"highlight_end":45},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":63},{"text":"                            *word.offset(2 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":67},{"text":"                                | (*word.offset(1 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":80},{"text":"                                | (*word.offset(0 as isize) as u32 & 0xf) << 12,","highlight_start":1,"highlight_end":81},{"text":"                        ) as u32;","highlight_start":1,"highlight_end":34},{"text":"                        *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;","highlight_start":1,"highlight_end":89},{"text":"                        *word.offset(1 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":80},{"text":"                                | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":61},{"text":"                        *word.offset(2 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)","highlight_start":1,"highlight_end":97},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                        return 3;","highlight_start":1,"highlight_end":34},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if (*word.offset(0 as isize) as i32) < 0xc0 {\n            return 1;\n        } else {\n            if (*word.offset(0 as isize) as i32) < 0xe0 {\n                if word_len < 2 {\n                    return 1;\n                }\n                scalar = (scalar as u32).wrapping_add(\n                    *word.offset(1 as isize) as u32 & 0x3f\n                        | (*word.offset(0 as isize) as u32 & 0x1f) << 6,\n                ) as u32;\n                *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;\n                *word.offset(1 as isize) =\n                    ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;\n                return 2;\n            } else {\n                if (*word.offset(0 as isize) as i32) < 0xf0 {\n                    if word_len < 3 {\n                        return word_len;\n                    }\n                    scalar = (scalar as u32).wrapping_add(\n                        *word.offset(2 as isize) as u32 & 0x3f\n                            | (*word.offset(1 as isize) as u32 & 0x3f) << 6\n                            | (*word.offset(0 as isize) as u32 & 0xf) << 12,\n                    ) as u32;\n                    *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;\n                    *word.offset(1 as isize) =\n                        ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\n                            | scalar >> 6 & 0x3f) as u8;\n                    *word.offset(2 as isize) =\n                        ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)\n                            as u8;\n                    return 3;\n                } else {\n                    if (*word.offset(0 as isize) as i32) < 0xf8 {\n                        if word_len < 4 {\n                            return word_len;\n                        }\n                        scalar = (scalar as u32).wrapping_add(\n                            *word.offset(3 as isize) as u32 & 0x3f\n                                | (*word.offset(2 as isize) as u32 & 0x3f) << 6\n                                | (*word.offset(1 as isize) as u32 & 0x3f) << 12\n                                | (*word.offset(0 as isize) as u32 & 0x7) << 18,\n                        ) as u32;\n                        *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\n                        *word.offset(1 as isize) =\n                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 12 & 0x3f) as u8;\n                        *word.offset(2 as isize) =\n                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 6 & 0x3f) as u8;\n                        *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\n                            as u32\n                            | scalar & 0x3f)\n                            as u8;\n                        return 4;\n                    }\n                }\n            }\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/common/transform.rs:459:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        } else {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m460\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if (*word.offset(0 as isize) as i32) < 0xc0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m462\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m520\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::collapsible_else_if)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        } else \u001b[0m\u001b[0m\u001b[38;5;10mif (*word.offset(0 as isize) as i32) < 0xc0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m460\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m462\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (*word.offset(0 as isize) as i32) < 0xe0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m463\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if word_len < 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m465\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m466\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m467\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(1 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m468\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         | (*word.offset(0 as isize) as u32 & 0x1f) << 6,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m470\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m473\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m474\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if (*word.offset(0 as isize) as i32) < 0xf0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if word_len < 3 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m479\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m480\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(2 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m481\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | (*word.offset(1 as isize) as u32 & 0x3f) << 6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m482\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | (*word.offset(0 as isize) as u32 & 0xf) << 12,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m483\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m484\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m485\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m486\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | scalar >> 6 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m488\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(2 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m489\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m490\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m492\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m493\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if (*word.offset(0 as isize) as i32) < 0xf8 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if word_len < 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *word.offset(3 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(2 as isize) as u32 & 0x3f) << 6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(1 as isize) as u32 & 0x3f) << 12\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(0 as isize) as u32 & 0x7) << 18,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m503\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m504\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m505\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m506\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 12 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m507\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(2 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m508\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 6 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m511\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | scalar & 0x3f)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return 4;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/common/transform.rs","byte_start":10810,"byte_end":13990,"line_start":462,"line_end":519,"column_start":20,"column_end":14,"is_primary":true,"text":[{"text":"            } else {","highlight_start":20,"highlight_end":21},{"text":"                if (*word.offset(0 as isize) as i32) < 0xe0 {","highlight_start":1,"highlight_end":62},{"text":"                    if word_len < 2 {","highlight_start":1,"highlight_end":38},{"text":"                        return 1;","highlight_start":1,"highlight_end":34},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":59},{"text":"                        *word.offset(1 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":63},{"text":"                            | (*word.offset(0 as isize) as u32 & 0x1f) << 6,","highlight_start":1,"highlight_end":77},{"text":"                    ) as u32;","highlight_start":1,"highlight_end":30},{"text":"                    *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;","highlight_start":1,"highlight_end":85},{"text":"                    *word.offset(1 as isize) =","highlight_start":1,"highlight_end":47},{"text":"                        ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;","highlight_start":1,"highlight_end":100},{"text":"                    return 2;","highlight_start":1,"highlight_end":30},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if (*word.offset(0 as isize) as i32) < 0xf0 {","highlight_start":1,"highlight_end":66},{"text":"                        if word_len < 3 {","highlight_start":1,"highlight_end":42},{"text":"                            return word_len;","highlight_start":1,"highlight_end":45},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":63},{"text":"                            *word.offset(2 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":67},{"text":"                                | (*word.offset(1 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":80},{"text":"                                | (*word.offset(0 as isize) as u32 & 0xf) << 12,","highlight_start":1,"highlight_end":81},{"text":"                        ) as u32;","highlight_start":1,"highlight_end":34},{"text":"                        *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;","highlight_start":1,"highlight_end":89},{"text":"                        *word.offset(1 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":80},{"text":"                                | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":61},{"text":"                        *word.offset(2 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)","highlight_start":1,"highlight_end":97},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                        return 3;","highlight_start":1,"highlight_end":34},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/common/transform.rs","byte_start":10810,"byte_end":13990,"line_start":462,"line_end":519,"column_start":20,"column_end":14,"is_primary":true,"text":[{"text":"            } else {","highlight_start":20,"highlight_end":21},{"text":"                if (*word.offset(0 as isize) as i32) < 0xe0 {","highlight_start":1,"highlight_end":62},{"text":"                    if word_len < 2 {","highlight_start":1,"highlight_end":38},{"text":"                        return 1;","highlight_start":1,"highlight_end":34},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":59},{"text":"                        *word.offset(1 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":63},{"text":"                            | (*word.offset(0 as isize) as u32 & 0x1f) << 6,","highlight_start":1,"highlight_end":77},{"text":"                    ) as u32;","highlight_start":1,"highlight_end":30},{"text":"                    *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;","highlight_start":1,"highlight_end":85},{"text":"                    *word.offset(1 as isize) =","highlight_start":1,"highlight_end":47},{"text":"                        ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;","highlight_start":1,"highlight_end":100},{"text":"                    return 2;","highlight_start":1,"highlight_end":30},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if (*word.offset(0 as isize) as i32) < 0xf0 {","highlight_start":1,"highlight_end":66},{"text":"                        if word_len < 3 {","highlight_start":1,"highlight_end":42},{"text":"                            return word_len;","highlight_start":1,"highlight_end":45},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":63},{"text":"                            *word.offset(2 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":67},{"text":"                                | (*word.offset(1 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":80},{"text":"                                | (*word.offset(0 as isize) as u32 & 0xf) << 12,","highlight_start":1,"highlight_end":81},{"text":"                        ) as u32;","highlight_start":1,"highlight_end":34},{"text":"                        *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;","highlight_start":1,"highlight_end":89},{"text":"                        *word.offset(1 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":80},{"text":"                                | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":61},{"text":"                        *word.offset(2 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)","highlight_start":1,"highlight_end":97},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                        return 3;","highlight_start":1,"highlight_end":34},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if (*word.offset(0 as isize) as i32) < 0xe0 {\n                if word_len < 2 {\n                    return 1;\n                }\n                scalar = (scalar as u32).wrapping_add(\n                    *word.offset(1 as isize) as u32 & 0x3f\n                        | (*word.offset(0 as isize) as u32 & 0x1f) << 6,\n                ) as u32;\n                *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;\n                *word.offset(1 as isize) =\n                    ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;\n                return 2;\n            } else {\n                if (*word.offset(0 as isize) as i32) < 0xf0 {\n                    if word_len < 3 {\n                        return word_len;\n                    }\n                    scalar = (scalar as u32).wrapping_add(\n                        *word.offset(2 as isize) as u32 & 0x3f\n                            | (*word.offset(1 as isize) as u32 & 0x3f) << 6\n                            | (*word.offset(0 as isize) as u32 & 0xf) << 12,\n                    ) as u32;\n                    *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;\n                    *word.offset(1 as isize) =\n                        ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\n                            | scalar >> 6 & 0x3f) as u8;\n                    *word.offset(2 as isize) =\n                        ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)\n                            as u8;\n                    return 3;\n                } else {\n                    if (*word.offset(0 as isize) as i32) < 0xf8 {\n                        if word_len < 4 {\n                            return word_len;\n                        }\n                        scalar = (scalar as u32).wrapping_add(\n                            *word.offset(3 as isize) as u32 & 0x3f\n                                | (*word.offset(2 as isize) as u32 & 0x3f) << 6\n                                | (*word.offset(1 as isize) as u32 & 0x3f) << 12\n                                | (*word.offset(0 as isize) as u32 & 0x7) << 18,\n                        ) as u32;\n                        *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\n                        *word.offset(1 as isize) =\n                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 12 & 0x3f) as u8;\n                        *word.offset(2 as isize) =\n                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 6 & 0x3f) as u8;\n                        *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\n                            as u32\n                            | scalar & 0x3f)\n                            as u8;\n                        return 4;\n                    }\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/common/transform.rs:462:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m462\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            } else {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m463\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if (*word.offset(0 as isize) as i32) < 0xe0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if word_len < 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m465\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m462\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            } else \u001b[0m\u001b[0m\u001b[38;5;10mif (*word.offset(0 as isize) as i32) < 0xe0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m463\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if word_len < 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m465\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m466\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m467\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(1 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m468\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         | (*word.offset(0 as isize) as u32 & 0x1f) << 6,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m470\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *word.offset(0 as isize) = (0xc0 | scalar >> 6 & 0x1fu32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m473\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m474\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if (*word.offset(0 as isize) as i32) < 0xf0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if word_len < 3 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m479\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m480\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(2 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m481\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | (*word.offset(1 as isize) as u32 & 0x3f) << 6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m482\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | (*word.offset(0 as isize) as u32 & 0xf) << 12,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m483\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m484\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m485\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m486\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | scalar >> 6 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m488\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(2 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m489\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m490\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m492\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m493\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if (*word.offset(0 as isize) as i32) < 0xf8 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if word_len < 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *word.offset(3 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(2 as isize) as u32 & 0x3f) << 6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(1 as isize) as u32 & 0x3f) << 12\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(0 as isize) as u32 & 0x7) << 18,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m503\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m504\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m505\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m506\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 12 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m507\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(2 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m508\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 6 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m511\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | scalar & 0x3f)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return 4;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/common/transform.rs","byte_start":11482,"byte_end":13976,"line_start":475,"line_end":518,"column_start":24,"column_end":18,"is_primary":true,"text":[{"text":"                } else {","highlight_start":24,"highlight_end":25},{"text":"                    if (*word.offset(0 as isize) as i32) < 0xf0 {","highlight_start":1,"highlight_end":66},{"text":"                        if word_len < 3 {","highlight_start":1,"highlight_end":42},{"text":"                            return word_len;","highlight_start":1,"highlight_end":45},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":63},{"text":"                            *word.offset(2 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":67},{"text":"                                | (*word.offset(1 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":80},{"text":"                                | (*word.offset(0 as isize) as u32 & 0xf) << 12,","highlight_start":1,"highlight_end":81},{"text":"                        ) as u32;","highlight_start":1,"highlight_end":34},{"text":"                        *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;","highlight_start":1,"highlight_end":89},{"text":"                        *word.offset(1 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":80},{"text":"                                | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":61},{"text":"                        *word.offset(2 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)","highlight_start":1,"highlight_end":97},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                        return 3;","highlight_start":1,"highlight_end":34},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/common/transform.rs","byte_start":11482,"byte_end":13976,"line_start":475,"line_end":518,"column_start":24,"column_end":18,"is_primary":true,"text":[{"text":"                } else {","highlight_start":24,"highlight_end":25},{"text":"                    if (*word.offset(0 as isize) as i32) < 0xf0 {","highlight_start":1,"highlight_end":66},{"text":"                        if word_len < 3 {","highlight_start":1,"highlight_end":42},{"text":"                            return word_len;","highlight_start":1,"highlight_end":45},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":63},{"text":"                            *word.offset(2 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":67},{"text":"                                | (*word.offset(1 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":80},{"text":"                                | (*word.offset(0 as isize) as u32 & 0xf) << 12,","highlight_start":1,"highlight_end":81},{"text":"                        ) as u32;","highlight_start":1,"highlight_end":34},{"text":"                        *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;","highlight_start":1,"highlight_end":89},{"text":"                        *word.offset(1 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":80},{"text":"                                | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":61},{"text":"                        *word.offset(2 as isize) =","highlight_start":1,"highlight_end":51},{"text":"                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)","highlight_start":1,"highlight_end":97},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                        return 3;","highlight_start":1,"highlight_end":34},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if (*word.offset(0 as isize) as i32) < 0xf0 {\n                    if word_len < 3 {\n                        return word_len;\n                    }\n                    scalar = (scalar as u32).wrapping_add(\n                        *word.offset(2 as isize) as u32 & 0x3f\n                            | (*word.offset(1 as isize) as u32 & 0x3f) << 6\n                            | (*word.offset(0 as isize) as u32 & 0xf) << 12,\n                    ) as u32;\n                    *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;\n                    *word.offset(1 as isize) =\n                        ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\n                            | scalar >> 6 & 0x3f) as u8;\n                    *word.offset(2 as isize) =\n                        ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)\n                            as u8;\n                    return 3;\n                } else {\n                    if (*word.offset(0 as isize) as i32) < 0xf8 {\n                        if word_len < 4 {\n                            return word_len;\n                        }\n                        scalar = (scalar as u32).wrapping_add(\n                            *word.offset(3 as isize) as u32 & 0x3f\n                                | (*word.offset(2 as isize) as u32 & 0x3f) << 6\n                                | (*word.offset(1 as isize) as u32 & 0x3f) << 12\n                                | (*word.offset(0 as isize) as u32 & 0x7) << 18,\n                        ) as u32;\n                        *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\n                        *word.offset(1 as isize) =\n                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 12 & 0x3f) as u8;\n                        *word.offset(2 as isize) =\n                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 6 & 0x3f) as u8;\n                        *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\n                            as u32\n                            | scalar & 0x3f)\n                            as u8;\n                        return 4;\n                    }\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/common/transform.rs:475:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                } else {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if (*word.offset(0 as isize) as i32) < 0xf0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if word_len < 3 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                } else \u001b[0m\u001b[0m\u001b[38;5;10mif (*word.offset(0 as isize) as i32) < 0xf0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if word_len < 3 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m479\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m480\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(2 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m481\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | (*word.offset(1 as isize) as u32 & 0x3f) << 6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m482\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | (*word.offset(0 as isize) as u32 & 0xf) << 12,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m483\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m484\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(0 as isize) = (0xe0 | scalar >> 12 & 0xfu32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m485\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m486\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | scalar >> 6 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m488\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     *word.offset(2 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m489\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32 | scalar & 0x3f)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m490\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m492\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m493\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if (*word.offset(0 as isize) as i32) < 0xf8 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if word_len < 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *word.offset(3 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(2 as isize) as u32 & 0x3f) << 6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(1 as isize) as u32 & 0x3f) << 12\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(0 as isize) as u32 & 0x7) << 18,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m503\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m504\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m505\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m506\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 12 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m507\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(2 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m508\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 6 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m511\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | scalar & 0x3f)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return 4;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/common/transform.rs","byte_start":12517,"byte_end":13958,"line_start":493,"line_end":517,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else {","highlight_start":28,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/common/transform.rs","byte_start":12517,"byte_end":13958,"line_start":493,"line_end":517,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else {","highlight_start":28,"highlight_end":29},{"text":"                        if (*word.offset(0 as isize) as i32) < 0xf8 {","highlight_start":1,"highlight_end":70},{"text":"                            if word_len < 4 {","highlight_start":1,"highlight_end":46},{"text":"                                return word_len;","highlight_start":1,"highlight_end":49},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            scalar = (scalar as u32).wrapping_add(","highlight_start":1,"highlight_end":67},{"text":"                                *word.offset(3 as isize) as u32 & 0x3f","highlight_start":1,"highlight_end":71},{"text":"                                    | (*word.offset(2 as isize) as u32 & 0x3f) << 6","highlight_start":1,"highlight_end":84},{"text":"                                    | (*word.offset(1 as isize) as u32 & 0x3f) << 12","highlight_start":1,"highlight_end":85},{"text":"                                    | (*word.offset(0 as isize) as u32 & 0x7) << 18,","highlight_start":1,"highlight_end":85},{"text":"                            ) as u32;","highlight_start":1,"highlight_end":38},{"text":"                            *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;","highlight_start":1,"highlight_end":93},{"text":"                            *word.offset(1 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 12 & 0x3f) as u8;","highlight_start":1,"highlight_end":66},{"text":"                            *word.offset(2 as isize) =","highlight_start":1,"highlight_end":55},{"text":"                                ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32","highlight_start":1,"highlight_end":84},{"text":"                                    | scalar >> 6 & 0x3f) as u8;","highlight_start":1,"highlight_end":65},{"text":"                            *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)","highlight_start":1,"highlight_end":100},{"text":"                                as u32","highlight_start":1,"highlight_end":39},{"text":"                                | scalar & 0x3f)","highlight_start":1,"highlight_end":49},{"text":"                                as u8;","highlight_start":1,"highlight_end":39},{"text":"                            return 4;","highlight_start":1,"highlight_end":38},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if (*word.offset(0 as isize) as i32) < 0xf8 {\n                        if word_len < 4 {\n                            return word_len;\n                        }\n                        scalar = (scalar as u32).wrapping_add(\n                            *word.offset(3 as isize) as u32 & 0x3f\n                                | (*word.offset(2 as isize) as u32 & 0x3f) << 6\n                                | (*word.offset(1 as isize) as u32 & 0x3f) << 12\n                                | (*word.offset(0 as isize) as u32 & 0x7) << 18,\n                        ) as u32;\n                        *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\n                        *word.offset(1 as isize) =\n                            ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 12 & 0x3f) as u8;\n                        *word.offset(2 as isize) =\n                            ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\n                                | scalar >> 6 & 0x3f) as u8;\n                        *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\n                            as u32\n                            | scalar & 0x3f)\n                            as u8;\n                        return 4;\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/common/transform.rs:493:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m493\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    } else {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if (*word.offset(0 as isize) as i32) < 0xf8 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if word_len < 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m493\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    } else \u001b[0m\u001b[0m\u001b[38;5;10mif (*word.offset(0 as isize) as i32) < 0xf8 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if word_len < 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return word_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         scalar = (scalar as u32).wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             *word.offset(3 as isize) as u32 & 0x3f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(2 as isize) as u32 & 0x3f) << 6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(1 as isize) as u32 & 0x3f) << 12\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | (*word.offset(0 as isize) as u32 & 0x7) << 18,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m503\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(0 as isize) = (0xf0 | scalar >> 18 & 0x7u32) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m504\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(1 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m505\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(1 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m506\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 12 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m507\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(2 as isize) =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m508\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((*word.offset(2 as isize) as i32 & 0xc0i32) as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 | scalar >> 6 & 0x3f) as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         *word.offset(3 as isize) = ((*word.offset(3 as isize) as i32 & 0xc0i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m511\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             | scalar & 0x3f)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return 4;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/bit_reader.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/dec/bit_reader.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/bit_reader.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/bit_reader.rs","byte_start":3862,"byte_end":3989,"line_start":144,"line_end":148,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if BrotliGetAvailableBits(br) == 0 {","highlight_start":9,"highlight_end":45},{"text":"            if BrotliPullByte(br) == 0 {","highlight_start":1,"highlight_end":41},{"text":"                return 0;","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::collapsible_if)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/dec/bit_reader.rs","byte_start":3862,"byte_end":3989,"line_start":144,"line_end":148,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if BrotliGetAvailableBits(br) == 0 {","highlight_start":9,"highlight_end":45},{"text":"            if BrotliPullByte(br) == 0 {","highlight_start":1,"highlight_end":41},{"text":"                return 0;","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if BrotliGetAvailableBits(br) == 0 && BrotliPullByte(br) == 0 {\n            return 0;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/bit_reader.rs:144:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if BrotliGetAvailableBits(br) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if BrotliPullByte(br) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::collapsible_if)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif BrotliGetAvailableBits(br) == 0 && BrotliPullByte(br) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":237860,"byte_end":237876,"line_start":8778,"line_end":8778,"column_start":63,"column_end":79,"is_primary":true,"text":[{"text":"                            (*s).meta_block_remaining_len |= (bits << i * 8i32) as i32;","highlight_start":63,"highlight_end":79}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::precedence)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":237860,"byte_end":237876,"line_start":8778,"line_end":8778,"column_start":63,"column_end":79,"is_primary":true,"text":[{"text":"                            (*s).meta_block_remaining_len |= (bits << i * 8i32) as i32;","highlight_start":63,"highlight_end":79}],"label":null,"suggested_replacement":"bits << (i * 8i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:8778:63\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8778\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   (*s).meta_block_remaining_len |= (bits << i * 8i32) as i32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `bits << (i * 8i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::precedence)]` on by default\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":239944,"byte_end":239960,"line_start":8817,"line_end":8817,"column_start":63,"column_end":79,"is_primary":true,"text":[{"text":"                            (*s).meta_block_remaining_len |= (bits << i * 4i32) as i32;","highlight_start":63,"highlight_end":79}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":239944,"byte_end":239960,"line_start":8817,"line_end":8817,"column_start":63,"column_end":79,"is_primary":true,"text":[{"text":"                            (*s).meta_block_remaining_len |= (bits << i * 4i32) as i32;","highlight_start":63,"highlight_end":79}],"label":null,"suggested_replacement":"bits << (i * 4i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:8817:63\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8817\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   (*s).meta_block_remaining_len |= (bits << i * 4i32) as i32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `bits << (i * 4i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":291381,"byte_end":291413,"line_start":10194,"line_end":10194,"column_start":48,"column_end":80,"is_primary":true,"text":[{"text":"            (*s).distance_code = (*s).dist_rb[((*s).dist_rb_idx - offset & 3i32) as usize];","highlight_start":48,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":291381,"byte_end":291413,"line_start":10194,"line_end":10194,"column_start":48,"column_end":80,"is_primary":true,"text":[{"text":"            (*s).distance_code = (*s).dist_rb[((*s).dist_rb_idx - offset & 3i32) as usize];","highlight_start":48,"highlight_end":80}],"label":null,"suggested_replacement":"((*s).dist_rb_idx - offset) & 3i32","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10194:48\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            (*s).distance_code = (*s).dist_rb[((*s).dist_rb_idx - offset & 3i32) as usize];\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `((*s).dist_rb_idx - offset) & 3i32`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":291800,"byte_end":291820,"line_start":10205,"line_end":10205,"column_start":22,"column_end":42,"is_primary":true,"text":[{"text":"            delta = (0x605142 >> 4 * base & 0xf) - 3;","highlight_start":22,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":291800,"byte_end":291820,"line_start":10205,"line_end":10205,"column_start":22,"column_end":42,"is_primary":true,"text":[{"text":"            delta = (0x605142 >> 4 * base & 0xf) - 3;","highlight_start":22,"highlight_end":42}],"label":null,"suggested_replacement":"0x605142 >> (4 * base)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10205:22\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            delta = (0x605142 >> 4 * base & 0xf) - 3;\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `0x605142 >> (4 * base)`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":291896,"byte_end":291935,"line_start":10207,"line_end":10207,"column_start":31,"column_end":70,"is_primary":true,"text":[{"text":"                (*s).dist_rb[((*s).dist_rb_idx + index_delta & 0x3i32) as usize] + delta;","highlight_start":31,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":291896,"byte_end":291935,"line_start":10207,"line_end":10207,"column_start":31,"column_end":70,"is_primary":true,"text":[{"text":"                (*s).dist_rb[((*s).dist_rb_idx + index_delta & 0x3i32) as usize] + delta;","highlight_start":31,"highlight_end":70}],"label":null,"suggested_replacement":"((*s).dist_rb_idx + index_delta) & 0x3i32","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10207:31\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10207\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                (*s).dist_rb[((*s).dist_rb_idx + index_delta & 0x3i32) as usize] + delta;\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `((*s).dist_rb_idx + index_delta) & 0x3i32`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":305660,"byte_end":305707,"line_start":10551,"line_end":10551,"column_start":49,"column_end":96,"is_primary":true,"text":[{"text":"                            let mut src_start = pos - (*s).distance_code & (*s).ringbuffer_mask;","highlight_start":49,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":305660,"byte_end":305707,"line_start":10551,"line_end":10551,"column_start":49,"column_end":96,"is_primary":true,"text":[{"text":"                            let mut src_start = pos - (*s).distance_code & (*s).ringbuffer_mask;","highlight_start":49,"highlight_end":96}],"label":null,"suggested_replacement":"(pos - (*s).distance_code) & (*s).ringbuffer_mask","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10551:49\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10551\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   let mut src_start = pos - (*s).distance_code & (*s).ringbuffer_mask;\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `(pos - (*s).distance_code) & (*s).ringbuffer_mask`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":310514,"byte_end":310561,"line_start":10642,"line_end":10642,"column_start":42,"column_end":89,"is_primary":true,"text":[{"text":"                                .offset((pos - (*s).distance_code & (*s).ringbuffer_mask) as isize);","highlight_start":42,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":310514,"byte_end":310561,"line_start":10642,"line_end":10642,"column_start":42,"column_end":89,"is_primary":true,"text":[{"text":"                                .offset((pos - (*s).distance_code & (*s).ringbuffer_mask) as isize);","highlight_start":42,"highlight_end":89}],"label":null,"suggested_replacement":"(pos - (*s).distance_code) & (*s).ringbuffer_mask","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10642:42\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10642\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   .offset((pos - (*s).distance_code & (*s).ringbuffer_mask) as isize);\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `(pos - (*s).distance_code) & (*s).ringbuffer_mask`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":315382,"byte_end":315412,"line_start":10728,"line_end":10728,"column_start":42,"column_end":72,"is_primary":true,"text":[{"text":"                                .offset((pos - 1 & (*s).ringbuffer_mask) as isize);","highlight_start":42,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":315382,"byte_end":315412,"line_start":10728,"line_end":10728,"column_start":42,"column_end":72,"is_primary":true,"text":[{"text":"                                .offset((pos - 1 & (*s).ringbuffer_mask) as isize);","highlight_start":42,"highlight_end":72}],"label":null,"suggested_replacement":"(pos - 1) & (*s).ringbuffer_mask","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10728:42\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10728\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   .offset((pos - 1 & (*s).ringbuffer_mask) as isize);\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `(pos - 1) & (*s).ringbuffer_mask`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/decode.rs","byte_start":315526,"byte_end":315556,"line_start":10730,"line_end":10730,"column_start":42,"column_end":72,"is_primary":true,"text":[{"text":"                                .offset((pos - 2 & (*s).ringbuffer_mask) as isize);","highlight_start":42,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":315526,"byte_end":315556,"line_start":10730,"line_end":10730,"column_start":42,"column_end":72,"is_primary":true,"text":[{"text":"                                .offset((pos - 2 & (*s).ringbuffer_mask) as isize);","highlight_start":42,"highlight_end":72}],"label":null,"suggested_replacement":"(pos - 2) & (*s).ringbuffer_mask","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10730:42\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10730\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   .offset((pos - 2 & (*s).ringbuffer_mask) as isize);\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `(pos - 2) & (*s).ringbuffer_mask`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":2664,"byte_end":2684,"line_start":65,"line_end":65,"column_start":24,"column_end":44,"is_primary":true,"text":[{"text":"        let mut left = 1 << len - root_bits;","highlight_start":24,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":2664,"byte_end":2684,"line_start":65,"line_end":65,"column_start":24,"column_end":44,"is_primary":true,"text":[{"text":"        let mut left = 1 << len - root_bits;","highlight_start":24,"highlight_end":44}],"label":null,"suggested_replacement":"1 << (len - root_bits)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:65:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut left = 1 << len - root_bits;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << (len - root_bits)`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":7384,"byte_end":7398,"line_start":183,"line_end":183,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":7384,"byte_end":7398,"line_start":183,"line_end":183,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":"1 << (8 - 1 + 0)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:183:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        key_step = 1 << 8 - 1 + 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << (8 - 1 + 0)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":9475,"byte_end":9489,"line_start":250,"line_end":250,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":9475,"byte_end":9489,"line_start":250,"line_end":250,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":"1 << (8 - 1 + 0)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:250:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m250\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        key_step = 1 << 8 - 1 + 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << (8 - 1 + 0)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10800,"byte_end":10831,"line_start":285,"line_end":285,"column_start":20,"column_end":51,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0 >> root_bits - 1;","highlight_start":20,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10800,"byte_end":10831,"line_start":285,"line_end":285,"column_start":20,"column_end":51,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0 >> root_bits - 1;","highlight_start":20,"highlight_end":51}],"label":null,"suggested_replacement":"1 << 8 - 1 + 0 >> (root_bits - 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:285:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        key_step = 1 << 8 - 1 + 0 >> root_bits - 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << 8 - 1 + 0 >> (root_bits - 1)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10800,"byte_end":10814,"line_start":285,"line_end":285,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0 >> root_bits - 1;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10800,"byte_end":10814,"line_start":285,"line_end":285,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        key_step = 1 << 8 - 1 + 0 >> root_bits - 1;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":"1 << (8 - 1 + 0)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:285:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        key_step = 1 << 8 - 1 + 0 >> root_bits - 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << (8 - 1 + 0)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10852,"byte_end":10866,"line_start":286,"line_end":286,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        sub_key = (1 << 8 - 1 + 0) << 1;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10852,"byte_end":10866,"line_start":286,"line_end":286,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"        sub_key = (1 << 8 - 1 + 0) << 1;","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":"1 << (8 - 1 + 0)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:286:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m286\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        sub_key = (1 << 8 - 1 + 0) << 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << (8 - 1 + 0)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10897,"byte_end":10911,"line_start":287,"line_end":287,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"        sub_key_step = 1 << 8 - 1 + 0;","highlight_start":24,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":10897,"byte_end":10911,"line_start":287,"line_end":287,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"        sub_key_step = 1 << 8 - 1 + 0;","highlight_start":24,"highlight_end":38}],"label":null,"suggested_replacement":"1 << (8 - 1 + 0)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:287:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        sub_key_step = 1 << 8 - 1 + 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << (8 - 1 + 0)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/dec/huffman.rs","byte_start":11122,"byte_end":11136,"line_start":293,"line_end":293,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"                if sub_key == (1 << 8 - 1 + 0) << 1 {","highlight_start":32,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/dec/huffman.rs","byte_start":11122,"byte_end":11136,"line_start":293,"line_end":293,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"                if sub_key == (1 << 8 - 1 + 0) << 1 {","highlight_start":32,"highlight_end":46}],"label":null,"suggested_replacement":"1 << (8 - 1 + 0)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/huffman.rs:293:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if sub_key == (1 << 8 - 1 + 0) << 1 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `1 << (8 - 1 + 0)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":13933,"byte_end":13945,"line_start":522,"line_end":522,"column_start":16,"column_end":28,"is_primary":true,"text":[{"text":"        return h >> 32 - 14;","highlight_start":16,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":13933,"byte_end":13945,"line_start":522,"line_end":522,"column_start":16,"column_end":28,"is_primary":true,"text":[{"text":"        return h >> 32 - 14;","highlight_start":16,"highlight_end":28}],"label":null,"suggested_replacement":"h >> (32 - 14)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:522:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m522\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return h >> 32 - 14;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 14)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":19592,"byte_end":19659,"line_start":684,"line_end":684,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":19592,"byte_end":19659,"line_start":684,"line_end":684,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:684:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m684\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":19716,"byte_end":19731,"line_start":686,"line_end":686,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":19716,"byte_end":19731,"line_start":686,"line_end":686,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 16i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:686:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m686\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 16i32) as u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 16i32)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":24799,"byte_end":24866,"line_start":839,"line_end":839,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":24799,"byte_end":24866,"line_start":839,"line_end":839,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:839:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m839\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":24923,"byte_end":24938,"line_start":841,"line_end":841,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":24923,"byte_end":24938,"line_start":841,"line_end":841,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 16i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:841:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 16i32) as u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 16i32)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":28930,"byte_end":30051,"line_start":952,"line_end":972,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {","highlight_start":17,"highlight_end":101},{"text":"                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":87},{"text":"                        len_1 = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":58},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len_1 >= 4 {","highlight_start":1,"highlight_end":40},{"text":"                            let score_1 = BackwardReferenceScore(len_1, backward_0);","highlight_start":1,"highlight_end":85},{"text":"                            if best_score < score_1 {","highlight_start":1,"highlight_end":54},{"text":"                                best_len = len_1;","highlight_start":1,"highlight_end":50},{"text":"                                (*out).len = len_1;","highlight_start":1,"highlight_end":52},{"text":"                                compare_char =","highlight_start":1,"highlight_end":47},{"text":"                                    *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;","highlight_start":1,"highlight_end":101},{"text":"                                best_score = score_1;","highlight_start":1,"highlight_end":54},{"text":"                                (*out).score = score_1;","highlight_start":1,"highlight_end":56},{"text":"                                (*out).distance = backward_0;","highlight_start":1,"highlight_end":62},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":28930,"byte_end":30051,"line_start":952,"line_end":972,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {","highlight_start":17,"highlight_end":101},{"text":"                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":87},{"text":"                        len_1 = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":58},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len_1 >= 4 {","highlight_start":1,"highlight_end":40},{"text":"                            let score_1 = BackwardReferenceScore(len_1, backward_0);","highlight_start":1,"highlight_end":85},{"text":"                            if best_score < score_1 {","highlight_start":1,"highlight_end":54},{"text":"                                best_len = len_1;","highlight_start":1,"highlight_end":50},{"text":"                                (*out).len = len_1;","highlight_start":1,"highlight_end":52},{"text":"                                compare_char =","highlight_start":1,"highlight_end":47},{"text":"                                    *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;","highlight_start":1,"highlight_end":101},{"text":"                                best_score = score_1;","highlight_start":1,"highlight_end":54},{"text":"                                (*out).score = score_1;","highlight_start":1,"highlight_end":56},{"text":"                                (*out).distance = backward_0;","highlight_start":1,"highlight_end":62},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) && !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\n                    len_1 = FindMatchLengthWithLimit(\n                        &*data.offset(prev_ix as isize),\n                        &*data.offset(cur_ix_masked as isize),\n                        max_length,\n                    );\n                    if len_1 >= 4 {\n                        let score_1 = BackwardReferenceScore(len_1, backward_0);\n                        if best_score < score_1 {\n                            best_len = len_1;\n                            (*out).len = len_1;\n                            compare_char =\n                                *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;\n                            best_score = score_1;\n                            (*out).score = score_1;\n                            (*out).distance = backward_0;\n                        }\n                    }\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:952:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m952\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m953\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m954\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        len_1 = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m955\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m971\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m972\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m952\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10mif !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) && !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m953\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     len_1 = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m954\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m955\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m956\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m957\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m958\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if len_1 >= 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m959\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let score_1 = BackwardReferenceScore(len_1, backward_0);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m960\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score_1 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m961\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_len = len_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m962\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).len = len_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m963\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             compare_char =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m964\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m965\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_score = score_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m966\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).score = score_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m967\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).distance = backward_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m968\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m969\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m970\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":30462,"byte_end":30529,"line_start":994,"line_end":994,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":30462,"byte_end":30529,"line_start":994,"line_end":994,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:994:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m994\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":30586,"byte_end":30601,"line_start":996,"line_end":996,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 17i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":30586,"byte_end":30601,"line_start":996,"line_end":996,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 17i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 17i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:996:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m996\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 17i32) as u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 17i32)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":34593,"byte_end":35714,"line_start":1107,"line_end":1127,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {","highlight_start":17,"highlight_end":101},{"text":"                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":87},{"text":"                        len_1 = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":58},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len_1 >= 4 {","highlight_start":1,"highlight_end":40},{"text":"                            let score_1 = BackwardReferenceScore(len_1, backward_0);","highlight_start":1,"highlight_end":85},{"text":"                            if best_score < score_1 {","highlight_start":1,"highlight_end":54},{"text":"                                best_len = len_1;","highlight_start":1,"highlight_end":50},{"text":"                                (*out).len = len_1;","highlight_start":1,"highlight_end":52},{"text":"                                compare_char =","highlight_start":1,"highlight_end":47},{"text":"                                    *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;","highlight_start":1,"highlight_end":101},{"text":"                                best_score = score_1;","highlight_start":1,"highlight_end":54},{"text":"                                (*out).score = score_1;","highlight_start":1,"highlight_end":56},{"text":"                                (*out).distance = backward_0;","highlight_start":1,"highlight_end":62},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":34593,"byte_end":35714,"line_start":1107,"line_end":1127,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {","highlight_start":17,"highlight_end":101},{"text":"                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":87},{"text":"                        len_1 = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":58},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len_1 >= 4 {","highlight_start":1,"highlight_end":40},{"text":"                            let score_1 = BackwardReferenceScore(len_1, backward_0);","highlight_start":1,"highlight_end":85},{"text":"                            if best_score < score_1 {","highlight_start":1,"highlight_end":54},{"text":"                                best_len = len_1;","highlight_start":1,"highlight_end":50},{"text":"                                (*out).len = len_1;","highlight_start":1,"highlight_end":52},{"text":"                                compare_char =","highlight_start":1,"highlight_end":47},{"text":"                                    *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;","highlight_start":1,"highlight_end":101},{"text":"                                best_score = score_1;","highlight_start":1,"highlight_end":54},{"text":"                                (*out).score = score_1;","highlight_start":1,"highlight_end":56},{"text":"                                (*out).distance = backward_0;","highlight_start":1,"highlight_end":62},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) && !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\n                    len_1 = FindMatchLengthWithLimit(\n                        &*data.offset(prev_ix as isize),\n                        &*data.offset(cur_ix_masked as isize),\n                        max_length,\n                    );\n                    if len_1 >= 4 {\n                        let score_1 = BackwardReferenceScore(len_1, backward_0);\n                        if best_score < score_1 {\n                            best_len = len_1;\n                            (*out).len = len_1;\n                            compare_char =\n                                *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;\n                            best_score = score_1;\n                            (*out).score = score_1;\n                            (*out).distance = backward_0;\n                        }\n                    }\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1107:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        len_1 = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1126\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10mif !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) && !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     len_1 = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if len_1 >= 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let score_1 = BackwardReferenceScore(len_1, backward_0);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score_1 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_len = len_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).len = len_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1118\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             compare_char =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_score = score_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).score = score_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1122\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).distance = backward_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1123\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1124\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":38730,"byte_end":40468,"line_start":1232,"line_end":1264,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(prev_ix >= cur_ix) {","highlight_start":13,"highlight_end":38},{"text":"                if !((backward > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":62},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":81},{"text":"                        || prev_ix.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":77},{"text":"                        || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32","highlight_start":1,"highlight_end":94},{"text":"                            != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)","highlight_start":1,"highlight_end":93},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":60},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len >= 3 || len == 2 && i < 2 {","highlight_start":1,"highlight_end":59},{"text":"                            let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":90},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                if i != 0 {","highlight_start":1,"highlight_end":44},{"text":"                                    score = (score as u64)","highlight_start":1,"highlight_end":59},{"text":"                                        .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":100},{"text":"                                        as u64;","highlight_start":1,"highlight_end":48},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                if best_score < score {","highlight_start":1,"highlight_end":56},{"text":"                                    best_score = score;","highlight_start":1,"highlight_end":56},{"text":"                                    best_len = len;","highlight_start":1,"highlight_end":52},{"text":"                                    (*out).len = best_len;","highlight_start":1,"highlight_end":59},{"text":"                                    (*out).distance = backward;","highlight_start":1,"highlight_end":64},{"text":"                                    (*out).score = best_score;","highlight_start":1,"highlight_end":63},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":38730,"byte_end":40468,"line_start":1232,"line_end":1264,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(prev_ix >= cur_ix) {","highlight_start":13,"highlight_end":38},{"text":"                if !((backward > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":62},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":81},{"text":"                        || prev_ix.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":77},{"text":"                        || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32","highlight_start":1,"highlight_end":94},{"text":"                            != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)","highlight_start":1,"highlight_end":93},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":60},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len >= 3 || len == 2 && i < 2 {","highlight_start":1,"highlight_end":59},{"text":"                            let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":90},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                if i != 0 {","highlight_start":1,"highlight_end":44},{"text":"                                    score = (score as u64)","highlight_start":1,"highlight_end":59},{"text":"                                        .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":100},{"text":"                                        as u64;","highlight_start":1,"highlight_end":48},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                if best_score < score {","highlight_start":1,"highlight_end":56},{"text":"                                    best_score = score;","highlight_start":1,"highlight_end":56},{"text":"                                    best_len = len;","highlight_start":1,"highlight_end":52},{"text":"                                    (*out).len = best_len;","highlight_start":1,"highlight_end":59},{"text":"                                    (*out).distance = backward;","highlight_start":1,"highlight_end":64},{"text":"                                    (*out).score = best_score;","highlight_start":1,"highlight_end":63},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if !(prev_ix >= cur_ix) && !((backward > max_backward) as i64 != 0) {\n                prev_ix &= ring_buffer_mask;\n                if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask\n                    || prev_ix.wrapping_add(best_len) > ring_buffer_mask\n                    || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32\n                        != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)\n                {\n                    let len = FindMatchLengthWithLimit(\n                        &*data.offset(prev_ix as isize),\n                        &*data.offset(cur_ix_masked as isize),\n                        max_length,\n                    );\n                    if len >= 3 || len == 2 && i < 2 {\n                        let mut score = BackwardReferenceScoreUsingLastDistance(len);\n                        if best_score < score {\n                            if i != 0 {\n                                score = (score as u64)\n                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\n                                    as u64;\n                            }\n                            if best_score < score {\n                                best_score = score;\n                                best_len = len;\n                                (*out).len = best_len;\n                                (*out).distance = backward;\n                                (*out).score = best_score;\n                            }\n                        }\n                    }\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1232:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if !(prev_ix >= cur_ix) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !((backward > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif !(prev_ix >= cur_ix) && !((backward > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || prev_ix.wrapping_add(best_len) > ring_buffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1238\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1239\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1241\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if len >= 3 || len == 2 && i < 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let mut score = BackwardReferenceScoreUsingLastDistance(len);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if i != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1248\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 score = (score as u64)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1249\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1250\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1253\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 best_score = score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1254\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 best_len = len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 (*out).len = best_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1256\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 (*out).distance = backward;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1257\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 (*out).score = best_score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1259\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1260\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1261\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":45542,"byte_end":47280,"line_start":1416,"line_end":1448,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(prev_ix >= cur_ix) {","highlight_start":13,"highlight_end":38},{"text":"                if !((backward > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":62},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":81},{"text":"                        || prev_ix.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":77},{"text":"                        || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32","highlight_start":1,"highlight_end":94},{"text":"                            != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)","highlight_start":1,"highlight_end":93},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":60},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len >= 3 || len == 2 && i < 2 {","highlight_start":1,"highlight_end":59},{"text":"                            let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":90},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                if i != 0 {","highlight_start":1,"highlight_end":44},{"text":"                                    score = (score as u64)","highlight_start":1,"highlight_end":59},{"text":"                                        .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":100},{"text":"                                        as u64;","highlight_start":1,"highlight_end":48},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                if best_score < score {","highlight_start":1,"highlight_end":56},{"text":"                                    best_score = score;","highlight_start":1,"highlight_end":56},{"text":"                                    best_len = len;","highlight_start":1,"highlight_end":52},{"text":"                                    (*out).len = best_len;","highlight_start":1,"highlight_end":59},{"text":"                                    (*out).distance = backward;","highlight_start":1,"highlight_end":64},{"text":"                                    (*out).score = best_score;","highlight_start":1,"highlight_end":63},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":45542,"byte_end":47280,"line_start":1416,"line_end":1448,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(prev_ix >= cur_ix) {","highlight_start":13,"highlight_end":38},{"text":"                if !((backward > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":62},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":81},{"text":"                        || prev_ix.wrapping_add(best_len) > ring_buffer_mask","highlight_start":1,"highlight_end":77},{"text":"                        || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32","highlight_start":1,"highlight_end":94},{"text":"                            != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)","highlight_start":1,"highlight_end":93},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":60},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len >= 3 || len == 2 && i < 2 {","highlight_start":1,"highlight_end":59},{"text":"                            let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":90},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                if i != 0 {","highlight_start":1,"highlight_end":44},{"text":"                                    score = (score as u64)","highlight_start":1,"highlight_end":59},{"text":"                                        .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":100},{"text":"                                        as u64;","highlight_start":1,"highlight_end":48},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                if best_score < score {","highlight_start":1,"highlight_end":56},{"text":"                                    best_score = score;","highlight_start":1,"highlight_end":56},{"text":"                                    best_len = len;","highlight_start":1,"highlight_end":52},{"text":"                                    (*out).len = best_len;","highlight_start":1,"highlight_end":59},{"text":"                                    (*out).distance = backward;","highlight_start":1,"highlight_end":64},{"text":"                                    (*out).score = best_score;","highlight_start":1,"highlight_end":63},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if !(prev_ix >= cur_ix) && !((backward > max_backward) as i64 != 0) {\n                prev_ix &= ring_buffer_mask;\n                if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask\n                    || prev_ix.wrapping_add(best_len) > ring_buffer_mask\n                    || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32\n                        != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)\n                {\n                    let len = FindMatchLengthWithLimit(\n                        &*data.offset(prev_ix as isize),\n                        &*data.offset(cur_ix_masked as isize),\n                        max_length,\n                    );\n                    if len >= 3 || len == 2 && i < 2 {\n                        let mut score = BackwardReferenceScoreUsingLastDistance(len);\n                        if best_score < score {\n                            if i != 0 {\n                                score = (score as u64)\n                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\n                                    as u64;\n                            }\n                            if best_score < score {\n                                best_score = score;\n                                best_len = len;\n                                (*out).len = best_len;\n                                (*out).distance = backward;\n                                (*out).score = best_score;\n                            }\n                        }\n                    }\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1416:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1416\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if !(prev_ix >= cur_ix) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !((backward > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1418\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1419\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1447\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1448\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1416\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif !(prev_ix >= cur_ix) && !((backward > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1417\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1418\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if !(cur_ix_masked.wrapping_add(best_len) > ring_buffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1419\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || prev_ix.wrapping_add(best_len) > ring_buffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1420\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || *data.offset(cur_ix_masked.wrapping_add(best_len) as isize) as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1421\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1422\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1423\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1424\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1425\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1426\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1427\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1428\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if len >= 3 || len == 2 && i < 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1429\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let mut score = BackwardReferenceScoreUsingLastDistance(len);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1430\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1431\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if i != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1432\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 score = (score as u64)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1433\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1434\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1435\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1436\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1437\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 best_score = score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 best_len = len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 (*out).len = best_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1440\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 (*out).distance = backward;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1441\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 (*out).score = best_score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1442\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1443\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1444\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1445\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1446\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":50137,"byte_end":50152,"line_start":1528,"line_end":1528,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":50137,"byte_end":50152,"line_start":1528,"line_end":1528,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (32 - 15i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1528:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 32 - 15i32) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 15i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":51660,"byte_end":51692,"line_start":1571,"line_end":1571,"column_start":20,"column_end":52,"is_primary":true,"text":[{"text":"        let idx = (fresh7 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":51660,"byte_end":51692,"line_start":1571,"line_end":1571,"column_start":20,"column_end":52,"is_primary":true,"text":[{"text":"        let idx = (fresh7 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":52}],"label":null,"suggested_replacement":"fresh7 as i32 & ((1i32 << 16) - 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1571:20\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1571\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let idx = (fresh7 as i32 & (1i32 << 16) - 1) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `fresh7 as i32 & ((1i32 << 16) - 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":53891,"byte_end":55201,"line_start":1641,"line_end":1667,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {","highlight_start":13,"highlight_end":101},{"text":"                if !(prev_ix >= cur_ix || backward > max_backward) {","highlight_start":1,"highlight_end":69},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":56},{"text":"                        &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":57},{"text":"                        &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":63},{"text":"                        max_length,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    if len >= 2 {","highlight_start":1,"highlight_end":34},{"text":"                        let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":86},{"text":"                        if best_score < score {","highlight_start":1,"highlight_end":48},{"text":"                            if i != 0 {","highlight_start":1,"highlight_end":40},{"text":"                                score = (score as u64)","highlight_start":1,"highlight_end":55},{"text":"                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":96},{"text":"                                    as u64;","highlight_start":1,"highlight_end":44},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                best_score = score;","highlight_start":1,"highlight_end":52},{"text":"                                best_len = len;","highlight_start":1,"highlight_end":48},{"text":"                                (*out).len = best_len;","highlight_start":1,"highlight_end":55},{"text":"                                (*out).distance = backward;","highlight_start":1,"highlight_end":60},{"text":"                                (*out).score = best_score;","highlight_start":1,"highlight_end":59},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":53891,"byte_end":55201,"line_start":1641,"line_end":1667,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {","highlight_start":13,"highlight_end":101},{"text":"                if !(prev_ix >= cur_ix || backward > max_backward) {","highlight_start":1,"highlight_end":69},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":56},{"text":"                        &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":57},{"text":"                        &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":63},{"text":"                        max_length,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    if len >= 2 {","highlight_start":1,"highlight_end":34},{"text":"                        let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":86},{"text":"                        if best_score < score {","highlight_start":1,"highlight_end":48},{"text":"                            if i != 0 {","highlight_start":1,"highlight_end":40},{"text":"                                score = (score as u64)","highlight_start":1,"highlight_end":55},{"text":"                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":96},{"text":"                                    as u64;","highlight_start":1,"highlight_end":44},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                best_score = score;","highlight_start":1,"highlight_end":52},{"text":"                                best_len = len;","highlight_start":1,"highlight_end":48},{"text":"                                (*out).len = best_len;","highlight_start":1,"highlight_end":55},{"text":"                                (*out).distance = backward;","highlight_start":1,"highlight_end":60},{"text":"                                (*out).score = best_score;","highlight_start":1,"highlight_end":59},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) && !(prev_ix >= cur_ix || backward > max_backward) {\n                prev_ix &= ring_buffer_mask;\n                let len = FindMatchLengthWithLimit(\n                    &*data.offset(prev_ix as isize),\n                    &*data.offset(cur_ix_masked as isize),\n                    max_length,\n                );\n                if len >= 2 {\n                    let mut score = BackwardReferenceScoreUsingLastDistance(len);\n                    if best_score < score {\n                        if i != 0 {\n                            score = (score as u64)\n                                .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\n                                as u64;\n                        }\n                        if best_score < score {\n                            best_score = score;\n                            best_len = len;\n                            (*out).len = best_len;\n                            (*out).distance = backward;\n                            (*out).score = best_score;\n                        }\n                    }\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1641:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1641\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1642\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !(prev_ix >= cur_ix || backward > max_backward) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1643\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1644\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1666\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1667\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1641\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) && !(prev_ix >= cur_ix || backward > max_backward) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1642\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1643\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1644\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1645\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1646\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1647\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1648\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if len >= 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1649\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let mut score = BackwardReferenceScoreUsingLastDistance(len);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1650\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1651\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if i != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1652\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             score = (score as u64)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1653\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1654\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1655\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1656\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1657\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_score = score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1658\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_len = len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1659\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).len = best_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1660\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).distance = backward;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1661\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).score = best_score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1662\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1663\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1664\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1665\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":57908,"byte_end":57923,"line_start":1743,"line_end":1743,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":57908,"byte_end":57923,"line_start":1743,"line_end":1743,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (32 - 15i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1743:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1743\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 32 - 15i32) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 15i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":59432,"byte_end":59465,"line_start":1786,"line_end":1786,"column_start":20,"column_end":53,"is_primary":true,"text":[{"text":"        let idx = (fresh10 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":59432,"byte_end":59465,"line_start":1786,"line_end":1786,"column_start":20,"column_end":53,"is_primary":true,"text":[{"text":"        let idx = (fresh10 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":53}],"label":null,"suggested_replacement":"fresh10 as i32 & ((1i32 << 16) - 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1786:20\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1786\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let idx = (fresh10 as i32 & (1i32 << 16) - 1) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `fresh10 as i32 & ((1i32 << 16) - 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":61666,"byte_end":62976,"line_start":1856,"line_end":1882,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {","highlight_start":13,"highlight_end":101},{"text":"                if !(prev_ix >= cur_ix || backward > max_backward) {","highlight_start":1,"highlight_end":69},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":56},{"text":"                        &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":57},{"text":"                        &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":63},{"text":"                        max_length,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    if len >= 2 {","highlight_start":1,"highlight_end":34},{"text":"                        let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":86},{"text":"                        if best_score < score {","highlight_start":1,"highlight_end":48},{"text":"                            if i != 0 {","highlight_start":1,"highlight_end":40},{"text":"                                score = (score as u64)","highlight_start":1,"highlight_end":55},{"text":"                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":96},{"text":"                                    as u64;","highlight_start":1,"highlight_end":44},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                best_score = score;","highlight_start":1,"highlight_end":52},{"text":"                                best_len = len;","highlight_start":1,"highlight_end":48},{"text":"                                (*out).len = best_len;","highlight_start":1,"highlight_end":55},{"text":"                                (*out).distance = backward;","highlight_start":1,"highlight_end":60},{"text":"                                (*out).score = best_score;","highlight_start":1,"highlight_end":59},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":61666,"byte_end":62976,"line_start":1856,"line_end":1882,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {","highlight_start":13,"highlight_end":101},{"text":"                if !(prev_ix >= cur_ix || backward > max_backward) {","highlight_start":1,"highlight_end":69},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":56},{"text":"                        &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":57},{"text":"                        &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":63},{"text":"                        max_length,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    if len >= 2 {","highlight_start":1,"highlight_end":34},{"text":"                        let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":86},{"text":"                        if best_score < score {","highlight_start":1,"highlight_end":48},{"text":"                            if i != 0 {","highlight_start":1,"highlight_end":40},{"text":"                                score = (score as u64)","highlight_start":1,"highlight_end":55},{"text":"                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":96},{"text":"                                    as u64;","highlight_start":1,"highlight_end":44},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                best_score = score;","highlight_start":1,"highlight_end":52},{"text":"                                best_len = len;","highlight_start":1,"highlight_end":48},{"text":"                                (*out).len = best_len;","highlight_start":1,"highlight_end":55},{"text":"                                (*out).distance = backward;","highlight_start":1,"highlight_end":60},{"text":"                                (*out).score = best_score;","highlight_start":1,"highlight_end":59},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) && !(prev_ix >= cur_ix || backward > max_backward) {\n                prev_ix &= ring_buffer_mask;\n                let len = FindMatchLengthWithLimit(\n                    &*data.offset(prev_ix as isize),\n                    &*data.offset(cur_ix_masked as isize),\n                    max_length,\n                );\n                if len >= 2 {\n                    let mut score = BackwardReferenceScoreUsingLastDistance(len);\n                    if best_score < score {\n                        if i != 0 {\n                            score = (score as u64)\n                                .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\n                                as u64;\n                        }\n                        if best_score < score {\n                            best_score = score;\n                            best_len = len;\n                            (*out).len = best_len;\n                            (*out).distance = backward;\n                            (*out).score = best_score;\n                        }\n                    }\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1856:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1856\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1857\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !(prev_ix >= cur_ix || backward > max_backward) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1858\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1859\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1881\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1882\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1856\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) && !(prev_ix >= cur_ix || backward > max_backward) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1857\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1858\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1859\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1860\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1861\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1862\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1863\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if len >= 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1864\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let mut score = BackwardReferenceScoreUsingLastDistance(len);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1865\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1866\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if i != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1867\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             score = (score as u64)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1868\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1869\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1870\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1871\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1872\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_score = score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1873\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_len = len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1874\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).len = best_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1875\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).distance = backward;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1876\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).score = best_score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1877\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1878\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1879\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1880\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":65685,"byte_end":65700,"line_start":1958,"line_end":1958,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":65685,"byte_end":65700,"line_start":1958,"line_end":1958,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (32 - 15i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:1958:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1958\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 32 - 15i32) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 15i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":67215,"byte_end":67247,"line_start":2001,"line_end":2001,"column_start":20,"column_end":52,"is_primary":true,"text":[{"text":"        let idx = (fresh13 as i32 & (1i32 << 9) - 1) as u64;","highlight_start":20,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":67215,"byte_end":67247,"line_start":2001,"line_end":2001,"column_start":20,"column_end":52,"is_primary":true,"text":[{"text":"        let idx = (fresh13 as i32 & (1i32 << 9) - 1) as u64;","highlight_start":20,"highlight_end":52}],"label":null,"suggested_replacement":"fresh13 as i32 & ((1i32 << 9) - 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2001:20\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2001\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let idx = (fresh13 as i32 & (1i32 << 9) - 1) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `fresh13 as i32 & ((1i32 << 9) - 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":69448,"byte_end":70758,"line_start":2071,"line_end":2097,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {","highlight_start":13,"highlight_end":101},{"text":"                if !(prev_ix >= cur_ix || backward > max_backward) {","highlight_start":1,"highlight_end":69},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":56},{"text":"                        &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":57},{"text":"                        &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":63},{"text":"                        max_length,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    if len >= 2 {","highlight_start":1,"highlight_end":34},{"text":"                        let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":86},{"text":"                        if best_score < score {","highlight_start":1,"highlight_end":48},{"text":"                            if i != 0 {","highlight_start":1,"highlight_end":40},{"text":"                                score = (score as u64)","highlight_start":1,"highlight_end":55},{"text":"                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":96},{"text":"                                    as u64;","highlight_start":1,"highlight_end":44},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                best_score = score;","highlight_start":1,"highlight_end":52},{"text":"                                best_len = len;","highlight_start":1,"highlight_end":48},{"text":"                                (*out).len = best_len;","highlight_start":1,"highlight_end":55},{"text":"                                (*out).distance = backward;","highlight_start":1,"highlight_end":60},{"text":"                                (*out).score = best_score;","highlight_start":1,"highlight_end":59},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":69448,"byte_end":70758,"line_start":2071,"line_end":2097,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {","highlight_start":13,"highlight_end":101},{"text":"                if !(prev_ix >= cur_ix || backward > max_backward) {","highlight_start":1,"highlight_end":69},{"text":"                    prev_ix &= ring_buffer_mask;","highlight_start":1,"highlight_end":49},{"text":"                    let len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":56},{"text":"                        &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":57},{"text":"                        &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":63},{"text":"                        max_length,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    if len >= 2 {","highlight_start":1,"highlight_end":34},{"text":"                        let mut score = BackwardReferenceScoreUsingLastDistance(len);","highlight_start":1,"highlight_end":86},{"text":"                        if best_score < score {","highlight_start":1,"highlight_end":48},{"text":"                            if i != 0 {","highlight_start":1,"highlight_end":40},{"text":"                                score = (score as u64)","highlight_start":1,"highlight_end":55},{"text":"                                    .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))","highlight_start":1,"highlight_end":96},{"text":"                                    as u64;","highlight_start":1,"highlight_end":44},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if best_score < score {","highlight_start":1,"highlight_end":52},{"text":"                                best_score = score;","highlight_start":1,"highlight_end":52},{"text":"                                best_len = len;","highlight_start":1,"highlight_end":48},{"text":"                                (*out).len = best_len;","highlight_start":1,"highlight_end":55},{"text":"                                (*out).distance = backward;","highlight_start":1,"highlight_end":60},{"text":"                                (*out).score = best_score;","highlight_start":1,"highlight_end":59},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) && !(prev_ix >= cur_ix || backward > max_backward) {\n                prev_ix &= ring_buffer_mask;\n                let len = FindMatchLengthWithLimit(\n                    &*data.offset(prev_ix as isize),\n                    &*data.offset(cur_ix_masked as isize),\n                    max_length,\n                );\n                if len >= 2 {\n                    let mut score = BackwardReferenceScoreUsingLastDistance(len);\n                    if best_score < score {\n                        if i != 0 {\n                            score = (score as u64)\n                                .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\n                                as u64;\n                        }\n                        if best_score < score {\n                            best_score = score;\n                            best_len = len;\n                            (*out).len = best_len;\n                            (*out).distance = backward;\n                            (*out).score = best_score;\n                        }\n                    }\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2071:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2071\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2072\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !(prev_ix >= cur_ix || backward > max_backward) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2073\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2074\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2096\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2097\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2071\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif !(i > 0 && *tiny_hashes.offset(prev_ix as u16 as isize) as i32 != tiny_hash as i32) && !(prev_ix >= cur_ix || backward > max_backward) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2072\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 prev_ix &= ring_buffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2073\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2074\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2075\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2076\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2077\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2078\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if len >= 2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2079\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let mut score = BackwardReferenceScoreUsingLastDistance(len);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2080\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2081\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if i != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2082\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             score = (score as u64)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2083\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 .wrapping_sub(BackwardReferencePenaltyUsingLastDistance(i))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2084\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2085\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2086\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2087\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_score = score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2088\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_len = len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2089\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).len = best_len;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2090\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).distance = backward;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2091\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).score = best_score;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2092\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2093\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2094\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2095\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":73357,"byte_end":73424,"line_start":2171,"line_end":2171,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 7i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":73357,"byte_end":73424,"line_start":2171,"line_end":2171,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 7i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 7i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2171:18\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 7i32)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 7i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":73481,"byte_end":73496,"line_start":2173,"line_end":2173,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 20i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":73481,"byte_end":73496,"line_start":2173,"line_end":2173,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 20i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 20i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2173:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2173\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 20i32) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 20i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":77499,"byte_end":78620,"line_start":2284,"line_end":2304,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {","highlight_start":17,"highlight_end":101},{"text":"                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":87},{"text":"                        len_1 = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":58},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len_1 >= 4 {","highlight_start":1,"highlight_end":40},{"text":"                            let score_1 = BackwardReferenceScore(len_1, backward_0);","highlight_start":1,"highlight_end":85},{"text":"                            if best_score < score_1 {","highlight_start":1,"highlight_end":54},{"text":"                                best_len = len_1;","highlight_start":1,"highlight_end":50},{"text":"                                (*out).len = len_1;","highlight_start":1,"highlight_end":52},{"text":"                                compare_char =","highlight_start":1,"highlight_end":47},{"text":"                                    *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;","highlight_start":1,"highlight_end":101},{"text":"                                best_score = score_1;","highlight_start":1,"highlight_end":54},{"text":"                                (*out).score = score_1;","highlight_start":1,"highlight_end":56},{"text":"                                (*out).distance = backward_0;","highlight_start":1,"highlight_end":62},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":77499,"byte_end":78620,"line_start":2284,"line_end":2304,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {","highlight_start":17,"highlight_end":101},{"text":"                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {","highlight_start":1,"highlight_end":87},{"text":"                        len_1 = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":58},{"text":"                            &*data.offset(prev_ix as isize),","highlight_start":1,"highlight_end":61},{"text":"                            &*data.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":67},{"text":"                            max_length,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        if len_1 >= 4 {","highlight_start":1,"highlight_end":40},{"text":"                            let score_1 = BackwardReferenceScore(len_1, backward_0);","highlight_start":1,"highlight_end":85},{"text":"                            if best_score < score_1 {","highlight_start":1,"highlight_end":54},{"text":"                                best_len = len_1;","highlight_start":1,"highlight_end":50},{"text":"                                (*out).len = len_1;","highlight_start":1,"highlight_end":52},{"text":"                                compare_char =","highlight_start":1,"highlight_end":47},{"text":"                                    *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;","highlight_start":1,"highlight_end":101},{"text":"                                best_score = score_1;","highlight_start":1,"highlight_end":54},{"text":"                                (*out).score = score_1;","highlight_start":1,"highlight_end":56},{"text":"                                (*out).distance = backward_0;","highlight_start":1,"highlight_end":62},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) && !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\n                    len_1 = FindMatchLengthWithLimit(\n                        &*data.offset(prev_ix as isize),\n                        &*data.offset(cur_ix_masked as isize),\n                        max_length,\n                    );\n                    if len_1 >= 4 {\n                        let score_1 = BackwardReferenceScore(len_1, backward_0);\n                        if best_score < score_1 {\n                            best_len = len_1;\n                            (*out).len = len_1;\n                            compare_char =\n                                *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;\n                            best_score = score_1;\n                            (*out).score = score_1;\n                            (*out).distance = backward_0;\n                        }\n                    }\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2284:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2286\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        len_1 = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2303\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10mif !(compare_char != *data.offset(prev_ix.wrapping_add(best_len) as isize) as i32) && !((backward_0 == 0 || backward_0 > max_backward) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     len_1 = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2286\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2288\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         max_length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2289\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2290\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if len_1 >= 4 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2291\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let score_1 = BackwardReferenceScore(len_1, backward_0);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2292\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if best_score < score_1 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_len = len_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).len = len_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2295\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             compare_char =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 *data.offset(cur_ix_masked.wrapping_add(len_1) as isize) as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             best_score = score_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).score = score_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*out).distance = backward_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2301\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93496,"byte_end":94386,"line_start":2825,"line_end":2845,"column_start":20,"column_end":14,"is_primary":true,"text":[{"text":"            } else {","highlight_start":20,"highlight_end":21},{"text":"                if distance == *dist_cache.offset(1 as isize) as u64 {","highlight_start":1,"highlight_end":71},{"text":"                    return 1;","highlight_start":1,"highlight_end":30},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if offset0 < 7 {","highlight_start":1,"highlight_end":37},{"text":"                        return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;","highlight_start":1,"highlight_end":90},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if offset1 < 7 {","highlight_start":1,"highlight_end":41},{"text":"                            return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;","highlight_start":1,"highlight_end":94},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93496,"byte_end":94386,"line_start":2825,"line_end":2845,"column_start":20,"column_end":14,"is_primary":true,"text":[{"text":"            } else {","highlight_start":20,"highlight_end":21},{"text":"                if distance == *dist_cache.offset(1 as isize) as u64 {","highlight_start":1,"highlight_end":71},{"text":"                    return 1;","highlight_start":1,"highlight_end":30},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    if offset0 < 7 {","highlight_start":1,"highlight_end":37},{"text":"                        return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;","highlight_start":1,"highlight_end":90},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if offset1 < 7 {","highlight_start":1,"highlight_end":41},{"text":"                            return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;","highlight_start":1,"highlight_end":94},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if distance == *dist_cache.offset(1 as isize) as u64 {\n                return 1;\n            } else {\n                if offset0 < 7 {\n                    return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;\n                } else {\n                    if offset1 < 7 {\n                        return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;\n                    } else {\n                        if distance == *dist_cache.offset(2 as isize) as u64 {\n                            return 2;\n                        } else {\n                            if distance == *dist_cache.offset(3 as isize) as u64 {\n                                return 3;\n                            }\n                        }\n                    }\n                }\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2825:20\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2825\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2826\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if distance == *dist_cache.offset(1 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2827\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2828\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2844\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2845\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2825\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            } else \u001b[0m\u001b[0m\u001b[38;5;10mif distance == *dist_cache.offset(1 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2826\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2827\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2828\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if offset0 < 7 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2829\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2830\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if offset1 < 7 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2832\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2833\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2834\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if distance == *dist_cache.offset(2 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2836\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2837\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if distance == *dist_cache.offset(3 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2839\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2840\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2842\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2843\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93622,"byte_end":94372,"line_start":2828,"line_end":2844,"column_start":24,"column_end":18,"is_primary":true,"text":[{"text":"                } else {","highlight_start":24,"highlight_end":25},{"text":"                    if offset0 < 7 {","highlight_start":1,"highlight_end":37},{"text":"                        return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;","highlight_start":1,"highlight_end":90},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if offset1 < 7 {","highlight_start":1,"highlight_end":41},{"text":"                            return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;","highlight_start":1,"highlight_end":94},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93622,"byte_end":94372,"line_start":2828,"line_end":2844,"column_start":24,"column_end":18,"is_primary":true,"text":[{"text":"                } else {","highlight_start":24,"highlight_end":25},{"text":"                    if offset0 < 7 {","highlight_start":1,"highlight_end":37},{"text":"                        return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;","highlight_start":1,"highlight_end":90},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        if offset1 < 7 {","highlight_start":1,"highlight_end":41},{"text":"                            return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;","highlight_start":1,"highlight_end":94},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if offset0 < 7 {\n                    return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;\n                } else {\n                    if offset1 < 7 {\n                        return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;\n                    } else {\n                        if distance == *dist_cache.offset(2 as isize) as u64 {\n                            return 2;\n                        } else {\n                            if distance == *dist_cache.offset(3 as isize) as u64 {\n                                return 3;\n                            }\n                        }\n                    }\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2828:24\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2828\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2829\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if offset0 < 7 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2830\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2843\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2844\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2828\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                } else \u001b[0m\u001b[0m\u001b[38;5;10mif offset0 < 7 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2829\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     return (0x9750468 >> 4u64.wrapping_mul(offset0) & 0xfi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2830\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if offset1 < 7 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2832\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2833\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2834\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if distance == *dist_cache.offset(2 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2836\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2837\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if distance == *dist_cache.offset(3 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2839\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2840\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2842\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93778,"byte_end":94354,"line_start":2831,"line_end":2843,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else {","highlight_start":28,"highlight_end":29},{"text":"                        if offset1 < 7 {","highlight_start":1,"highlight_end":41},{"text":"                            return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;","highlight_start":1,"highlight_end":94},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93778,"byte_end":94354,"line_start":2831,"line_end":2843,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else {","highlight_start":28,"highlight_end":29},{"text":"                        if offset1 < 7 {","highlight_start":1,"highlight_end":41},{"text":"                            return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;","highlight_start":1,"highlight_end":94},{"text":"                        } else {","highlight_start":1,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if offset1 < 7 {\n                        return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;\n                    } else {\n                        if distance == *dist_cache.offset(2 as isize) as u64 {\n                            return 2;\n                        } else {\n                            if distance == *dist_cache.offset(3 as isize) as u64 {\n                                return 3;\n                            }\n                        }\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2831:28\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2832\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if offset1 < 7 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2833\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2834\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2842\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2843\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2831\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    } else \u001b[0m\u001b[0m\u001b[38;5;10mif offset1 < 7 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2832\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         return (0xfdb1ace >> 4u64.wrapping_mul(offset1) & 0xfi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2833\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2834\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if distance == *dist_cache.offset(2 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2836\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2837\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if distance == *dist_cache.offset(3 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2839\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2840\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93946,"byte_end":94332,"line_start":2834,"line_end":2842,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":93946,"byte_end":94332,"line_start":2834,"line_end":2842,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if distance == *dist_cache.offset(2 as isize) as u64 {","highlight_start":1,"highlight_end":83},{"text":"                                return 2;","highlight_start":1,"highlight_end":42},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if distance == *dist_cache.offset(2 as isize) as u64 {\n                            return 2;\n                        } else {\n                            if distance == *dist_cache.offset(3 as isize) as u64 {\n                                return 3;\n                            }\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2834:32\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2834\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if distance == *dist_cache.offset(2 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2836\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                return 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2837\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2842\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2834\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif distance == *dist_cache.offset(2 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return 2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2836\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2837\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if distance == *dist_cache.offset(3 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2839\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2840\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":94108,"byte_end":94306,"line_start":2837,"line_end":2841,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else {","highlight_start":36,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references.rs","byte_start":94108,"byte_end":94306,"line_start":2837,"line_end":2841,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else {","highlight_start":36,"highlight_end":37},{"text":"                                if distance == *dist_cache.offset(3 as isize) as u64 {","highlight_start":1,"highlight_end":87},{"text":"                                    return 3;","highlight_start":1,"highlight_end":46},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"if distance == *dist_cache.offset(3 as isize) as u64 {\n                                return 3;\n                            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references.rs:2837:36\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2837\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m______________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       if distance == *dist_cache.offset(3 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2839\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2840\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_______________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2837\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                            } else \u001b[0m\u001b[0m\u001b[38;5;10mif distance == *dist_cache.offset(3 as isize) as u64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2839\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":17526,"byte_end":17538,"line_start":653,"line_end":653,"column_start":16,"column_end":28,"is_primary":true,"text":[{"text":"        return h >> 32 - 17;","highlight_start":16,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":17526,"byte_end":17538,"line_start":653,"line_end":653,"column_start":16,"column_end":28,"is_primary":true,"text":[{"text":"        return h >> 32 - 17;","highlight_start":16,"highlight_end":28}],"label":null,"suggested_replacement":"h >> (32 - 17)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:653:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m653\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return h >> 32 - 17;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 17)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":47097,"byte_end":49815,"line_start":1495,"line_end":1542,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !((backward > dictionary_start.wrapping_add(gap)) as i64 != 0) {","highlight_start":17,"highlight_end":84},{"text":"                    if backward <= max_distance {","highlight_start":1,"highlight_end":50},{"text":"                        if !(prev_ix >= cur_ix) {","highlight_start":1,"highlight_end":50},{"text":"                            prev_ix &= ringbuffer_mask;","highlight_start":1,"highlight_end":56},{"text":"                            if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask","highlight_start":1,"highlight_end":82},{"text":"                                || continuation as i32","highlight_start":1,"highlight_end":55},{"text":"                                    != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)","highlight_start":1,"highlight_end":99},{"text":"                                        as i32)","highlight_start":1,"highlight_end":48},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":64},{"text":"                                    &*ringbuffer.offset(prev_ix as isize),","highlight_start":1,"highlight_end":75},{"text":"                                    &*ringbuffer.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":81},{"text":"                                    max_len,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                                let dist_cost =","highlight_start":1,"highlight_end":48},{"text":"                                    base_cost + ZopfliCostModelGetDistanceCost(model, j);","highlight_start":1,"highlight_end":90},{"text":"                                let mut l: u64 = 0;","highlight_start":1,"highlight_end":52},{"text":"                                l = best_len.wrapping_add(1);","highlight_start":1,"highlight_end":62},{"text":"                                while l <= len {","highlight_start":1,"highlight_end":49},{"text":"                                    let copycode = GetCopyLengthCode(l);","highlight_start":1,"highlight_end":73},{"text":"                                    let cmdcode =","highlight_start":1,"highlight_end":50},{"text":"                                        CombineLengthCodes(inscode, copycode, (j == 0) as i32);","highlight_start":1,"highlight_end":96},{"text":"                                    let cost = (if (cmdcode as i32) < 128 {","highlight_start":1,"highlight_end":76},{"text":"                                        base_cost","highlight_start":1,"highlight_end":50},{"text":"                                    } else {","highlight_start":1,"highlight_end":45},{"text":"                                        dist_cost","highlight_start":1,"highlight_end":50},{"text":"                                    }) + GetCopyExtra(copycode) as libc::c_float","highlight_start":1,"highlight_end":81},{"text":"                                        + ZopfliCostModelGetCommandCost(model, cmdcode);","highlight_start":1,"highlight_end":89},{"text":"                                    if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {","highlight_start":1,"highlight_end":101},{"text":"                                        UpdateZopfliNode(","highlight_start":1,"highlight_end":58},{"text":"                                            nodes,","highlight_start":1,"highlight_end":51},{"text":"                                            pos,","highlight_start":1,"highlight_end":49},{"text":"                                            start,","highlight_start":1,"highlight_end":51},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            backward,","highlight_start":1,"highlight_end":54},{"text":"                                            j.wrapping_add(1),","highlight_start":1,"highlight_end":63},{"text":"                                            cost,","highlight_start":1,"highlight_end":50},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        result = brotli_max_size_t(result, l);","highlight_start":1,"highlight_end":79},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    best_len = l;","highlight_start":1,"highlight_end":50},{"text":"                                    l = l.wrapping_add(1);","highlight_start":1,"highlight_end":59},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":47097,"byte_end":49815,"line_start":1495,"line_end":1542,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if !((backward > dictionary_start.wrapping_add(gap)) as i64 != 0) {","highlight_start":17,"highlight_end":84},{"text":"                    if backward <= max_distance {","highlight_start":1,"highlight_end":50},{"text":"                        if !(prev_ix >= cur_ix) {","highlight_start":1,"highlight_end":50},{"text":"                            prev_ix &= ringbuffer_mask;","highlight_start":1,"highlight_end":56},{"text":"                            if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask","highlight_start":1,"highlight_end":82},{"text":"                                || continuation as i32","highlight_start":1,"highlight_end":55},{"text":"                                    != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)","highlight_start":1,"highlight_end":99},{"text":"                                        as i32)","highlight_start":1,"highlight_end":48},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":64},{"text":"                                    &*ringbuffer.offset(prev_ix as isize),","highlight_start":1,"highlight_end":75},{"text":"                                    &*ringbuffer.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":81},{"text":"                                    max_len,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                                let dist_cost =","highlight_start":1,"highlight_end":48},{"text":"                                    base_cost + ZopfliCostModelGetDistanceCost(model, j);","highlight_start":1,"highlight_end":90},{"text":"                                let mut l: u64 = 0;","highlight_start":1,"highlight_end":52},{"text":"                                l = best_len.wrapping_add(1);","highlight_start":1,"highlight_end":62},{"text":"                                while l <= len {","highlight_start":1,"highlight_end":49},{"text":"                                    let copycode = GetCopyLengthCode(l);","highlight_start":1,"highlight_end":73},{"text":"                                    let cmdcode =","highlight_start":1,"highlight_end":50},{"text":"                                        CombineLengthCodes(inscode, copycode, (j == 0) as i32);","highlight_start":1,"highlight_end":96},{"text":"                                    let cost = (if (cmdcode as i32) < 128 {","highlight_start":1,"highlight_end":76},{"text":"                                        base_cost","highlight_start":1,"highlight_end":50},{"text":"                                    } else {","highlight_start":1,"highlight_end":45},{"text":"                                        dist_cost","highlight_start":1,"highlight_end":50},{"text":"                                    }) + GetCopyExtra(copycode) as libc::c_float","highlight_start":1,"highlight_end":81},{"text":"                                        + ZopfliCostModelGetCommandCost(model, cmdcode);","highlight_start":1,"highlight_end":89},{"text":"                                    if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {","highlight_start":1,"highlight_end":101},{"text":"                                        UpdateZopfliNode(","highlight_start":1,"highlight_end":58},{"text":"                                            nodes,","highlight_start":1,"highlight_end":51},{"text":"                                            pos,","highlight_start":1,"highlight_end":49},{"text":"                                            start,","highlight_start":1,"highlight_end":51},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            backward,","highlight_start":1,"highlight_end":54},{"text":"                                            j.wrapping_add(1),","highlight_start":1,"highlight_end":63},{"text":"                                            cost,","highlight_start":1,"highlight_end":50},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        result = brotli_max_size_t(result, l);","highlight_start":1,"highlight_end":79},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    best_len = l;","highlight_start":1,"highlight_end":50},{"text":"                                    l = l.wrapping_add(1);","highlight_start":1,"highlight_end":59},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if !((backward > dictionary_start.wrapping_add(gap)) as i64 != 0) && backward <= max_distance {\n                    if !(prev_ix >= cur_ix) {\n                        prev_ix &= ringbuffer_mask;\n                        if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask\n                            || continuation as i32\n                                != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)\n                                    as i32)\n                        {\n                            len = FindMatchLengthWithLimit(\n                                &*ringbuffer.offset(prev_ix as isize),\n                                &*ringbuffer.offset(cur_ix_masked as isize),\n                                max_len,\n                            );\n                            let dist_cost =\n                                base_cost + ZopfliCostModelGetDistanceCost(model, j);\n                            let mut l: u64 = 0;\n                            l = best_len.wrapping_add(1);\n                            while l <= len {\n                                let copycode = GetCopyLengthCode(l);\n                                let cmdcode =\n                                    CombineLengthCodes(inscode, copycode, (j == 0) as i32);\n                                let cost = (if (cmdcode as i32) < 128 {\n                                    base_cost\n                                } else {\n                                    dist_cost\n                                }) + GetCopyExtra(copycode) as libc::c_float\n                                    + ZopfliCostModelGetCommandCost(model, cmdcode);\n                                if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {\n                                    UpdateZopfliNode(\n                                        nodes,\n                                        pos,\n                                        start,\n                                        l,\n                                        l,\n                                        backward,\n                                        j.wrapping_add(1),\n                                        cost,\n                                    );\n                                    result = brotli_max_size_t(result, l);\n                                }\n                                best_len = l;\n                                l = l.wrapping_add(1);\n                            }\n                        }\n                    }\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:1495:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if !((backward > dictionary_start.wrapping_add(gap)) as i64 != 0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if backward <= max_distance {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if !(prev_ix >= cur_ix) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            prev_ix &= ringbuffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1541\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1542\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1495\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10mif !((backward > dictionary_start.wrapping_add(gap)) as i64 != 0) && backward <= max_distance {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if !(prev_ix >= cur_ix) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         prev_ix &= ringbuffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             || continuation as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1503\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1504\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 &*ringbuffer.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1505\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 &*ringbuffer.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1506\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 max_len,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1507\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1508\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let dist_cost =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 base_cost + ZopfliCostModelGetDistanceCost(model, j);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let mut l: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1511\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l = best_len.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             while l <= len {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let copycode = GetCopyLengthCode(l);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let cmdcode =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     CombineLengthCodes(inscode, copycode, (j == 0) as i32);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let cost = (if (cmdcode as i32) < 128 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     base_cost\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     dist_cost\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1520\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }) + GetCopyExtra(copycode) as libc::c_float\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     + ZopfliCostModelGetCommandCost(model, cmdcode);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1522\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1523\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     UpdateZopfliNode(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1524\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         nodes,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1525\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         pos,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1526\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         start,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1529\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         backward,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1530\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         j.wrapping_add(1),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1531\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         cost,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1532\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1533\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     result = brotli_max_size_t(result, l);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1534\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1535\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 best_len = l;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1536\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l = l.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1537\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1538\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1539\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1540\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":47185,"byte_end":49797,"line_start":1496,"line_end":1541,"column_start":21,"column_end":22,"is_primary":true,"text":[{"text":"                    if backward <= max_distance {","highlight_start":21,"highlight_end":50},{"text":"                        if !(prev_ix >= cur_ix) {","highlight_start":1,"highlight_end":50},{"text":"                            prev_ix &= ringbuffer_mask;","highlight_start":1,"highlight_end":56},{"text":"                            if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask","highlight_start":1,"highlight_end":82},{"text":"                                || continuation as i32","highlight_start":1,"highlight_end":55},{"text":"                                    != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)","highlight_start":1,"highlight_end":99},{"text":"                                        as i32)","highlight_start":1,"highlight_end":48},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":64},{"text":"                                    &*ringbuffer.offset(prev_ix as isize),","highlight_start":1,"highlight_end":75},{"text":"                                    &*ringbuffer.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":81},{"text":"                                    max_len,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                                let dist_cost =","highlight_start":1,"highlight_end":48},{"text":"                                    base_cost + ZopfliCostModelGetDistanceCost(model, j);","highlight_start":1,"highlight_end":90},{"text":"                                let mut l: u64 = 0;","highlight_start":1,"highlight_end":52},{"text":"                                l = best_len.wrapping_add(1);","highlight_start":1,"highlight_end":62},{"text":"                                while l <= len {","highlight_start":1,"highlight_end":49},{"text":"                                    let copycode = GetCopyLengthCode(l);","highlight_start":1,"highlight_end":73},{"text":"                                    let cmdcode =","highlight_start":1,"highlight_end":50},{"text":"                                        CombineLengthCodes(inscode, copycode, (j == 0) as i32);","highlight_start":1,"highlight_end":96},{"text":"                                    let cost = (if (cmdcode as i32) < 128 {","highlight_start":1,"highlight_end":76},{"text":"                                        base_cost","highlight_start":1,"highlight_end":50},{"text":"                                    } else {","highlight_start":1,"highlight_end":45},{"text":"                                        dist_cost","highlight_start":1,"highlight_end":50},{"text":"                                    }) + GetCopyExtra(copycode) as libc::c_float","highlight_start":1,"highlight_end":81},{"text":"                                        + ZopfliCostModelGetCommandCost(model, cmdcode);","highlight_start":1,"highlight_end":89},{"text":"                                    if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {","highlight_start":1,"highlight_end":101},{"text":"                                        UpdateZopfliNode(","highlight_start":1,"highlight_end":58},{"text":"                                            nodes,","highlight_start":1,"highlight_end":51},{"text":"                                            pos,","highlight_start":1,"highlight_end":49},{"text":"                                            start,","highlight_start":1,"highlight_end":51},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            backward,","highlight_start":1,"highlight_end":54},{"text":"                                            j.wrapping_add(1),","highlight_start":1,"highlight_end":63},{"text":"                                            cost,","highlight_start":1,"highlight_end":50},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        result = brotli_max_size_t(result, l);","highlight_start":1,"highlight_end":79},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    best_len = l;","highlight_start":1,"highlight_end":50},{"text":"                                    l = l.wrapping_add(1);","highlight_start":1,"highlight_end":59},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":47185,"byte_end":49797,"line_start":1496,"line_end":1541,"column_start":21,"column_end":22,"is_primary":true,"text":[{"text":"                    if backward <= max_distance {","highlight_start":21,"highlight_end":50},{"text":"                        if !(prev_ix >= cur_ix) {","highlight_start":1,"highlight_end":50},{"text":"                            prev_ix &= ringbuffer_mask;","highlight_start":1,"highlight_end":56},{"text":"                            if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask","highlight_start":1,"highlight_end":82},{"text":"                                || continuation as i32","highlight_start":1,"highlight_end":55},{"text":"                                    != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)","highlight_start":1,"highlight_end":99},{"text":"                                        as i32)","highlight_start":1,"highlight_end":48},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                len = FindMatchLengthWithLimit(","highlight_start":1,"highlight_end":64},{"text":"                                    &*ringbuffer.offset(prev_ix as isize),","highlight_start":1,"highlight_end":75},{"text":"                                    &*ringbuffer.offset(cur_ix_masked as isize),","highlight_start":1,"highlight_end":81},{"text":"                                    max_len,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                                let dist_cost =","highlight_start":1,"highlight_end":48},{"text":"                                    base_cost + ZopfliCostModelGetDistanceCost(model, j);","highlight_start":1,"highlight_end":90},{"text":"                                let mut l: u64 = 0;","highlight_start":1,"highlight_end":52},{"text":"                                l = best_len.wrapping_add(1);","highlight_start":1,"highlight_end":62},{"text":"                                while l <= len {","highlight_start":1,"highlight_end":49},{"text":"                                    let copycode = GetCopyLengthCode(l);","highlight_start":1,"highlight_end":73},{"text":"                                    let cmdcode =","highlight_start":1,"highlight_end":50},{"text":"                                        CombineLengthCodes(inscode, copycode, (j == 0) as i32);","highlight_start":1,"highlight_end":96},{"text":"                                    let cost = (if (cmdcode as i32) < 128 {","highlight_start":1,"highlight_end":76},{"text":"                                        base_cost","highlight_start":1,"highlight_end":50},{"text":"                                    } else {","highlight_start":1,"highlight_end":45},{"text":"                                        dist_cost","highlight_start":1,"highlight_end":50},{"text":"                                    }) + GetCopyExtra(copycode) as libc::c_float","highlight_start":1,"highlight_end":81},{"text":"                                        + ZopfliCostModelGetCommandCost(model, cmdcode);","highlight_start":1,"highlight_end":89},{"text":"                                    if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {","highlight_start":1,"highlight_end":101},{"text":"                                        UpdateZopfliNode(","highlight_start":1,"highlight_end":58},{"text":"                                            nodes,","highlight_start":1,"highlight_end":51},{"text":"                                            pos,","highlight_start":1,"highlight_end":49},{"text":"                                            start,","highlight_start":1,"highlight_end":51},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            l,","highlight_start":1,"highlight_end":47},{"text":"                                            backward,","highlight_start":1,"highlight_end":54},{"text":"                                            j.wrapping_add(1),","highlight_start":1,"highlight_end":63},{"text":"                                            cost,","highlight_start":1,"highlight_end":50},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        result = brotli_max_size_t(result, l);","highlight_start":1,"highlight_end":79},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    best_len = l;","highlight_start":1,"highlight_end":50},{"text":"                                    l = l.wrapping_add(1);","highlight_start":1,"highlight_end":59},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if backward <= max_distance && !(prev_ix >= cur_ix) {\n                        prev_ix &= ringbuffer_mask;\n                        if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask\n                            || continuation as i32\n                                != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)\n                                    as i32)\n                        {\n                            len = FindMatchLengthWithLimit(\n                                &*ringbuffer.offset(prev_ix as isize),\n                                &*ringbuffer.offset(cur_ix_masked as isize),\n                                max_len,\n                            );\n                            let dist_cost =\n                                base_cost + ZopfliCostModelGetDistanceCost(model, j);\n                            let mut l: u64 = 0;\n                            l = best_len.wrapping_add(1);\n                            while l <= len {\n                                let copycode = GetCopyLengthCode(l);\n                                let cmdcode =\n                                    CombineLengthCodes(inscode, copycode, (j == 0) as i32);\n                                let cost = (if (cmdcode as i32) < 128 {\n                                    base_cost\n                                } else {\n                                    dist_cost\n                                }) + GetCopyExtra(copycode) as libc::c_float\n                                    + ZopfliCostModelGetCommandCost(model, cmdcode);\n                                if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {\n                                    UpdateZopfliNode(\n                                        nodes,\n                                        pos,\n                                        start,\n                                        l,\n                                        l,\n                                        backward,\n                                        j.wrapping_add(1),\n                                        cost,\n                                    );\n                                    result = brotli_max_size_t(result, l);\n                                }\n                                best_len = l;\n                                l = l.wrapping_add(1);\n                            }\n                        }\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:1496:21\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if backward <= max_distance {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if !(prev_ix >= cur_ix) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            prev_ix &= ringbuffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1540\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1541\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10mif backward <= max_distance && !(prev_ix >= cur_ix) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         prev_ix &= ringbuffer_mask;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1498\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if !(prev_ix.wrapping_add(best_len) > ringbuffer_mask\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             || continuation as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 != *ringbuffer.offset(prev_ix.wrapping_add(best_len) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     as i32)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1503\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             len = FindMatchLengthWithLimit(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1504\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 &*ringbuffer.offset(prev_ix as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1505\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 &*ringbuffer.offset(cur_ix_masked as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1506\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 max_len,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1507\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1508\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let dist_cost =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 base_cost + ZopfliCostModelGetDistanceCost(model, j);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let mut l: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1511\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l = best_len.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             while l <= len {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let copycode = GetCopyLengthCode(l);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let cmdcode =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     CombineLengthCodes(inscode, copycode, (j == 0) as i32);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let cost = (if (cmdcode as i32) < 128 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     base_cost\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     dist_cost\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1520\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }) + GetCopyExtra(copycode) as libc::c_float\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     + ZopfliCostModelGetCommandCost(model, cmdcode);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1522\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if cost < (*nodes.offset(pos.wrapping_add(l) as isize)).u.cost {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1523\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     UpdateZopfliNode(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1524\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         nodes,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1525\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         pos,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1526\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         start,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1529\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         backward,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1530\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         j.wrapping_add(1),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1531\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         cost,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1532\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1533\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     result = brotli_max_size_t(result, l);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1534\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1535\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 best_len = l;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1536\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l = l.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1537\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1538\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1539\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/bit_cost.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":27414,"byte_end":27830,"line_start":905,"line_end":914,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)","highlight_start":13,"highlight_end":97},{"text":"                as i32","highlight_start":1,"highlight_end":23},{"text":"                & mask_0 as i32","highlight_start":1,"highlight_end":32},{"text":"                != 0","highlight_start":1,"highlight_end":21},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {","highlight_start":1,"highlight_end":82},{"text":"                    cur_id = *block_id.offset(byte_ix_0 as isize);","highlight_start":1,"highlight_end":67},{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            };","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":27414,"byte_end":27830,"line_start":905,"line_end":914,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)","highlight_start":13,"highlight_end":97},{"text":"                as i32","highlight_start":1,"highlight_end":23},{"text":"                & mask_0 as i32","highlight_start":1,"highlight_end":32},{"text":"                != 0","highlight_start":1,"highlight_end":21},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {","highlight_start":1,"highlight_end":82},{"text":"                    cur_id = *block_id.offset(byte_ix_0 as isize);","highlight_start":1,"highlight_end":67},{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            };","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\n                as i32\n                & mask_0 as i32 != 0 && cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {\n                cur_id = *block_id.offset(byte_ix_0 as isize);\n                num_blocks = num_blocks.wrapping_add(1);\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:905:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m905\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m906\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m907\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                & mask_0 as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m908\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m913\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m914\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m905\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m906\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m907\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 & mask_0 as i32 != 0 && cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m908\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 cur_id = *block_id.offset(byte_ix_0 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m909\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 num_blocks = num_blocks.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m910\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~             }\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":31873,"byte_end":32289,"line_start":1024,"line_end":1033,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)","highlight_start":13,"highlight_end":97},{"text":"                as i32","highlight_start":1,"highlight_end":23},{"text":"                & mask_0 as i32","highlight_start":1,"highlight_end":32},{"text":"                != 0","highlight_start":1,"highlight_end":21},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {","highlight_start":1,"highlight_end":82},{"text":"                    cur_id = *block_id.offset(byte_ix_0 as isize);","highlight_start":1,"highlight_end":67},{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            };","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":31873,"byte_end":32289,"line_start":1024,"line_end":1033,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)","highlight_start":13,"highlight_end":97},{"text":"                as i32","highlight_start":1,"highlight_end":23},{"text":"                & mask_0 as i32","highlight_start":1,"highlight_end":32},{"text":"                != 0","highlight_start":1,"highlight_end":21},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {","highlight_start":1,"highlight_end":82},{"text":"                    cur_id = *block_id.offset(byte_ix_0 as isize);","highlight_start":1,"highlight_end":67},{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            };","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\n                as i32\n                & mask_0 as i32 != 0 && cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {\n                cur_id = *block_id.offset(byte_ix_0 as isize);\n                num_blocks = num_blocks.wrapping_add(1);\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1024:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1024\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1025\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                & mask_0 as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1032\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1033\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            };\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1024\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1025\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 & mask_0 as i32 != 0 && cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 cur_id = *block_id.offset(byte_ix_0 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 num_blocks = num_blocks.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~             }\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":36336,"byte_end":36752,"line_start":1143,"line_end":1152,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)","highlight_start":13,"highlight_end":97},{"text":"                as i32","highlight_start":1,"highlight_end":23},{"text":"                & mask_0 as i32","highlight_start":1,"highlight_end":32},{"text":"                != 0","highlight_start":1,"highlight_end":21},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {","highlight_start":1,"highlight_end":82},{"text":"                    cur_id = *block_id.offset(byte_ix_0 as isize);","highlight_start":1,"highlight_end":67},{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            };","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":36336,"byte_end":36752,"line_start":1143,"line_end":1152,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)","highlight_start":13,"highlight_end":97},{"text":"                as i32","highlight_start":1,"highlight_end":23},{"text":"                & mask_0 as i32","highlight_start":1,"highlight_end":32},{"text":"                != 0","highlight_start":1,"highlight_end":21},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                if cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {","highlight_start":1,"highlight_end":82},{"text":"                    cur_id = *block_id.offset(byte_ix_0 as isize);","highlight_start":1,"highlight_end":67},{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            };","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\n                as i32\n                & mask_0 as i32 != 0 && cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {\n                cur_id = *block_id.offset(byte_ix_0 as isize);\n                num_blocks = num_blocks.wrapping_add(1);\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1143:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                & mask_0 as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1151\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1152\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            };\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif *switch_signal.offset(ix_0.wrapping_add((cur_id as i32 >> 3i32) as u64) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 & mask_0 as i32 != 0 && cur_id as i32 != *block_id.offset(byte_ix_0 as isize) as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 cur_id = *block_id.offset(byte_ix_0 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 num_blocks = num_blocks.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~             }\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":95854,"byte_end":99742,"line_start":2671,"line_end":2749,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if length < kMinLengthForBlockSplitting {","highlight_start":1,"highlight_end":54},{"text":"                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":87},{"text":"                    let mut _new_size = if (*split).types_alloc_size == 0 {","highlight_start":1,"highlight_end":76},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).types_alloc_size","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array = 0 as *mut u8;","highlight_start":1,"highlight_end":54},{"text":"                    while _new_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":78},{"text":"                        _new_size = (_new_size as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array = if _new_size > 0 {","highlight_start":1,"highlight_end":51},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":88},{"text":"                        ) as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {","highlight_start":1,"highlight_end":76},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array as *mut libc::c_void,","highlight_start":1,"highlight_end":60},{"text":"                            (*split).types as *const libc::c_void,","highlight_start":1,"highlight_end":67},{"text":"                            ((*split).types_alloc_size)","highlight_start":1,"highlight_end":56},{"text":"                                .wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":83},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).types as *mut libc::c_void);","highlight_start":1,"highlight_end":72},{"text":"                    let ref mut fresh57 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh57 = 0 as *mut u8;","highlight_start":1,"highlight_end":45},{"text":"                    let ref mut fresh58 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh58 = new_array;","highlight_start":1,"highlight_end":42},{"text":"                    (*split).types_alloc_size = _new_size;","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":89},{"text":"                    let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {","highlight_start":1,"highlight_end":80},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).lengths_alloc_size","highlight_start":1,"highlight_end":52},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array_0 = 0 as *mut u32;","highlight_start":1,"highlight_end":57},{"text":"                    while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":80},{"text":"                        _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":83},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array_0 = if _new_size_0 > 0 {","highlight_start":1,"highlight_end":55},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":91},{"text":"                        ) as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {","highlight_start":1,"highlight_end":78},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array_0 as *mut libc::c_void,","highlight_start":1,"highlight_end":62},{"text":"                            (*split).lengths as *const libc::c_void,","highlight_start":1,"highlight_end":69},{"text":"                            ((*split).lengths_alloc_size)","highlight_start":1,"highlight_end":58},{"text":"                                .wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":84},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).lengths as *mut libc::c_void);","highlight_start":1,"highlight_end":74},{"text":"                    let ref mut fresh59 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh59 = 0 as *mut u32;","highlight_start":1,"highlight_end":46},{"text":"                    let ref mut fresh60 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh60 = new_array_0;","highlight_start":1,"highlight_end":44},{"text":"                    (*split).lengths_alloc_size = _new_size_0;","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if 0 != 0 {","highlight_start":1,"highlight_end":28},{"text":"                    return;","highlight_start":1,"highlight_end":28},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                (*split).num_types = 1;","highlight_start":1,"highlight_end":40},{"text":"                *((*split).types).offset((*split).num_blocks as isize) = 0;","highlight_start":1,"highlight_end":76},{"text":"                *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;","highlight_start":1,"highlight_end":90},{"text":"                let ref mut fresh61 = (*split).num_blocks;","highlight_start":1,"highlight_end":59},{"text":"                *fresh61 = (*fresh61).wrapping_add(1);","highlight_start":1,"highlight_end":55},{"text":"                return;","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":95854,"byte_end":99742,"line_start":2671,"line_end":2749,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if length < kMinLengthForBlockSplitting {","highlight_start":1,"highlight_end":54},{"text":"                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":87},{"text":"                    let mut _new_size = if (*split).types_alloc_size == 0 {","highlight_start":1,"highlight_end":76},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).types_alloc_size","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array = 0 as *mut u8;","highlight_start":1,"highlight_end":54},{"text":"                    while _new_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":78},{"text":"                        _new_size = (_new_size as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array = if _new_size > 0 {","highlight_start":1,"highlight_end":51},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":88},{"text":"                        ) as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {","highlight_start":1,"highlight_end":76},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array as *mut libc::c_void,","highlight_start":1,"highlight_end":60},{"text":"                            (*split).types as *const libc::c_void,","highlight_start":1,"highlight_end":67},{"text":"                            ((*split).types_alloc_size)","highlight_start":1,"highlight_end":56},{"text":"                                .wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":83},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).types as *mut libc::c_void);","highlight_start":1,"highlight_end":72},{"text":"                    let ref mut fresh57 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh57 = 0 as *mut u8;","highlight_start":1,"highlight_end":45},{"text":"                    let ref mut fresh58 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh58 = new_array;","highlight_start":1,"highlight_end":42},{"text":"                    (*split).types_alloc_size = _new_size;","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":89},{"text":"                    let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {","highlight_start":1,"highlight_end":80},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).lengths_alloc_size","highlight_start":1,"highlight_end":52},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array_0 = 0 as *mut u32;","highlight_start":1,"highlight_end":57},{"text":"                    while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":80},{"text":"                        _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":83},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array_0 = if _new_size_0 > 0 {","highlight_start":1,"highlight_end":55},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":91},{"text":"                        ) as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {","highlight_start":1,"highlight_end":78},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array_0 as *mut libc::c_void,","highlight_start":1,"highlight_end":62},{"text":"                            (*split).lengths as *const libc::c_void,","highlight_start":1,"highlight_end":69},{"text":"                            ((*split).lengths_alloc_size)","highlight_start":1,"highlight_end":58},{"text":"                                .wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":84},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).lengths as *mut libc::c_void);","highlight_start":1,"highlight_end":74},{"text":"                    let ref mut fresh59 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh59 = 0 as *mut u32;","highlight_start":1,"highlight_end":46},{"text":"                    let ref mut fresh60 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh60 = new_array_0;","highlight_start":1,"highlight_end":44},{"text":"                    (*split).lengths_alloc_size = _new_size_0;","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if 0 != 0 {","highlight_start":1,"highlight_end":28},{"text":"                    return;","highlight_start":1,"highlight_end":28},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                (*split).num_types = 1;","highlight_start":1,"highlight_end":40},{"text":"                *((*split).types).offset((*split).num_blocks as isize) = 0;","highlight_start":1,"highlight_end":76},{"text":"                *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;","highlight_start":1,"highlight_end":90},{"text":"                let ref mut fresh61 = (*split).num_blocks;","highlight_start":1,"highlight_end":59},{"text":"                *fresh61 = (*fresh61).wrapping_add(1);","highlight_start":1,"highlight_end":55},{"text":"                return;","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if length < kMinLengthForBlockSplitting {\n            if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\n                let mut _new_size = if (*split).types_alloc_size == 0 {\n                    ((*split).num_blocks).wrapping_add(1)\n                } else {\n                    (*split).types_alloc_size\n                };\n                let mut new_array = 0 as *mut u8;\n                while _new_size < ((*split).num_blocks).wrapping_add(1) {\n                    _new_size = (_new_size as u64).wrapping_mul(2) as u64;\n                }\n                new_array = if _new_size > 0 {\n                    BrotliAllocate(\n                        m,\n                        _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),\n                    ) as *mut u8\n                } else {\n                    0 as *mut u8\n                };\n                if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {\n                    memcpy(\n                        new_array as *mut libc::c_void,\n                        (*split).types as *const libc::c_void,\n                        ((*split).types_alloc_size)\n                            .wrapping_mul(::std::mem::size_of::<u8>() as u64),\n                    );\n                }\n                BrotliFree(m, (*split).types as *mut libc::c_void);\n                let ref mut fresh57 = (*split).types;\n                *fresh57 = 0 as *mut u8;\n                let ref mut fresh58 = (*split).types;\n                *fresh58 = new_array;\n                (*split).types_alloc_size = _new_size;\n            }\n            if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {\n                let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {\n                    ((*split).num_blocks).wrapping_add(1)\n                } else {\n                    (*split).lengths_alloc_size\n                };\n                let mut new_array_0 = 0 as *mut u32;\n                while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {\n                    _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;\n                }\n                new_array_0 = if _new_size_0 > 0 {\n                    BrotliAllocate(\n                        m,\n                        _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),\n                    ) as *mut u32\n                } else {\n                    0 as *mut u32\n                };\n                if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {\n                    memcpy(\n                        new_array_0 as *mut libc::c_void,\n                        (*split).lengths as *const libc::c_void,\n                        ((*split).lengths_alloc_size)\n                            .wrapping_mul(::std::mem::size_of::<u32>() as u64),\n                    );\n                }\n                BrotliFree(m, (*split).lengths as *mut libc::c_void);\n                let ref mut fresh59 = (*split).lengths;\n                *fresh59 = 0 as *mut u32;\n                let ref mut fresh60 = (*split).lengths;\n                *fresh60 = new_array_0;\n                (*split).lengths_alloc_size = _new_size_0;\n            }\n            if 0 != 0 {\n                return;\n            };\n            (*split).num_types = 1;\n            *((*split).types).offset((*split).num_blocks as isize) = 0;\n            *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;\n            let ref mut fresh61 = (*split).num_blocks;\n            *fresh61 = (*fresh61).wrapping_add(1);\n            return;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2671:16\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2671\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2672\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if length < kMinLengthForBlockSplitting {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2673\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2674\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut _new_size = if (*split).types_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2748\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2749\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2671\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        } else \u001b[0m\u001b[0m\u001b[38;5;10mif length < kMinLengthForBlockSplitting {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2672\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2673\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut _new_size = if (*split).types_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2674\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*split).num_blocks).wrapping_add(1)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2675\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2676\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*split).types_alloc_size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2677\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2678\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut new_array = 0 as *mut u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2679\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while _new_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2680\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     _new_size = (_new_size as u64).wrapping_mul(2) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2681\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2682\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 new_array = if _new_size > 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2683\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     BrotliAllocate(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2684\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2685\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2686\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as *mut u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2687\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2688\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     0 as *mut u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2689\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2690\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2691\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     memcpy(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2692\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         new_array as *mut libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2693\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*split).types as *const libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2694\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*split).types_alloc_size)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2695\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             .wrapping_mul(::std::mem::size_of::<u8>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2696\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2697\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2698\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 BrotliFree(m, (*split).types as *mut libc::c_void);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2699\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh57 = (*split).types;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2700\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh57 = 0 as *mut u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2701\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh58 = (*split).types;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2702\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh58 = new_array;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2703\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*split).types_alloc_size = _new_size;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2704\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2705\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2706\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2707\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*split).num_blocks).wrapping_add(1)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2708\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2709\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*split).lengths_alloc_size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2710\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2711\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut new_array_0 = 0 as *mut u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2712\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2713\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2714\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2715\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 new_array_0 = if _new_size_0 > 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2716\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     BrotliAllocate(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2717\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2718\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2719\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as *mut u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2720\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2721\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     0 as *mut u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2722\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2723\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2724\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     memcpy(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2725\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         new_array_0 as *mut libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2726\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*split).lengths as *const libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2727\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*split).lengths_alloc_size)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2728\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             .wrapping_mul(::std::mem::size_of::<u32>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2729\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2730\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2731\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 BrotliFree(m, (*split).lengths as *mut libc::c_void);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2732\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh59 = (*split).lengths;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2733\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh59 = 0 as *mut u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2734\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh60 = (*split).lengths;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2735\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh60 = new_array_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2736\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*split).lengths_alloc_size = _new_size_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2737\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2738\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if 0 != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2739\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2740\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2741\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             (*split).num_types = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2742\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *((*split).types).offset((*split).num_blocks as isize) = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2743\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2744\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let ref mut fresh61 = (*split).num_blocks;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2745\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *fresh61 = (*fresh61).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2746\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             return;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2747\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":104128,"byte_end":108016,"line_start":2880,"line_end":2958,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if length < kMinLengthForBlockSplitting {","highlight_start":1,"highlight_end":54},{"text":"                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":87},{"text":"                    let mut _new_size = if (*split).types_alloc_size == 0 {","highlight_start":1,"highlight_end":76},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).types_alloc_size","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array = 0 as *mut u8;","highlight_start":1,"highlight_end":54},{"text":"                    while _new_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":78},{"text":"                        _new_size = (_new_size as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array = if _new_size > 0 {","highlight_start":1,"highlight_end":51},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":88},{"text":"                        ) as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {","highlight_start":1,"highlight_end":76},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array as *mut libc::c_void,","highlight_start":1,"highlight_end":60},{"text":"                            (*split).types as *const libc::c_void,","highlight_start":1,"highlight_end":67},{"text":"                            ((*split).types_alloc_size)","highlight_start":1,"highlight_end":56},{"text":"                                .wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":83},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).types as *mut libc::c_void);","highlight_start":1,"highlight_end":72},{"text":"                    let ref mut fresh62 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh62 = 0 as *mut u8;","highlight_start":1,"highlight_end":45},{"text":"                    let ref mut fresh63 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh63 = new_array;","highlight_start":1,"highlight_end":42},{"text":"                    (*split).types_alloc_size = _new_size;","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":89},{"text":"                    let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {","highlight_start":1,"highlight_end":80},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).lengths_alloc_size","highlight_start":1,"highlight_end":52},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array_0 = 0 as *mut u32;","highlight_start":1,"highlight_end":57},{"text":"                    while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":80},{"text":"                        _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":83},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array_0 = if _new_size_0 > 0 {","highlight_start":1,"highlight_end":55},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":91},{"text":"                        ) as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {","highlight_start":1,"highlight_end":78},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array_0 as *mut libc::c_void,","highlight_start":1,"highlight_end":62},{"text":"                            (*split).lengths as *const libc::c_void,","highlight_start":1,"highlight_end":69},{"text":"                            ((*split).lengths_alloc_size)","highlight_start":1,"highlight_end":58},{"text":"                                .wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":84},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).lengths as *mut libc::c_void);","highlight_start":1,"highlight_end":74},{"text":"                    let ref mut fresh64 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh64 = 0 as *mut u32;","highlight_start":1,"highlight_end":46},{"text":"                    let ref mut fresh65 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh65 = new_array_0;","highlight_start":1,"highlight_end":44},{"text":"                    (*split).lengths_alloc_size = _new_size_0;","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if 0 != 0 {","highlight_start":1,"highlight_end":28},{"text":"                    return;","highlight_start":1,"highlight_end":28},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                (*split).num_types = 1;","highlight_start":1,"highlight_end":40},{"text":"                *((*split).types).offset((*split).num_blocks as isize) = 0;","highlight_start":1,"highlight_end":76},{"text":"                *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;","highlight_start":1,"highlight_end":90},{"text":"                let ref mut fresh66 = (*split).num_blocks;","highlight_start":1,"highlight_end":59},{"text":"                *fresh66 = (*fresh66).wrapping_add(1);","highlight_start":1,"highlight_end":55},{"text":"                return;","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":104128,"byte_end":108016,"line_start":2880,"line_end":2958,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if length < kMinLengthForBlockSplitting {","highlight_start":1,"highlight_end":54},{"text":"                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":87},{"text":"                    let mut _new_size = if (*split).types_alloc_size == 0 {","highlight_start":1,"highlight_end":76},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).types_alloc_size","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array = 0 as *mut u8;","highlight_start":1,"highlight_end":54},{"text":"                    while _new_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":78},{"text":"                        _new_size = (_new_size as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array = if _new_size > 0 {","highlight_start":1,"highlight_end":51},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":88},{"text":"                        ) as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {","highlight_start":1,"highlight_end":76},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array as *mut libc::c_void,","highlight_start":1,"highlight_end":60},{"text":"                            (*split).types as *const libc::c_void,","highlight_start":1,"highlight_end":67},{"text":"                            ((*split).types_alloc_size)","highlight_start":1,"highlight_end":56},{"text":"                                .wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":83},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).types as *mut libc::c_void);","highlight_start":1,"highlight_end":72},{"text":"                    let ref mut fresh62 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh62 = 0 as *mut u8;","highlight_start":1,"highlight_end":45},{"text":"                    let ref mut fresh63 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh63 = new_array;","highlight_start":1,"highlight_end":42},{"text":"                    (*split).types_alloc_size = _new_size;","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":89},{"text":"                    let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {","highlight_start":1,"highlight_end":80},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).lengths_alloc_size","highlight_start":1,"highlight_end":52},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array_0 = 0 as *mut u32;","highlight_start":1,"highlight_end":57},{"text":"                    while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":80},{"text":"                        _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":83},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array_0 = if _new_size_0 > 0 {","highlight_start":1,"highlight_end":55},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":91},{"text":"                        ) as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {","highlight_start":1,"highlight_end":78},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array_0 as *mut libc::c_void,","highlight_start":1,"highlight_end":62},{"text":"                            (*split).lengths as *const libc::c_void,","highlight_start":1,"highlight_end":69},{"text":"                            ((*split).lengths_alloc_size)","highlight_start":1,"highlight_end":58},{"text":"                                .wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":84},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).lengths as *mut libc::c_void);","highlight_start":1,"highlight_end":74},{"text":"                    let ref mut fresh64 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh64 = 0 as *mut u32;","highlight_start":1,"highlight_end":46},{"text":"                    let ref mut fresh65 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh65 = new_array_0;","highlight_start":1,"highlight_end":44},{"text":"                    (*split).lengths_alloc_size = _new_size_0;","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if 0 != 0 {","highlight_start":1,"highlight_end":28},{"text":"                    return;","highlight_start":1,"highlight_end":28},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                (*split).num_types = 1;","highlight_start":1,"highlight_end":40},{"text":"                *((*split).types).offset((*split).num_blocks as isize) = 0;","highlight_start":1,"highlight_end":76},{"text":"                *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;","highlight_start":1,"highlight_end":90},{"text":"                let ref mut fresh66 = (*split).num_blocks;","highlight_start":1,"highlight_end":59},{"text":"                *fresh66 = (*fresh66).wrapping_add(1);","highlight_start":1,"highlight_end":55},{"text":"                return;","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if length < kMinLengthForBlockSplitting {\n            if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\n                let mut _new_size = if (*split).types_alloc_size == 0 {\n                    ((*split).num_blocks).wrapping_add(1)\n                } else {\n                    (*split).types_alloc_size\n                };\n                let mut new_array = 0 as *mut u8;\n                while _new_size < ((*split).num_blocks).wrapping_add(1) {\n                    _new_size = (_new_size as u64).wrapping_mul(2) as u64;\n                }\n                new_array = if _new_size > 0 {\n                    BrotliAllocate(\n                        m,\n                        _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),\n                    ) as *mut u8\n                } else {\n                    0 as *mut u8\n                };\n                if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {\n                    memcpy(\n                        new_array as *mut libc::c_void,\n                        (*split).types as *const libc::c_void,\n                        ((*split).types_alloc_size)\n                            .wrapping_mul(::std::mem::size_of::<u8>() as u64),\n                    );\n                }\n                BrotliFree(m, (*split).types as *mut libc::c_void);\n                let ref mut fresh62 = (*split).types;\n                *fresh62 = 0 as *mut u8;\n                let ref mut fresh63 = (*split).types;\n                *fresh63 = new_array;\n                (*split).types_alloc_size = _new_size;\n            }\n            if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {\n                let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {\n                    ((*split).num_blocks).wrapping_add(1)\n                } else {\n                    (*split).lengths_alloc_size\n                };\n                let mut new_array_0 = 0 as *mut u32;\n                while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {\n                    _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;\n                }\n                new_array_0 = if _new_size_0 > 0 {\n                    BrotliAllocate(\n                        m,\n                        _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),\n                    ) as *mut u32\n                } else {\n                    0 as *mut u32\n                };\n                if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {\n                    memcpy(\n                        new_array_0 as *mut libc::c_void,\n                        (*split).lengths as *const libc::c_void,\n                        ((*split).lengths_alloc_size)\n                            .wrapping_mul(::std::mem::size_of::<u32>() as u64),\n                    );\n                }\n                BrotliFree(m, (*split).lengths as *mut libc::c_void);\n                let ref mut fresh64 = (*split).lengths;\n                *fresh64 = 0 as *mut u32;\n                let ref mut fresh65 = (*split).lengths;\n                *fresh65 = new_array_0;\n                (*split).lengths_alloc_size = _new_size_0;\n            }\n            if 0 != 0 {\n                return;\n            };\n            (*split).num_types = 1;\n            *((*split).types).offset((*split).num_blocks as isize) = 0;\n            *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;\n            let ref mut fresh66 = (*split).num_blocks;\n            *fresh66 = (*fresh66).wrapping_add(1);\n            return;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2880:16\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2880\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2881\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if length < kMinLengthForBlockSplitting {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2882\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2883\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut _new_size = if (*split).types_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2957\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2958\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2880\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        } else \u001b[0m\u001b[0m\u001b[38;5;10mif length < kMinLengthForBlockSplitting {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2881\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2882\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut _new_size = if (*split).types_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2883\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*split).num_blocks).wrapping_add(1)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2884\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2885\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*split).types_alloc_size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2886\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2887\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut new_array = 0 as *mut u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2888\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while _new_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2889\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     _new_size = (_new_size as u64).wrapping_mul(2) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2890\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2891\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 new_array = if _new_size > 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2892\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     BrotliAllocate(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2893\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2894\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2895\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as *mut u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2896\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2897\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     0 as *mut u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2898\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2899\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2900\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     memcpy(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2901\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         new_array as *mut libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2902\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*split).types as *const libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2903\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*split).types_alloc_size)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2904\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             .wrapping_mul(::std::mem::size_of::<u8>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2905\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2906\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2907\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 BrotliFree(m, (*split).types as *mut libc::c_void);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2908\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh62 = (*split).types;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2909\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh62 = 0 as *mut u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2910\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh63 = (*split).types;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2911\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh63 = new_array;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2912\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*split).types_alloc_size = _new_size;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2913\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2914\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2915\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2916\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*split).num_blocks).wrapping_add(1)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2917\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2918\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*split).lengths_alloc_size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2919\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2920\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut new_array_0 = 0 as *mut u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2921\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2922\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2923\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2924\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 new_array_0 = if _new_size_0 > 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2925\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     BrotliAllocate(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2926\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2927\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2928\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as *mut u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2929\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2930\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     0 as *mut u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2931\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2932\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2933\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     memcpy(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2934\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         new_array_0 as *mut libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2935\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*split).lengths as *const libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2936\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*split).lengths_alloc_size)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2937\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             .wrapping_mul(::std::mem::size_of::<u32>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2938\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2939\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2940\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 BrotliFree(m, (*split).lengths as *mut libc::c_void);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2941\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh64 = (*split).lengths;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2942\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh64 = 0 as *mut u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2943\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh65 = (*split).lengths;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2944\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh65 = new_array_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2945\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*split).lengths_alloc_size = _new_size_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2946\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2947\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if 0 != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2948\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2949\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2950\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             (*split).num_types = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2951\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *((*split).types).offset((*split).num_blocks as isize) = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2952\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2953\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let ref mut fresh66 = (*split).num_blocks;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2954\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *fresh66 = (*fresh66).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2955\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             return;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2956\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":112409,"byte_end":116297,"line_start":3089,"line_end":3167,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if length < kMinLengthForBlockSplitting {","highlight_start":1,"highlight_end":54},{"text":"                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":87},{"text":"                    let mut _new_size = if (*split).types_alloc_size == 0 {","highlight_start":1,"highlight_end":76},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).types_alloc_size","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array = 0 as *mut u8;","highlight_start":1,"highlight_end":54},{"text":"                    while _new_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":78},{"text":"                        _new_size = (_new_size as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array = if _new_size > 0 {","highlight_start":1,"highlight_end":51},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":88},{"text":"                        ) as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {","highlight_start":1,"highlight_end":76},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array as *mut libc::c_void,","highlight_start":1,"highlight_end":60},{"text":"                            (*split).types as *const libc::c_void,","highlight_start":1,"highlight_end":67},{"text":"                            ((*split).types_alloc_size)","highlight_start":1,"highlight_end":56},{"text":"                                .wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":83},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).types as *mut libc::c_void);","highlight_start":1,"highlight_end":72},{"text":"                    let ref mut fresh67 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh67 = 0 as *mut u8;","highlight_start":1,"highlight_end":45},{"text":"                    let ref mut fresh68 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh68 = new_array;","highlight_start":1,"highlight_end":42},{"text":"                    (*split).types_alloc_size = _new_size;","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":89},{"text":"                    let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {","highlight_start":1,"highlight_end":80},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).lengths_alloc_size","highlight_start":1,"highlight_end":52},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array_0 = 0 as *mut u32;","highlight_start":1,"highlight_end":57},{"text":"                    while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":80},{"text":"                        _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":83},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array_0 = if _new_size_0 > 0 {","highlight_start":1,"highlight_end":55},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":91},{"text":"                        ) as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {","highlight_start":1,"highlight_end":78},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array_0 as *mut libc::c_void,","highlight_start":1,"highlight_end":62},{"text":"                            (*split).lengths as *const libc::c_void,","highlight_start":1,"highlight_end":69},{"text":"                            ((*split).lengths_alloc_size)","highlight_start":1,"highlight_end":58},{"text":"                                .wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":84},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).lengths as *mut libc::c_void);","highlight_start":1,"highlight_end":74},{"text":"                    let ref mut fresh69 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh69 = 0 as *mut u32;","highlight_start":1,"highlight_end":46},{"text":"                    let ref mut fresh70 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh70 = new_array_0;","highlight_start":1,"highlight_end":44},{"text":"                    (*split).lengths_alloc_size = _new_size_0;","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if 0 != 0 {","highlight_start":1,"highlight_end":28},{"text":"                    return;","highlight_start":1,"highlight_end":28},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                (*split).num_types = 1;","highlight_start":1,"highlight_end":40},{"text":"                *((*split).types).offset((*split).num_blocks as isize) = 0;","highlight_start":1,"highlight_end":76},{"text":"                *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;","highlight_start":1,"highlight_end":90},{"text":"                let ref mut fresh71 = (*split).num_blocks;","highlight_start":1,"highlight_end":59},{"text":"                *fresh71 = (*fresh71).wrapping_add(1);","highlight_start":1,"highlight_end":55},{"text":"                return;","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":112409,"byte_end":116297,"line_start":3089,"line_end":3167,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if length < kMinLengthForBlockSplitting {","highlight_start":1,"highlight_end":54},{"text":"                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":87},{"text":"                    let mut _new_size = if (*split).types_alloc_size == 0 {","highlight_start":1,"highlight_end":76},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).types_alloc_size","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array = 0 as *mut u8;","highlight_start":1,"highlight_end":54},{"text":"                    while _new_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":78},{"text":"                        _new_size = (_new_size as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":79},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array = if _new_size > 0 {","highlight_start":1,"highlight_end":51},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":88},{"text":"                        ) as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u8","highlight_start":1,"highlight_end":37},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {","highlight_start":1,"highlight_end":76},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array as *mut libc::c_void,","highlight_start":1,"highlight_end":60},{"text":"                            (*split).types as *const libc::c_void,","highlight_start":1,"highlight_end":67},{"text":"                            ((*split).types_alloc_size)","highlight_start":1,"highlight_end":56},{"text":"                                .wrapping_mul(::std::mem::size_of::<u8>() as u64),","highlight_start":1,"highlight_end":83},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).types as *mut libc::c_void);","highlight_start":1,"highlight_end":72},{"text":"                    let ref mut fresh67 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh67 = 0 as *mut u8;","highlight_start":1,"highlight_end":45},{"text":"                    let ref mut fresh68 = (*split).types;","highlight_start":1,"highlight_end":58},{"text":"                    *fresh68 = new_array;","highlight_start":1,"highlight_end":42},{"text":"                    (*split).types_alloc_size = _new_size;","highlight_start":1,"highlight_end":59},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":89},{"text":"                    let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {","highlight_start":1,"highlight_end":80},{"text":"                        ((*split).num_blocks).wrapping_add(1)","highlight_start":1,"highlight_end":62},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        (*split).lengths_alloc_size","highlight_start":1,"highlight_end":52},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    let mut new_array_0 = 0 as *mut u32;","highlight_start":1,"highlight_end":57},{"text":"                    while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {","highlight_start":1,"highlight_end":80},{"text":"                        _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;","highlight_start":1,"highlight_end":83},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    new_array_0 = if _new_size_0 > 0 {","highlight_start":1,"highlight_end":55},{"text":"                        BrotliAllocate(","highlight_start":1,"highlight_end":40},{"text":"                            m,","highlight_start":1,"highlight_end":31},{"text":"                            _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":91},{"text":"                        ) as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        0 as *mut u32","highlight_start":1,"highlight_end":38},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {","highlight_start":1,"highlight_end":78},{"text":"                        memcpy(","highlight_start":1,"highlight_end":32},{"text":"                            new_array_0 as *mut libc::c_void,","highlight_start":1,"highlight_end":62},{"text":"                            (*split).lengths as *const libc::c_void,","highlight_start":1,"highlight_end":69},{"text":"                            ((*split).lengths_alloc_size)","highlight_start":1,"highlight_end":58},{"text":"                                .wrapping_mul(::std::mem::size_of::<u32>() as u64),","highlight_start":1,"highlight_end":84},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    BrotliFree(m, (*split).lengths as *mut libc::c_void);","highlight_start":1,"highlight_end":74},{"text":"                    let ref mut fresh69 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh69 = 0 as *mut u32;","highlight_start":1,"highlight_end":46},{"text":"                    let ref mut fresh70 = (*split).lengths;","highlight_start":1,"highlight_end":60},{"text":"                    *fresh70 = new_array_0;","highlight_start":1,"highlight_end":44},{"text":"                    (*split).lengths_alloc_size = _new_size_0;","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if 0 != 0 {","highlight_start":1,"highlight_end":28},{"text":"                    return;","highlight_start":1,"highlight_end":28},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                (*split).num_types = 1;","highlight_start":1,"highlight_end":40},{"text":"                *((*split).types).offset((*split).num_blocks as isize) = 0;","highlight_start":1,"highlight_end":76},{"text":"                *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;","highlight_start":1,"highlight_end":90},{"text":"                let ref mut fresh71 = (*split).num_blocks;","highlight_start":1,"highlight_end":59},{"text":"                *fresh71 = (*fresh71).wrapping_add(1);","highlight_start":1,"highlight_end":55},{"text":"                return;","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if length < kMinLengthForBlockSplitting {\n            if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\n                let mut _new_size = if (*split).types_alloc_size == 0 {\n                    ((*split).num_blocks).wrapping_add(1)\n                } else {\n                    (*split).types_alloc_size\n                };\n                let mut new_array = 0 as *mut u8;\n                while _new_size < ((*split).num_blocks).wrapping_add(1) {\n                    _new_size = (_new_size as u64).wrapping_mul(2) as u64;\n                }\n                new_array = if _new_size > 0 {\n                    BrotliAllocate(\n                        m,\n                        _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),\n                    ) as *mut u8\n                } else {\n                    0 as *mut u8\n                };\n                if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {\n                    memcpy(\n                        new_array as *mut libc::c_void,\n                        (*split).types as *const libc::c_void,\n                        ((*split).types_alloc_size)\n                            .wrapping_mul(::std::mem::size_of::<u8>() as u64),\n                    );\n                }\n                BrotliFree(m, (*split).types as *mut libc::c_void);\n                let ref mut fresh67 = (*split).types;\n                *fresh67 = 0 as *mut u8;\n                let ref mut fresh68 = (*split).types;\n                *fresh68 = new_array;\n                (*split).types_alloc_size = _new_size;\n            }\n            if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {\n                let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {\n                    ((*split).num_blocks).wrapping_add(1)\n                } else {\n                    (*split).lengths_alloc_size\n                };\n                let mut new_array_0 = 0 as *mut u32;\n                while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {\n                    _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;\n                }\n                new_array_0 = if _new_size_0 > 0 {\n                    BrotliAllocate(\n                        m,\n                        _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),\n                    ) as *mut u32\n                } else {\n                    0 as *mut u32\n                };\n                if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {\n                    memcpy(\n                        new_array_0 as *mut libc::c_void,\n                        (*split).lengths as *const libc::c_void,\n                        ((*split).lengths_alloc_size)\n                            .wrapping_mul(::std::mem::size_of::<u32>() as u64),\n                    );\n                }\n                BrotliFree(m, (*split).lengths as *mut libc::c_void);\n                let ref mut fresh69 = (*split).lengths;\n                *fresh69 = 0 as *mut u32;\n                let ref mut fresh70 = (*split).lengths;\n                *fresh70 = new_array_0;\n                (*split).lengths_alloc_size = _new_size_0;\n            }\n            if 0 != 0 {\n                return;\n            };\n            (*split).num_types = 1;\n            *((*split).types).offset((*split).num_blocks as isize) = 0;\n            *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;\n            let ref mut fresh71 = (*split).num_blocks;\n            *fresh71 = (*fresh71).wrapping_add(1);\n            return;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:3089:16\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3089\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3090\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if length < kMinLengthForBlockSplitting {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3091\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3092\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut _new_size = if (*split).types_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3167\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3089\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        } else \u001b[0m\u001b[0m\u001b[38;5;10mif length < kMinLengthForBlockSplitting {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3090\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (*split).types_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3091\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut _new_size = if (*split).types_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3092\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*split).num_blocks).wrapping_add(1)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3093\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3094\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*split).types_alloc_size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3095\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3096\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut new_array = 0 as *mut u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3097\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while _new_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3098\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     _new_size = (_new_size as u64).wrapping_mul(2) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3099\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 new_array = if _new_size > 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     BrotliAllocate(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         _new_size.wrapping_mul(::std::mem::size_of::<u8>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as *mut u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     0 as *mut u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if 0 == 0 && 0 == 0 && (*split).types_alloc_size != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     memcpy(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         new_array as *mut libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*split).types as *const libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*split).types_alloc_size)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             .wrapping_mul(::std::mem::size_of::<u8>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 BrotliFree(m, (*split).types as *mut libc::c_void);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh67 = (*split).types;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3118\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh67 = 0 as *mut u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh68 = (*split).types;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh68 = new_array;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*split).types_alloc_size = _new_size;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3122\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3123\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (*split).lengths_alloc_size < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3124\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut _new_size_0 = if (*split).lengths_alloc_size == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ((*split).num_blocks).wrapping_add(1)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3126\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (*split).lengths_alloc_size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3128\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut new_array_0 = 0 as *mut u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3130\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while _new_size_0 < ((*split).num_blocks).wrapping_add(1) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3131\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     _new_size_0 = (_new_size_0 as u64).wrapping_mul(2) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3132\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 new_array_0 = if _new_size_0 > 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     BrotliAllocate(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         m,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         _new_size_0.wrapping_mul(::std::mem::size_of::<u32>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3137\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) as *mut u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3138\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     0 as *mut u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3141\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if 0 == 0 && 0 == 0 && (*split).lengths_alloc_size != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3142\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     memcpy(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         new_array_0 as *mut libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*split).lengths as *const libc::c_void,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ((*split).lengths_alloc_size)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             .wrapping_mul(::std::mem::size_of::<u32>() as u64),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 BrotliFree(m, (*split).lengths as *mut libc::c_void);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh69 = (*split).lengths;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3151\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh69 = 0 as *mut u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3152\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let ref mut fresh70 = (*split).lengths;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 *fresh70 = new_array_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3154\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 (*split).lengths_alloc_size = _new_size_0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if 0 != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3158\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3159\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             (*split).num_types = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3160\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *((*split).types).offset((*split).num_blocks as isize) = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3161\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *((*split).lengths).offset((*split).num_blocks as isize) = length as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3162\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let ref mut fresh71 = (*split).num_blocks;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3163\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             *fresh71 = (*fresh71).wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             return;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3165\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":107321,"byte_end":107332,"line_start":2679,"line_end":2679,"column_start":47,"column_end":58,"is_primary":true,"text":[{"text":"            ((16 + 0i32) as u32).wrapping_add(62 << 0 + 1) as u64,","highlight_start":47,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":107321,"byte_end":107332,"line_start":2679,"line_end":2679,"column_start":47,"column_end":58,"is_primary":true,"text":[{"text":"            ((16 + 0i32) as u32).wrapping_add(62 << 0 + 1) as u64,","highlight_start":47,"highlight_end":58}],"label":null,"suggested_replacement":"62 << (0 + 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:2679:47\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2679\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ((16 + 0i32) as u32).wrapping_add(62 << 0 + 1) as u64,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `62 << (0 + 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/command.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/enc/command.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/command.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":4929,"byte_end":4944,"line_start":172,"line_end":172,"column_start":18,"column_end":33,"is_primary":true,"text":[{"text":"        let h = (v >> 8 * offset << 24i32).wrapping_mul(kHashMul32 as u64);","highlight_start":18,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":4929,"byte_end":4944,"line_start":172,"line_end":172,"column_start":18,"column_end":33,"is_primary":true,"text":[{"text":"        let h = (v >> 8 * offset << 24i32).wrapping_mul(kHashMul32 as u64);","highlight_start":18,"highlight_end":33}],"label":null,"suggested_replacement":"v >> (8 * offset)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/compress_fragment.rs:172:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (v >> 8 * offset << 24i32).wrapping_mul(kHashMul32 as u64);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `v >> (8 * offset)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":19645,"byte_end":19660,"line_start":739,"line_end":739,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":19645,"byte_end":19660,"line_start":739,"line_end":739,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (32 - 15i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:739:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m739\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 32 - 15i32) as u64;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 15i32)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":29878,"byte_end":29949,"line_start":1058,"line_end":1058,"column_start":14,"column_end":85,"is_primary":true,"text":[{"text":"            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;","highlight_start":14,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":29878,"byte_end":29949,"line_start":1058,"line_end":1058,"column_start":14,"column_end":85,"is_primary":true,"text":[{"text":"            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;","highlight_start":14,"highlight_end":85}],"label":null,"suggested_replacement":"(if (*params).quality > 6i32 { 7 } else { 8 }) << ((*params).quality - 4)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1058:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1058\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `(if (*params).quality > 6i32 { 7 } else { 8 }) << ((*params).quality - 4)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":30317,"byte_end":30388,"line_start":1073,"line_end":1073,"column_start":14,"column_end":85,"is_primary":true,"text":[{"text":"            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;","highlight_start":14,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":30317,"byte_end":30388,"line_start":1073,"line_end":1073,"column_start":14,"column_end":85,"is_primary":true,"text":[{"text":"            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;","highlight_start":14,"highlight_end":85}],"label":null,"suggested_replacement":"(if (*params).quality > 6i32 { 7 } else { 8 }) << ((*params).quality - 4)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1073:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1073\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `(if (*params).quality > 6i32 { 7 } else { 8 }) << ((*params).quality - 4)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":30758,"byte_end":30829,"line_start":1088,"line_end":1088,"column_start":14,"column_end":85,"is_primary":true,"text":[{"text":"            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;","highlight_start":14,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":30758,"byte_end":30829,"line_start":1088,"line_end":1088,"column_start":14,"column_end":85,"is_primary":true,"text":[{"text":"            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;","highlight_start":14,"highlight_end":85}],"label":null,"suggested_replacement":"(if (*params).quality > 6i32 { 7 } else { 8 }) << ((*params).quality - 4)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1088:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1088\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ((if (*params).quality > 6i32 { 7 } else { 8 }) << (*params).quality - 4) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `(if (*params).quality > 6i32 { 7 } else { 8 }) << ((*params).quality - 4)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":48014,"byte_end":48054,"line_start":1631,"line_end":1631,"column_start":32,"column_end":72,"is_primary":true,"text":[{"text":"        (*self_0).hash_mask_ = !0 >> 64 - 8 * (*common).params.hash_len;","highlight_start":32,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":48014,"byte_end":48054,"line_start":1631,"line_end":1631,"column_start":32,"column_end":72,"is_primary":true,"text":[{"text":"        (*self_0).hash_mask_ = !0 >> 64 - 8 * (*common).params.hash_len;","highlight_start":32,"highlight_end":72}],"label":null,"suggested_replacement":"!0 >> (64 - 8 * (*common).params.hash_len)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1631:32\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*self_0).hash_mask_ = !0 >> 64 - 8 * (*common).params.hash_len;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `!0 >> (64 - 8 * (*common).params.hash_len)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":56981,"byte_end":57048,"line_start":1882,"line_end":1882,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":56981,"byte_end":57048,"line_start":1882,"line_end":1882,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1882:18\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1882\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":57105,"byte_end":57120,"line_start":1884,"line_end":1884,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":57105,"byte_end":57120,"line_start":1884,"line_end":1884,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 16i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1884:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1884\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 16i32) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 16i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":58562,"byte_end":58629,"line_start":1937,"line_end":1937,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":58562,"byte_end":58629,"line_start":1937,"line_end":1937,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1937:18\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1937\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":58686,"byte_end":58701,"line_start":1939,"line_end":1939,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 17i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":58686,"byte_end":58701,"line_start":1939,"line_end":1939,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 17i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 17i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:1939:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1939\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 17i32) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 17i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":63572,"byte_end":63605,"line_start":2098,"line_end":2098,"column_start":20,"column_end":53,"is_primary":true,"text":[{"text":"        let idx = (fresh41 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":63572,"byte_end":63605,"line_start":2098,"line_end":2098,"column_start":20,"column_end":53,"is_primary":true,"text":[{"text":"        let idx = (fresh41 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":53}],"label":null,"suggested_replacement":"fresh41 as i32 & ((1i32 << 16) - 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2098:20\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2098\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let idx = (fresh41 as i32 & (1i32 << 16) - 1) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `fresh41 as i32 & ((1i32 << 16) - 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":66101,"byte_end":66116,"line_start":2179,"line_end":2179,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":66101,"byte_end":66116,"line_start":2179,"line_end":2179,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (32 - 15i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2179:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 32 - 15i32) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 15i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":66742,"byte_end":66775,"line_start":2195,"line_end":2195,"column_start":20,"column_end":53,"is_primary":true,"text":[{"text":"        let idx = (fresh43 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":66742,"byte_end":66775,"line_start":2195,"line_end":2195,"column_start":20,"column_end":53,"is_primary":true,"text":[{"text":"        let idx = (fresh43 as i32 & (1i32 << 16) - 1) as u64;","highlight_start":20,"highlight_end":53}],"label":null,"suggested_replacement":"fresh43 as i32 & ((1i32 << 16) - 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2195:20\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let idx = (fresh43 as i32 & (1i32 << 16) - 1) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `fresh43 as i32 & ((1i32 << 16) - 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":69015,"byte_end":69030,"line_start":2269,"line_end":2269,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":69015,"byte_end":69030,"line_start":2269,"line_end":2269,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 32 - 15i32) as u64;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (32 - 15i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2269:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 32 - 15i32) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 15i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":69658,"byte_end":69690,"line_start":2285,"line_end":2285,"column_start":20,"column_end":52,"is_primary":true,"text":[{"text":"        let idx = (fresh45 as i32 & (1i32 << 9) - 1) as u64;","highlight_start":20,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":69658,"byte_end":69690,"line_start":2285,"line_end":2285,"column_start":20,"column_end":52,"is_primary":true,"text":[{"text":"        let idx = (fresh45 as i32 & (1i32 << 9) - 1) as u64;","highlight_start":20,"highlight_end":52}],"label":null,"suggested_replacement":"fresh45 as i32 & ((1i32 << 9) - 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2285:20\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let idx = (fresh45 as i32 & (1i32 << 9) - 1) as u64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `fresh45 as i32 & ((1i32 << 9) - 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":71185,"byte_end":71252,"line_start":2337,"line_end":2337,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":71185,"byte_end":71252,"line_start":2337,"line_end":2337,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2337:18\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 5i32)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 5i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":71309,"byte_end":71324,"line_start":2339,"line_end":2339,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":71309,"byte_end":71324,"line_start":2339,"line_end":2339,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 16i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 16i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2339:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2339\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 16i32) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 16i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":73483,"byte_end":73550,"line_start":2424,"line_end":2424,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 7i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":73483,"byte_end":73550,"line_start":2424,"line_end":2424,"column_start":18,"column_end":85,"is_primary":true,"text":[{"text":"        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 7i32)","highlight_start":18,"highlight_end":85}],"label":null,"suggested_replacement":"BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 7i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2424:18\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2424\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let h = (BrotliUnalignedRead64(data as *const libc::c_void) << 64 - 8 * 7i32)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `BrotliUnalignedRead64(data as *const libc::c_void) << (64 - 8 * 7i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":73607,"byte_end":73622,"line_start":2426,"line_end":2426,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 20i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":73607,"byte_end":73622,"line_start":2426,"line_end":2426,"column_start":17,"column_end":32,"is_primary":true,"text":[{"text":"        return (h >> 64 - 20i32) as u32;","highlight_start":17,"highlight_end":32}],"label":null,"suggested_replacement":"h >> (64 - 20i32)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2426:17\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2426\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return (h >> 64 - 20i32) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (64 - 20i32)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":84262,"byte_end":84274,"line_start":2808,"line_end":2808,"column_start":16,"column_end":28,"is_primary":true,"text":[{"text":"        return h >> 32 - 17;","highlight_start":16,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":84262,"byte_end":84274,"line_start":2808,"line_end":2808,"column_start":16,"column_end":28,"is_primary":true,"text":[{"text":"        return h >> 32 - 17;","highlight_start":16,"highlight_end":28}],"label":null,"suggested_replacement":"h >> (32 - 17)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:2808:16\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2808\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return h >> 32 - 17;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - 17)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":113614,"byte_end":113724,"line_start":3685,"line_end":3689,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if quality == 0 {","highlight_start":9,"highlight_end":26},{"text":"            if htsize & 0xaaaaa == 0 {","highlight_start":1,"highlight_end":39},{"text":"                htsize <<= 1;","highlight_start":1,"highlight_end":30},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":113614,"byte_end":113724,"line_start":3685,"line_end":3689,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if quality == 0 {","highlight_start":9,"highlight_end":26},{"text":"            if htsize & 0xaaaaa == 0 {","highlight_start":1,"highlight_end":39},{"text":"                htsize <<= 1;","highlight_start":1,"highlight_end":30},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if quality == 0 && htsize & 0xaaaaa == 0 {\n            htsize <<= 1;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:3685:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3685\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if quality == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3686\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if htsize & 0xaaaaa == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3687\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                htsize <<= 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3688\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3689\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3685\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif quality == 0 && htsize & 0xaaaaa == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3686\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             htsize <<= 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3687\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":125491,"byte_end":127337,"line_start":3969,"line_end":4010,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if !(ShouldUseComplexStaticContextMap(","highlight_start":1,"highlight_end":51},{"text":"                input,","highlight_start":1,"highlight_end":23},{"text":"                start_pos,","highlight_start":1,"highlight_end":27},{"text":"                length,","highlight_start":1,"highlight_end":24},{"text":"                mask,","highlight_start":1,"highlight_end":22},{"text":"                quality,","highlight_start":1,"highlight_end":25},{"text":"                size_hint,","highlight_start":1,"highlight_end":27},{"text":"                num_literal_contexts,","highlight_start":1,"highlight_end":38},{"text":"                literal_context_map,","highlight_start":1,"highlight_end":37},{"text":"            ) != 0)","highlight_start":1,"highlight_end":20},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                let end_pos = start_pos.wrapping_add(length);","highlight_start":1,"highlight_end":62},{"text":"                let mut bigram_prefix_histo: [u32; 9] = [0; 9];","highlight_start":1,"highlight_end":64},{"text":"                while start_pos.wrapping_add(64) <= end_pos {","highlight_start":1,"highlight_end":62},{"text":"                    static mut lut: [i32; 4] = [0, 0, 1, 2];","highlight_start":1,"highlight_end":61},{"text":"                    let stride_end_pos = start_pos.wrapping_add(64);","highlight_start":1,"highlight_end":69},{"text":"                    let mut prev = lut","highlight_start":1,"highlight_end":39},{"text":"                        [(*input.offset((start_pos & mask) as isize) as i32 >> 6i32) as usize]","highlight_start":1,"highlight_end":95},{"text":"                        * 3;","highlight_start":1,"highlight_end":29},{"text":"                    let mut pos: u64 = 0;","highlight_start":1,"highlight_end":42},{"text":"                    pos = start_pos.wrapping_add(1);","highlight_start":1,"highlight_end":53},{"text":"                    while pos < stride_end_pos {","highlight_start":1,"highlight_end":49},{"text":"                        let literal = *input.offset((pos & mask) as isize);","highlight_start":1,"highlight_end":76},{"text":"                        bigram_prefix_histo","highlight_start":1,"highlight_end":44},{"text":"                            [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize] =","highlight_start":1,"highlight_end":89},{"text":"                            (bigram_prefix_histo","highlight_start":1,"highlight_end":49},{"text":"                                [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize])","highlight_start":1,"highlight_end":92},{"text":"                                .wrapping_add(1);","highlight_start":1,"highlight_end":50},{"text":"                        prev = lut[(literal as i32 >> 6i32) as usize] * 3;","highlight_start":1,"highlight_end":75},{"text":"                        pos = pos.wrapping_add(1);","highlight_start":1,"highlight_end":51},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    start_pos = (start_pos as u64).wrapping_add(4096) as u64;","highlight_start":1,"highlight_end":78},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                ChooseContextMap(","highlight_start":1,"highlight_end":34},{"text":"                    quality,","highlight_start":1,"highlight_end":29},{"text":"                    &mut *bigram_prefix_histo.as_mut_ptr().offset(0 as isize),","highlight_start":1,"highlight_end":79},{"text":"                    num_literal_contexts,","highlight_start":1,"highlight_end":42},{"text":"                    literal_context_map,","highlight_start":1,"highlight_end":41},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        };","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":125491,"byte_end":127337,"line_start":3969,"line_end":4010,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        } else {","highlight_start":16,"highlight_end":17},{"text":"            if !(ShouldUseComplexStaticContextMap(","highlight_start":1,"highlight_end":51},{"text":"                input,","highlight_start":1,"highlight_end":23},{"text":"                start_pos,","highlight_start":1,"highlight_end":27},{"text":"                length,","highlight_start":1,"highlight_end":24},{"text":"                mask,","highlight_start":1,"highlight_end":22},{"text":"                quality,","highlight_start":1,"highlight_end":25},{"text":"                size_hint,","highlight_start":1,"highlight_end":27},{"text":"                num_literal_contexts,","highlight_start":1,"highlight_end":38},{"text":"                literal_context_map,","highlight_start":1,"highlight_end":37},{"text":"            ) != 0)","highlight_start":1,"highlight_end":20},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                let end_pos = start_pos.wrapping_add(length);","highlight_start":1,"highlight_end":62},{"text":"                let mut bigram_prefix_histo: [u32; 9] = [0; 9];","highlight_start":1,"highlight_end":64},{"text":"                while start_pos.wrapping_add(64) <= end_pos {","highlight_start":1,"highlight_end":62},{"text":"                    static mut lut: [i32; 4] = [0, 0, 1, 2];","highlight_start":1,"highlight_end":61},{"text":"                    let stride_end_pos = start_pos.wrapping_add(64);","highlight_start":1,"highlight_end":69},{"text":"                    let mut prev = lut","highlight_start":1,"highlight_end":39},{"text":"                        [(*input.offset((start_pos & mask) as isize) as i32 >> 6i32) as usize]","highlight_start":1,"highlight_end":95},{"text":"                        * 3;","highlight_start":1,"highlight_end":29},{"text":"                    let mut pos: u64 = 0;","highlight_start":1,"highlight_end":42},{"text":"                    pos = start_pos.wrapping_add(1);","highlight_start":1,"highlight_end":53},{"text":"                    while pos < stride_end_pos {","highlight_start":1,"highlight_end":49},{"text":"                        let literal = *input.offset((pos & mask) as isize);","highlight_start":1,"highlight_end":76},{"text":"                        bigram_prefix_histo","highlight_start":1,"highlight_end":44},{"text":"                            [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize] =","highlight_start":1,"highlight_end":89},{"text":"                            (bigram_prefix_histo","highlight_start":1,"highlight_end":49},{"text":"                                [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize])","highlight_start":1,"highlight_end":92},{"text":"                                .wrapping_add(1);","highlight_start":1,"highlight_end":50},{"text":"                        prev = lut[(literal as i32 >> 6i32) as usize] * 3;","highlight_start":1,"highlight_end":75},{"text":"                        pos = pos.wrapping_add(1);","highlight_start":1,"highlight_end":51},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    start_pos = (start_pos as u64).wrapping_add(4096) as u64;","highlight_start":1,"highlight_end":78},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                ChooseContextMap(","highlight_start":1,"highlight_end":34},{"text":"                    quality,","highlight_start":1,"highlight_end":29},{"text":"                    &mut *bigram_prefix_histo.as_mut_ptr().offset(0 as isize),","highlight_start":1,"highlight_end":79},{"text":"                    num_literal_contexts,","highlight_start":1,"highlight_end":42},{"text":"                    literal_context_map,","highlight_start":1,"highlight_end":41},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        };","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if !(ShouldUseComplexStaticContextMap(\n            input,\n            start_pos,\n            length,\n            mask,\n            quality,\n            size_hint,\n            num_literal_contexts,\n            literal_context_map,\n        ) != 0)\n        {\n            let end_pos = start_pos.wrapping_add(length);\n            let mut bigram_prefix_histo: [u32; 9] = [0; 9];\n            while start_pos.wrapping_add(64) <= end_pos {\n                static mut lut: [i32; 4] = [0, 0, 1, 2];\n                let stride_end_pos = start_pos.wrapping_add(64);\n                let mut prev = lut\n                    [(*input.offset((start_pos & mask) as isize) as i32 >> 6i32) as usize]\n                    * 3;\n                let mut pos: u64 = 0;\n                pos = start_pos.wrapping_add(1);\n                while pos < stride_end_pos {\n                    let literal = *input.offset((pos & mask) as isize);\n                    bigram_prefix_histo\n                        [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize] =\n                        (bigram_prefix_histo\n                            [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize])\n                            .wrapping_add(1);\n                    prev = lut[(literal as i32 >> 6i32) as usize] * 3;\n                    pos = pos.wrapping_add(1);\n                }\n                start_pos = (start_pos as u64).wrapping_add(4096) as u64;\n            }\n            ChooseContextMap(\n                quality,\n                &mut *bigram_prefix_histo.as_mut_ptr().offset(0 as isize),\n                num_literal_contexts,\n                literal_context_map,\n            );\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:3969:16\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3969\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        } else {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3970\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if !(ShouldUseComplexStaticContextMap(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3971\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                input,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3972\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                start_pos,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4009\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4010\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        };\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3969\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        } else \u001b[0m\u001b[0m\u001b[38;5;10mif !(ShouldUseComplexStaticContextMap(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3970\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             input,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3971\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             start_pos,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3972\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             length,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3973\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             mask,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3974\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             quality,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3975\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             size_hint,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3976\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             num_literal_contexts,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3977\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             literal_context_map,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3978\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         ) != 0)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3979\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3980\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let end_pos = start_pos.wrapping_add(length);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3981\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut bigram_prefix_histo: [u32; 9] = [0; 9];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3982\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             while start_pos.wrapping_add(64) <= end_pos {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3983\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 static mut lut: [i32; 4] = [0, 0, 1, 2];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3984\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let stride_end_pos = start_pos.wrapping_add(64);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3985\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut prev = lut\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3986\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     [(*input.offset((start_pos & mask) as isize) as i32 >> 6i32) as usize]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3987\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     * 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3988\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut pos: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3989\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 pos = start_pos.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3990\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 while pos < stride_end_pos {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3991\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     let literal = *input.offset((pos & mask) as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3992\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     bigram_prefix_histo\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3993\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize] =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3994\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (bigram_prefix_histo\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3995\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             [(prev + lut[(literal as i32 >> 6i32) as usize]) as usize])\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3996\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             .wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3997\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     prev = lut[(literal as i32 >> 6i32) as usize] * 3;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3998\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     pos = pos.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3999\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4000\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 start_pos = (start_pos as u64).wrapping_add(4096) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4001\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4002\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             ChooseContextMap(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 quality,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4004\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 &mut *bigram_prefix_histo.as_mut_ptr().offset(0 as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4005\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 num_literal_contexts,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4006\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 literal_context_map,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4007\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4008\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~         }\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":127593,"byte_end":128806,"line_start":4026,"line_end":4050,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if num_commands < (bytes >> 8i32).wrapping_add(2) {","highlight_start":9,"highlight_end":60},{"text":"            if num_literals as f64 > 0.99f64 * bytes as f64 {","highlight_start":1,"highlight_end":62},{"text":"                let mut literal_histo: [u32; 256] = [0; 256];","highlight_start":1,"highlight_end":62},{"text":"                static mut kSampleRate: u32 = 13;","highlight_start":1,"highlight_end":50},{"text":"                static mut kMinEntropy: f64 = 7.92f64;","highlight_start":1,"highlight_end":55},{"text":"                let bit_cost_threshold = bytes as f64 * kMinEntropy / kSampleRate as f64;","highlight_start":1,"highlight_end":90},{"text":"                let mut t = bytes","highlight_start":1,"highlight_end":34},{"text":"                    .wrapping_add(kSampleRate as u64)","highlight_start":1,"highlight_end":54},{"text":"                    .wrapping_sub(1)","highlight_start":1,"highlight_end":37},{"text":"                    .wrapping_div(kSampleRate as u64);","highlight_start":1,"highlight_end":55},{"text":"                let mut pos = last_flush_pos as u32;","highlight_start":1,"highlight_end":53},{"text":"                let mut i: u64 = 0;","highlight_start":1,"highlight_end":36},{"text":"                i = 0;","highlight_start":1,"highlight_end":23},{"text":"                while i < t {","highlight_start":1,"highlight_end":30},{"text":"                    literal_histo[*data.offset((pos as u64 & mask) as isize) as usize] =","highlight_start":1,"highlight_end":89},{"text":"                        (literal_histo[*data.offset((pos as u64 & mask) as isize) as usize])","highlight_start":1,"highlight_end":93},{"text":"                            .wrapping_add(1);","highlight_start":1,"highlight_end":46},{"text":"                    pos = (pos as u32).wrapping_add(kSampleRate) as u32;","highlight_start":1,"highlight_end":73},{"text":"                    i = i.wrapping_add(1);","highlight_start":1,"highlight_end":43},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if BitsEntropy(literal_histo.as_mut_ptr(), 256) > bit_cost_threshold {","highlight_start":1,"highlight_end":87},{"text":"                    return 0;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":127593,"byte_end":128806,"line_start":4026,"line_end":4050,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if num_commands < (bytes >> 8i32).wrapping_add(2) {","highlight_start":9,"highlight_end":60},{"text":"            if num_literals as f64 > 0.99f64 * bytes as f64 {","highlight_start":1,"highlight_end":62},{"text":"                let mut literal_histo: [u32; 256] = [0; 256];","highlight_start":1,"highlight_end":62},{"text":"                static mut kSampleRate: u32 = 13;","highlight_start":1,"highlight_end":50},{"text":"                static mut kMinEntropy: f64 = 7.92f64;","highlight_start":1,"highlight_end":55},{"text":"                let bit_cost_threshold = bytes as f64 * kMinEntropy / kSampleRate as f64;","highlight_start":1,"highlight_end":90},{"text":"                let mut t = bytes","highlight_start":1,"highlight_end":34},{"text":"                    .wrapping_add(kSampleRate as u64)","highlight_start":1,"highlight_end":54},{"text":"                    .wrapping_sub(1)","highlight_start":1,"highlight_end":37},{"text":"                    .wrapping_div(kSampleRate as u64);","highlight_start":1,"highlight_end":55},{"text":"                let mut pos = last_flush_pos as u32;","highlight_start":1,"highlight_end":53},{"text":"                let mut i: u64 = 0;","highlight_start":1,"highlight_end":36},{"text":"                i = 0;","highlight_start":1,"highlight_end":23},{"text":"                while i < t {","highlight_start":1,"highlight_end":30},{"text":"                    literal_histo[*data.offset((pos as u64 & mask) as isize) as usize] =","highlight_start":1,"highlight_end":89},{"text":"                        (literal_histo[*data.offset((pos as u64 & mask) as isize) as usize])","highlight_start":1,"highlight_end":93},{"text":"                            .wrapping_add(1);","highlight_start":1,"highlight_end":46},{"text":"                    pos = (pos as u32).wrapping_add(kSampleRate) as u32;","highlight_start":1,"highlight_end":73},{"text":"                    i = i.wrapping_add(1);","highlight_start":1,"highlight_end":43},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if BitsEntropy(literal_histo.as_mut_ptr(), 256) > bit_cost_threshold {","highlight_start":1,"highlight_end":87},{"text":"                    return 0;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if num_commands < (bytes >> 8i32).wrapping_add(2) && num_literals as f64 > 0.99f64 * bytes as f64 {\n            let mut literal_histo: [u32; 256] = [0; 256];\n            static mut kSampleRate: u32 = 13;\n            static mut kMinEntropy: f64 = 7.92f64;\n            let bit_cost_threshold = bytes as f64 * kMinEntropy / kSampleRate as f64;\n            let mut t = bytes\n                .wrapping_add(kSampleRate as u64)\n                .wrapping_sub(1)\n                .wrapping_div(kSampleRate as u64);\n            let mut pos = last_flush_pos as u32;\n            let mut i: u64 = 0;\n            i = 0;\n            while i < t {\n                literal_histo[*data.offset((pos as u64 & mask) as isize) as usize] =\n                    (literal_histo[*data.offset((pos as u64 & mask) as isize) as usize])\n                        .wrapping_add(1);\n                pos = (pos as u32).wrapping_add(kSampleRate) as u32;\n                i = i.wrapping_add(1);\n            }\n            if BitsEntropy(literal_histo.as_mut_ptr(), 256) > bit_cost_threshold {\n                return 0;\n            }\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:4026:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if num_commands < (bytes >> 8i32).wrapping_add(2) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if num_literals as f64 > 0.99f64 * bytes as f64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let mut literal_histo: [u32; 256] = [0; 256];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                static mut kSampleRate: u32 = 13;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4049\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4050\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4026\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif num_commands < (bytes >> 8i32).wrapping_add(2) && num_literals as f64 > 0.99f64 * bytes as f64 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4027\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut literal_histo: [u32; 256] = [0; 256];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             static mut kSampleRate: u32 = 13;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             static mut kMinEntropy: f64 = 7.92f64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4030\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let bit_cost_threshold = bytes as f64 * kMinEntropy / kSampleRate as f64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4031\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut t = bytes\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4032\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 .wrapping_add(kSampleRate as u64)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4033\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 .wrapping_sub(1)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4034\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 .wrapping_div(kSampleRate as u64);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4035\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut pos = last_flush_pos as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4036\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut i: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4037\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             i = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4038\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             while i < t {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4039\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 literal_histo[*data.offset((pos as u64 & mask) as isize) as usize] =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4040\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     (literal_histo[*data.offset((pos as u64 & mask) as isize) as usize])\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4041\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         .wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4042\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 pos = (pos as u32).wrapping_add(kSampleRate) as u32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4043\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 i = i.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4044\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4045\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if BitsEntropy(literal_histo.as_mut_ptr(), 256) > bit_cost_threshold {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4046\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4047\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4048\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/encode.rs","byte_start":140534,"byte_end":140545,"line_start":4397,"line_end":4397,"column_start":78,"column_end":89,"is_primary":true,"text":[{"text":"        (*params).dist.alphabet_size_max = ((16 + 0i32) as u32).wrapping_add(24 << 0 + 1);","highlight_start":78,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":140534,"byte_end":140545,"line_start":4397,"line_end":4397,"column_start":78,"column_end":89,"is_primary":true,"text":[{"text":"        (*params).dist.alphabet_size_max = ((16 + 0i32) as u32).wrapping_add(24 << 0 + 1);","highlight_start":78,"highlight_end":89}],"label":null,"suggested_replacement":"24 << (0 + 1)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:4397:78\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (*params).dist.alphabet_size_max = ((16 + 0i32) as u32).wrapping_add(24 << 0 + 1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `24 << (0 + 1)`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/fast_log.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/enc/fast_log.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/fast_log.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/histogram.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/enc/histogram.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/histogram.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"operator precedence can trip the unwary","code":{"code":"clippy::precedence","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":4396,"byte_end":4418,"line_start":135,"line_end":135,"column_start":16,"column_end":38,"is_primary":true,"text":[{"text":"        return h >> 32 - kDictNumBits;","highlight_start":16,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider parenthesizing your expression","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":4396,"byte_end":4418,"line_start":135,"line_end":135,"column_start":16,"column_end":38,"is_primary":true,"text":[{"text":"        return h >> 32 - kDictNumBits;","highlight_start":16,"highlight_end":38}],"label":null,"suggested_replacement":"h >> (32 - kDictNumBits)","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: operator precedence can trip the unwary\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:135:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return h >> 32 - kDictNumBits;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: consider parenthesizing your expression: `h >> (32 - kDictNumBits)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":12236,"byte_end":12813,"line_start":325,"line_end":336,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'n' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == 'd' as i32","highlight_start":1,"highlight_end":74},{"text":"                                && *s.offset(4 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":78},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(10u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(5),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":12236,"byte_end":12813,"line_start":325,"line_end":336,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'n' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == 'd' as i32","highlight_start":1,"highlight_end":74},{"text":"                                && *s.offset(4 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":78},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(10u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(5),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if *s.offset(2 as isize) as i32 == 'n' as i32 && *s.offset(3 as isize) as i32 == 'd' as i32 && *s.offset(4 as isize) as i32 == ' ' as i32 {\n                            AddMatch(\n                                id.wrapping_add(10u64.wrapping_mul(n)),\n                                l.wrapping_add(5),\n                                l,\n                                matches,\n                            );\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:325:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else if *s.offset(2 as isize) as i32 == 'n' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if *s.offset(3 as isize) as i32 == 'd' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                && *s.offset(4 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m328\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m335\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m336\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(2 as isize) as i32 == 'n' as i32 && *s.offset(3 as isize) as i32 == 'd' as i32 && *s.offset(4 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 id.wrapping_add(10u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m328\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l.wrapping_add(5),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m329\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m330\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m332\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":13929,"byte_end":14400,"line_start":358,"line_end":367,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 's' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":76},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(47u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(4),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":13929,"byte_end":14400,"line_start":358,"line_end":367,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 's' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":76},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(47u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(4),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if *s.offset(2 as isize) as i32 == 's' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\n                            AddMatch(\n                                id.wrapping_add(47u64.wrapping_mul(n)),\n                                l.wrapping_add(4),\n                                l,\n                                matches,\n                            );\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:358:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m358\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else if *s.offset(2 as isize) as i32 == 's' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m359\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m360\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m361\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                    id.wrapping_add(47u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m366\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m367\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m358\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(2 as isize) as i32 == 's' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m359\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m360\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 id.wrapping_add(47u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m361\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l.wrapping_add(4),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m362\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m363\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m364\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m365\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":15083,"byte_end":15738,"line_start":380,"line_end":392,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'r' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":74},{"text":"                                && *s.offset(4 as isize) as i32 == 'm' as i32","highlight_start":1,"highlight_end":78},{"text":"                                && *s.offset(5 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":78},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(37u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(6),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":15083,"byte_end":15738,"line_start":380,"line_end":392,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'r' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":74},{"text":"                                && *s.offset(4 as isize) as i32 == 'm' as i32","highlight_start":1,"highlight_end":78},{"text":"                                && *s.offset(5 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":78},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(37u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(6),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if *s.offset(2 as isize) as i32 == 'r' as i32 && *s.offset(3 as isize) as i32 == 'o' as i32\n                                && *s.offset(4 as isize) as i32 == 'm' as i32 && *s.offset(5 as isize) as i32 == ' ' as i32 {\n                            AddMatch(\n                                id.wrapping_add(37u64.wrapping_mul(n)),\n                                l.wrapping_add(6),\n                                l,\n                                matches,\n                            );\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:380:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m380\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else if *s.offset(2 as isize) as i32 == 'r' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m381\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if *s.offset(3 as isize) as i32 == 'o' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m382\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                && *s.offset(4 as isize) as i32 == 'm' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m383\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                && *s.offset(5 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m391\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m392\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m380\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(2 as isize) as i32 == 'r' as i32 && *s.offset(3 as isize) as i32 == 'o' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m381\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && *s.offset(4 as isize) as i32 == 'm' as i32 && *s.offset(5 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m382\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m383\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 id.wrapping_add(37u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m384\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l.wrapping_add(6),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m385\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m386\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m387\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":16314,"byte_end":16785,"line_start":403,"line_end":412,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'n' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":76},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(45u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(4),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":16314,"byte_end":16785,"line_start":403,"line_end":412,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'n' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":76},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(45u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(4),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if *s.offset(2 as isize) as i32 == 'n' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\n                            AddMatch(\n                                id.wrapping_add(45u64.wrapping_mul(n)),\n                                l.wrapping_add(4),\n                                l,\n                                matches,\n                            );\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:403:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else if *s.offset(2 as isize) as i32 == 'n' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m404\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m406\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                    id.wrapping_add(45u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m411\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(2 as isize) as i32 == 'n' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m404\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 id.wrapping_add(45u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m406\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l.wrapping_add(4),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m407\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m408\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m409\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m410\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":18086,"byte_end":18707,"line_start":436,"line_end":447,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else if *s.offset(3 as isize) as i32 == 'a' as i32 {","highlight_start":36,"highlight_end":83},{"text":"                                if *s.offset(4 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":78},{"text":"                                    && *s.offset(5 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":82},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id.wrapping_add(29u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":80},{"text":"                                        l.wrapping_add(6),","highlight_start":1,"highlight_end":59},{"text":"                                        l,","highlight_start":1,"highlight_end":43},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":18086,"byte_end":18707,"line_start":436,"line_end":447,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else if *s.offset(3 as isize) as i32 == 'a' as i32 {","highlight_start":36,"highlight_end":83},{"text":"                                if *s.offset(4 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":78},{"text":"                                    && *s.offset(5 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":82},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id.wrapping_add(29u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":80},{"text":"                                        l.wrapping_add(6),","highlight_start":1,"highlight_end":59},{"text":"                                        l,","highlight_start":1,"highlight_end":43},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"if *s.offset(3 as isize) as i32 == 'a' as i32 && *s.offset(4 as isize) as i32 == 't' as i32 && *s.offset(5 as isize) as i32 == ' ' as i32 {\n                                AddMatch(\n                                    id.wrapping_add(29u64.wrapping_mul(n)),\n                                    l.wrapping_add(6),\n                                    l,\n                                    matches,\n                                );\n                            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:436:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m436\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   } else if *s.offset(3 as isize) as i32 == 'a' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m______________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m437\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       if *s.offset(4 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && *s.offset(5 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m446\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m447\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_______________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m436\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                            } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(3 as isize) as i32 == 'a' as i32 && *s.offset(4 as isize) as i32 == 't' as i32 && *s.offset(5 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m437\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     id.wrapping_add(29u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l.wrapping_add(6),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m440\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m441\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m442\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m443\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":18739,"byte_end":19210,"line_start":448,"line_end":457,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'o' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":76},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(17u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(4),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":18739,"byte_end":19210,"line_start":448,"line_end":457,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else if *s.offset(2 as isize) as i32 == 'o' as i32 {","highlight_start":32,"highlight_end":79},{"text":"                            if *s.offset(3 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":76},{"text":"                                AddMatch(","highlight_start":1,"highlight_end":42},{"text":"                                    id.wrapping_add(17u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":76},{"text":"                                    l.wrapping_add(4),","highlight_start":1,"highlight_end":55},{"text":"                                    l,","highlight_start":1,"highlight_end":39},{"text":"                                    matches,","highlight_start":1,"highlight_end":45},{"text":"                                );","highlight_start":1,"highlight_end":35},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if *s.offset(2 as isize) as i32 == 'o' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\n                            AddMatch(\n                                id.wrapping_add(17u64.wrapping_mul(n)),\n                                l.wrapping_add(4),\n                                l,\n                                matches,\n                            );\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:448:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m448\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else if *s.offset(2 as isize) as i32 == 'o' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m449\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m451\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                    id.wrapping_add(17u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m456\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m457\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m448\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(2 as isize) as i32 == 'o' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m449\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 id.wrapping_add(17u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m451\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l.wrapping_add(4),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m452\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m453\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m454\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m455\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":19238,"byte_end":19919,"line_start":458,"line_end":471,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 'w' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == 'i' as i32","highlight_start":1,"highlight_end":70},{"text":"                            && *s.offset(3 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":74},{"text":"                            && *s.offset(4 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":74},{"text":"                            && *s.offset(5 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":74},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(35u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":72},{"text":"                                l.wrapping_add(6),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":19238,"byte_end":19919,"line_start":458,"line_end":471,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 'w' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == 'i' as i32","highlight_start":1,"highlight_end":70},{"text":"                            && *s.offset(3 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":74},{"text":"                            && *s.offset(4 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":74},{"text":"                            && *s.offset(5 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":74},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(35u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":72},{"text":"                                l.wrapping_add(6),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if *s.offset(1 as isize) as i32 == 'w' as i32 && *s.offset(2 as isize) as i32 == 'i' as i32\n                            && *s.offset(3 as isize) as i32 == 't' as i32\n                            && *s.offset(4 as isize) as i32 == 'h' as i32 && *s.offset(5 as isize) as i32 == ' ' as i32 {\n                        AddMatch(\n                            id.wrapping_add(35u64.wrapping_mul(n)),\n                            l.wrapping_add(6),\n                            l,\n                            matches,\n                        );\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:458:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    } else if *s.offset(1 as isize) as i32 == 'w' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if *s.offset(2 as isize) as i32 == 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m460\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            && *s.offset(3 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            && *s.offset(4 as isize) as i32 == 'h' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m470\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(1 as isize) as i32 == 'w' as i32 && *s.offset(2 as isize) as i32 == 'i' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             && *s.offset(3 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m460\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             && *s.offset(4 as isize) as i32 == 'h' as i32 && *s.offset(5 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m462\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             id.wrapping_add(35u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m463\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l.wrapping_add(6),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m465\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m466\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m467\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":21859,"byte_end":22480,"line_start":513,"line_end":524,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else if *s.offset(4 as isize) as i32 == 'i' as i32 {","highlight_start":36,"highlight_end":83},{"text":"                                if *s.offset(5 as isize) as i32 == 's' as i32","highlight_start":1,"highlight_end":78},{"text":"                                    && *s.offset(6 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":82},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id.wrapping_add(75u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":80},{"text":"                                        l.wrapping_add(7),","highlight_start":1,"highlight_end":59},{"text":"                                        l,","highlight_start":1,"highlight_end":43},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":21859,"byte_end":22480,"line_start":513,"line_end":524,"column_start":36,"column_end":30,"is_primary":true,"text":[{"text":"                            } else if *s.offset(4 as isize) as i32 == 'i' as i32 {","highlight_start":36,"highlight_end":83},{"text":"                                if *s.offset(5 as isize) as i32 == 's' as i32","highlight_start":1,"highlight_end":78},{"text":"                                    && *s.offset(6 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":82},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id.wrapping_add(75u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":80},{"text":"                                        l.wrapping_add(7),","highlight_start":1,"highlight_end":59},{"text":"                                        l,","highlight_start":1,"highlight_end":43},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"if *s.offset(4 as isize) as i32 == 'i' as i32 && *s.offset(5 as isize) as i32 == 's' as i32 && *s.offset(6 as isize) as i32 == ' ' as i32 {\n                                AddMatch(\n                                    id.wrapping_add(75u64.wrapping_mul(n)),\n                                    l.wrapping_add(7),\n                                    l,\n                                    matches,\n                                );\n                            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:513:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   } else if *s.offset(4 as isize) as i32 == 'i' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m______________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       if *s.offset(5 as isize) as i32 == 's' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && *s.offset(6 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m523\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m524\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_______________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                            } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(4 as isize) as i32 == 'i' as i32 && *s.offset(5 as isize) as i32 == 's' as i32 && *s.offset(6 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     id.wrapping_add(75u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l.wrapping_add(7),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m520\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":27139,"byte_end":27672,"line_start":631,"line_end":642,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 's' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":70},{"text":"                            && *s.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":74},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(95u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":72},{"text":"                                l.wrapping_add(4),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":27139,"byte_end":27672,"line_start":631,"line_end":642,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 's' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":70},{"text":"                            && *s.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":74},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(95u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":72},{"text":"                                l.wrapping_add(4),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if *s.offset(1 as isize) as i32 == 's' as i32 && *s.offset(2 as isize) as i32 == 't' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\n                        AddMatch(\n                            id.wrapping_add(95u64.wrapping_mul(n)),\n                            l.wrapping_add(4),\n                            l,\n                            matches,\n                        );\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:631:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    } else if *s.offset(1 as isize) as i32 == 's' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m632\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if *s.offset(2 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m633\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            && *s.offset(3 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m634\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m641\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m642\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(1 as isize) as i32 == 's' as i32 && *s.offset(2 as isize) as i32 == 't' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m632\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m633\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             id.wrapping_add(95u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m634\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l.wrapping_add(4),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m635\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m636\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m637\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m638\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":28868,"byte_end":29402,"line_start":667,"line_end":678,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 'z' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":70},{"text":"                            && *s.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":74},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(100u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":73},{"text":"                                l.wrapping_add(4),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":28868,"byte_end":29402,"line_start":667,"line_end":678,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 'z' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":70},{"text":"                            && *s.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":74},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(100u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":73},{"text":"                                l.wrapping_add(4),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if *s.offset(1 as isize) as i32 == 'z' as i32 && *s.offset(2 as isize) as i32 == 'e' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\n                        AddMatch(\n                            id.wrapping_add(100u64.wrapping_mul(n)),\n                            l.wrapping_add(4),\n                            l,\n                            matches,\n                        );\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:667:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m667\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    } else if *s.offset(1 as isize) as i32 == 'z' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m668\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if *s.offset(2 as isize) as i32 == 'e' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m669\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            && *s.offset(3 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m670\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m677\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m678\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m667\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(1 as isize) as i32 == 'z' as i32 && *s.offset(2 as isize) as i32 == 'e' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m668\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m669\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             id.wrapping_add(100u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m670\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l.wrapping_add(4),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m671\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m672\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m673\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m674\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":30107,"byte_end":30542,"line_start":692,"line_end":701,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 'y' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":72},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(61u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":72},{"text":"                                l.wrapping_add(3),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":30107,"byte_end":30542,"line_start":692,"line_end":701,"column_start":28,"column_end":22,"is_primary":true,"text":[{"text":"                    } else if *s.offset(1 as isize) as i32 == 'y' as i32 {","highlight_start":28,"highlight_end":75},{"text":"                        if *s.offset(2 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":72},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id.wrapping_add(61u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":72},{"text":"                                l.wrapping_add(3),","highlight_start":1,"highlight_end":51},{"text":"                                l,","highlight_start":1,"highlight_end":35},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"if *s.offset(1 as isize) as i32 == 'y' as i32 && *s.offset(2 as isize) as i32 == ' ' as i32 {\n                        AddMatch(\n                            id.wrapping_add(61u64.wrapping_mul(n)),\n                            l.wrapping_add(3),\n                            l,\n                            matches,\n                        );\n                    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:692:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m692\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    } else if *s.offset(1 as isize) as i32 == 'y' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m____________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m693\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if *s.offset(2 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m694\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m695\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                id.wrapping_add(61u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m700\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m701\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m692\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(1 as isize) as i32 == 'y' as i32 && *s.offset(2 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m693\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m694\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             id.wrapping_add(61u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m695\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l.wrapping_add(3),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m696\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m697\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m698\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m699\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":30566,"byte_end":31126,"line_start":702,"line_end":714,"column_start":24,"column_end":18,"is_primary":true,"text":[{"text":"                } else if *s.offset(0 as isize) as i32 == 'o' as i32 {","highlight_start":24,"highlight_end":71},{"text":"                    if *s.offset(1 as isize) as i32 == 'u' as i32","highlight_start":1,"highlight_end":66},{"text":"                        && *s.offset(2 as isize) as i32 == 's' as i32","highlight_start":1,"highlight_end":70},{"text":"                        && *s.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":70},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        AddMatch(","highlight_start":1,"highlight_end":34},{"text":"                            id.wrapping_add(106u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":69},{"text":"                            l.wrapping_add(4),","highlight_start":1,"highlight_end":47},{"text":"                            l,","highlight_start":1,"highlight_end":31},{"text":"                            matches,","highlight_start":1,"highlight_end":37},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":30566,"byte_end":31126,"line_start":702,"line_end":714,"column_start":24,"column_end":18,"is_primary":true,"text":[{"text":"                } else if *s.offset(0 as isize) as i32 == 'o' as i32 {","highlight_start":24,"highlight_end":71},{"text":"                    if *s.offset(1 as isize) as i32 == 'u' as i32","highlight_start":1,"highlight_end":66},{"text":"                        && *s.offset(2 as isize) as i32 == 's' as i32","highlight_start":1,"highlight_end":70},{"text":"                        && *s.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":70},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        AddMatch(","highlight_start":1,"highlight_end":34},{"text":"                            id.wrapping_add(106u64.wrapping_mul(n)),","highlight_start":1,"highlight_end":69},{"text":"                            l.wrapping_add(4),","highlight_start":1,"highlight_end":47},{"text":"                            l,","highlight_start":1,"highlight_end":31},{"text":"                            matches,","highlight_start":1,"highlight_end":37},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":"if *s.offset(0 as isize) as i32 == 'o' as i32 && *s.offset(1 as isize) as i32 == 'u' as i32\n                        && *s.offset(2 as isize) as i32 == 's' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\n                    AddMatch(\n                        id.wrapping_add(106u64.wrapping_mul(n)),\n                        l.wrapping_add(4),\n                        l,\n                        matches,\n                    );\n                }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:702:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m702\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                } else if *s.offset(0 as isize) as i32 == 'o' as i32 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m703\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    if *s.offset(1 as isize) as i32 == 'u' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m704\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        && *s.offset(2 as isize) as i32 == 's' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m705\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        && *s.offset(3 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m713\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m714\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m702\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                } else \u001b[0m\u001b[0m\u001b[38;5;10mif *s.offset(0 as isize) as i32 == 'o' as i32 && *s.offset(1 as isize) as i32 == 'u' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m703\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         && *s.offset(2 as isize) as i32 == 's' as i32 && *s.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m704\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m705\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         id.wrapping_add(106u64.wrapping_mul(n)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m706\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         l.wrapping_add(4),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m707\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         l,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m708\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m709\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m710\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":47214,"byte_end":50073,"line_start":1073,"line_end":1131,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if max_length >= 6 {","highlight_start":9,"highlight_end":29},{"text":"            if *data.offset(1 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":61},{"text":"                && (*data.offset(0 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":66},{"text":"                    || *data.offset(0 as isize) as i32 == 's' as i32","highlight_start":1,"highlight_end":69},{"text":"                    || *data.offset(0 as isize) as i32 == ',' as i32)","highlight_start":1,"highlight_end":70},{"text":"                || *data.offset(0 as isize) as i32 == 0xc2","highlight_start":1,"highlight_end":59},{"text":"                    && *data.offset(1 as isize) as i32 == 0xa0","highlight_start":1,"highlight_end":63},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                let mut offset_1 = *((*dictionary).buckets)","highlight_start":1,"highlight_end":60},{"text":"                    .offset(Hash(&*data.offset(2 as isize)) as isize)","highlight_start":1,"highlight_end":70},{"text":"                    as u64;","highlight_start":1,"highlight_end":28},{"text":"                let mut end_1 = (offset_1 == 0) as i32;","highlight_start":1,"highlight_end":56},{"text":"                while end_1 == 0 {","highlight_start":1,"highlight_end":35},{"text":"                    let fresh2 = offset_1;","highlight_start":1,"highlight_end":43},{"text":"                    offset_1 = offset_1.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    let mut w_1 = *((*dictionary).dict_words).offset(fresh2 as isize);","highlight_start":1,"highlight_end":87},{"text":"                    let l_1 = (w_1.len as i32 & 0x1fi32) as u64;","highlight_start":1,"highlight_end":65},{"text":"                    let n_1 = 1 << (*(*dictionary).words).size_bits_by_length[l_1 as usize] as i32;","highlight_start":1,"highlight_end":100},{"text":"                    let id_1 = w_1.idx as u64;","highlight_start":1,"highlight_end":47},{"text":"                    end_1 = (w_1.len as i32 & 0x80 != 0) as i32;","highlight_start":1,"highlight_end":65},{"text":"                    w_1.len = l_1 as u8;","highlight_start":1,"highlight_end":41},{"text":"                    if w_1.transform as i32 == 0","highlight_start":1,"highlight_end":49},{"text":"                        && IsMatch(","highlight_start":1,"highlight_end":36},{"text":"                            (*dictionary).words,","highlight_start":1,"highlight_end":49},{"text":"                            w_1,","highlight_start":1,"highlight_end":33},{"text":"                            &*data.offset(2 as isize),","highlight_start":1,"highlight_end":55},{"text":"                            max_length.wrapping_sub(2),","highlight_start":1,"highlight_end":56},{"text":"                        ) != 0","highlight_start":1,"highlight_end":31},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        if *data.offset(0 as isize) as i32 == 0xc2 {","highlight_start":1,"highlight_end":69},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id_1.wrapping_add(102u64.wrapping_mul(n_1)),","highlight_start":1,"highlight_end":77},{"text":"                                l_1.wrapping_add(2),","highlight_start":1,"highlight_end":53},{"text":"                                l_1,","highlight_start":1,"highlight_end":37},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                            has_found_match = 1;","highlight_start":1,"highlight_end":49},{"text":"                        } else if l_1.wrapping_add(2) < max_length","highlight_start":1,"highlight_end":67},{"text":"                            && *data.offset(l_1.wrapping_add(2) as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":95},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            let mut t = (if *data.offset(0 as isize) as i32 == 'e' as i32 {","highlight_start":1,"highlight_end":92},{"text":"                                18","highlight_start":1,"highlight_end":35},{"text":"                            } else if *data.offset(0 as isize) as i32 == 's' as i32 {","highlight_start":1,"highlight_end":86},{"text":"                                7","highlight_start":1,"highlight_end":34},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                13","highlight_start":1,"highlight_end":35},{"text":"                            }) as u64;","highlight_start":1,"highlight_end":39},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id_1.wrapping_add(t.wrapping_mul(n_1)),","highlight_start":1,"highlight_end":72},{"text":"                                l_1.wrapping_add(3),","highlight_start":1,"highlight_end":53},{"text":"                                l_1,","highlight_start":1,"highlight_end":37},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                            has_found_match = 1;","highlight_start":1,"highlight_end":49},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":47214,"byte_end":50073,"line_start":1073,"line_end":1131,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if max_length >= 6 {","highlight_start":9,"highlight_end":29},{"text":"            if *data.offset(1 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":61},{"text":"                && (*data.offset(0 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":66},{"text":"                    || *data.offset(0 as isize) as i32 == 's' as i32","highlight_start":1,"highlight_end":69},{"text":"                    || *data.offset(0 as isize) as i32 == ',' as i32)","highlight_start":1,"highlight_end":70},{"text":"                || *data.offset(0 as isize) as i32 == 0xc2","highlight_start":1,"highlight_end":59},{"text":"                    && *data.offset(1 as isize) as i32 == 0xa0","highlight_start":1,"highlight_end":63},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                let mut offset_1 = *((*dictionary).buckets)","highlight_start":1,"highlight_end":60},{"text":"                    .offset(Hash(&*data.offset(2 as isize)) as isize)","highlight_start":1,"highlight_end":70},{"text":"                    as u64;","highlight_start":1,"highlight_end":28},{"text":"                let mut end_1 = (offset_1 == 0) as i32;","highlight_start":1,"highlight_end":56},{"text":"                while end_1 == 0 {","highlight_start":1,"highlight_end":35},{"text":"                    let fresh2 = offset_1;","highlight_start":1,"highlight_end":43},{"text":"                    offset_1 = offset_1.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    let mut w_1 = *((*dictionary).dict_words).offset(fresh2 as isize);","highlight_start":1,"highlight_end":87},{"text":"                    let l_1 = (w_1.len as i32 & 0x1fi32) as u64;","highlight_start":1,"highlight_end":65},{"text":"                    let n_1 = 1 << (*(*dictionary).words).size_bits_by_length[l_1 as usize] as i32;","highlight_start":1,"highlight_end":100},{"text":"                    let id_1 = w_1.idx as u64;","highlight_start":1,"highlight_end":47},{"text":"                    end_1 = (w_1.len as i32 & 0x80 != 0) as i32;","highlight_start":1,"highlight_end":65},{"text":"                    w_1.len = l_1 as u8;","highlight_start":1,"highlight_end":41},{"text":"                    if w_1.transform as i32 == 0","highlight_start":1,"highlight_end":49},{"text":"                        && IsMatch(","highlight_start":1,"highlight_end":36},{"text":"                            (*dictionary).words,","highlight_start":1,"highlight_end":49},{"text":"                            w_1,","highlight_start":1,"highlight_end":33},{"text":"                            &*data.offset(2 as isize),","highlight_start":1,"highlight_end":55},{"text":"                            max_length.wrapping_sub(2),","highlight_start":1,"highlight_end":56},{"text":"                        ) != 0","highlight_start":1,"highlight_end":31},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        if *data.offset(0 as isize) as i32 == 0xc2 {","highlight_start":1,"highlight_end":69},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id_1.wrapping_add(102u64.wrapping_mul(n_1)),","highlight_start":1,"highlight_end":77},{"text":"                                l_1.wrapping_add(2),","highlight_start":1,"highlight_end":53},{"text":"                                l_1,","highlight_start":1,"highlight_end":37},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                            has_found_match = 1;","highlight_start":1,"highlight_end":49},{"text":"                        } else if l_1.wrapping_add(2) < max_length","highlight_start":1,"highlight_end":67},{"text":"                            && *data.offset(l_1.wrapping_add(2) as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":95},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            let mut t = (if *data.offset(0 as isize) as i32 == 'e' as i32 {","highlight_start":1,"highlight_end":92},{"text":"                                18","highlight_start":1,"highlight_end":35},{"text":"                            } else if *data.offset(0 as isize) as i32 == 's' as i32 {","highlight_start":1,"highlight_end":86},{"text":"                                7","highlight_start":1,"highlight_end":34},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                13","highlight_start":1,"highlight_end":35},{"text":"                            }) as u64;","highlight_start":1,"highlight_end":39},{"text":"                            AddMatch(","highlight_start":1,"highlight_end":38},{"text":"                                id_1.wrapping_add(t.wrapping_mul(n_1)),","highlight_start":1,"highlight_end":72},{"text":"                                l_1.wrapping_add(3),","highlight_start":1,"highlight_end":53},{"text":"                                l_1,","highlight_start":1,"highlight_end":37},{"text":"                                matches,","highlight_start":1,"highlight_end":41},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                            has_found_match = 1;","highlight_start":1,"highlight_end":49},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if max_length >= 6 && (*data.offset(1 as isize) as i32 == ' ' as i32\n                && (*data.offset(0 as isize) as i32 == 'e' as i32\n                    || *data.offset(0 as isize) as i32 == 's' as i32\n                    || *data.offset(0 as isize) as i32 == ',' as i32) || *data.offset(0 as isize) as i32 == 0xc2\n                    && *data.offset(1 as isize) as i32 == 0xa0) {\n            let mut offset_1 = *((*dictionary).buckets)\n                .offset(Hash(&*data.offset(2 as isize)) as isize)\n                as u64;\n            let mut end_1 = (offset_1 == 0) as i32;\n            while end_1 == 0 {\n                let fresh2 = offset_1;\n                offset_1 = offset_1.wrapping_add(1);\n                let mut w_1 = *((*dictionary).dict_words).offset(fresh2 as isize);\n                let l_1 = (w_1.len as i32 & 0x1fi32) as u64;\n                let n_1 = 1 << (*(*dictionary).words).size_bits_by_length[l_1 as usize] as i32;\n                let id_1 = w_1.idx as u64;\n                end_1 = (w_1.len as i32 & 0x80 != 0) as i32;\n                w_1.len = l_1 as u8;\n                if w_1.transform as i32 == 0\n                    && IsMatch(\n                        (*dictionary).words,\n                        w_1,\n                        &*data.offset(2 as isize),\n                        max_length.wrapping_sub(2),\n                    ) != 0\n                {\n                    if *data.offset(0 as isize) as i32 == 0xc2 {\n                        AddMatch(\n                            id_1.wrapping_add(102u64.wrapping_mul(n_1)),\n                            l_1.wrapping_add(2),\n                            l_1,\n                            matches,\n                        );\n                        has_found_match = 1;\n                    } else if l_1.wrapping_add(2) < max_length\n                        && *data.offset(l_1.wrapping_add(2) as isize) as i32 == ' ' as i32\n                    {\n                        let mut t = (if *data.offset(0 as isize) as i32 == 'e' as i32 {\n                            18\n                        } else if *data.offset(0 as isize) as i32 == 's' as i32 {\n                            7\n                        } else {\n                            13\n                        }) as u64;\n                        AddMatch(\n                            id_1.wrapping_add(t.wrapping_mul(n_1)),\n                            l_1.wrapping_add(3),\n                            l_1,\n                            matches,\n                        );\n                        has_found_match = 1;\n                    }\n                }\n            }\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:1073:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1073\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if max_length >= 6 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1074\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if *data.offset(1 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1075\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && (*data.offset(0 as isize) as i32 == 'e' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1076\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    || *data.offset(0 as isize) as i32 == 's' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1130\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1131\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1073\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif max_length >= 6 && (*data.offset(1 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1074\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && (*data.offset(0 as isize) as i32 == 'e' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1075\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || *data.offset(0 as isize) as i32 == 's' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1076\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     || *data.offset(0 as isize) as i32 == ',' as i32) || *data.offset(0 as isize) as i32 == 0xc2\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1077\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && *data.offset(1 as isize) as i32 == 0xa0) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1078\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut offset_1 = *((*dictionary).buckets)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1079\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 .offset(Hash(&*data.offset(2 as isize)) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1080\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1081\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut end_1 = (offset_1 == 0) as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1082\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             while end_1 == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1083\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let fresh2 = offset_1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1084\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 offset_1 = offset_1.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1085\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut w_1 = *((*dictionary).dict_words).offset(fresh2 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1086\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let l_1 = (w_1.len as i32 & 0x1fi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1087\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let n_1 = 1 << (*(*dictionary).words).size_bits_by_length[l_1 as usize] as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1088\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let id_1 = w_1.idx as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1089\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 end_1 = (w_1.len as i32 & 0x80 != 0) as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1090\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 w_1.len = l_1 as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1091\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if w_1.transform as i32 == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1092\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && IsMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1093\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*dictionary).words,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1094\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         w_1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1095\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(2 as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1096\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         max_length.wrapping_sub(2),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1097\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1098\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1099\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if *data.offset(0 as isize) as i32 == 0xc2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             id_1.wrapping_add(102u64.wrapping_mul(n_1)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l_1.wrapping_add(2),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l_1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         has_found_match = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     } else if l_1.wrapping_add(2) < max_length\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         && *data.offset(l_1.wrapping_add(2) as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let mut t = (if *data.offset(0 as isize) as i32 == 'e' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             18\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else if *data.offset(0 as isize) as i32 == 's' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             7\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             13\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1118\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             id_1.wrapping_add(t.wrapping_mul(n_1)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l_1.wrapping_add(3),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             l_1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1122\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1123\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         has_found_match = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1124\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1126\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":50082,"byte_end":54522,"line_start":1132,"line_end":1214,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if max_length >= 9 {","highlight_start":9,"highlight_end":29},{"text":"            if *data.offset(0 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":61},{"text":"                && *data.offset(1 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":65},{"text":"                && *data.offset(2 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":65},{"text":"                && *data.offset(3 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":65},{"text":"                && *data.offset(4 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":65},{"text":"                || *data.offset(0 as isize) as i32 == '.' as i32","highlight_start":1,"highlight_end":65},{"text":"                    && *data.offset(1 as isize) as i32 == 'c' as i32","highlight_start":1,"highlight_end":69},{"text":"                    && *data.offset(2 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":69},{"text":"                    && *data.offset(3 as isize) as i32 == 'm' as i32","highlight_start":1,"highlight_end":69},{"text":"                    && *data.offset(4 as isize) as i32 == '/' as i32","highlight_start":1,"highlight_end":69},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                let mut offset_2 = *((*dictionary).buckets)","highlight_start":1,"highlight_end":60},{"text":"                    .offset(Hash(&*data.offset(5 as isize)) as isize)","highlight_start":1,"highlight_end":70},{"text":"                    as u64;","highlight_start":1,"highlight_end":28},{"text":"                let mut end_2 = (offset_2 == 0) as i32;","highlight_start":1,"highlight_end":56},{"text":"                while end_2 == 0 {","highlight_start":1,"highlight_end":35},{"text":"                    let fresh3 = offset_2;","highlight_start":1,"highlight_end":43},{"text":"                    offset_2 = offset_2.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    let mut w_2 = *((*dictionary).dict_words).offset(fresh3 as isize);","highlight_start":1,"highlight_end":87},{"text":"                    let l_2 = (w_2.len as i32 & 0x1fi32) as u64;","highlight_start":1,"highlight_end":65},{"text":"                    let n_2 = 1 << (*(*dictionary).words).size_bits_by_length[l_2 as usize] as i32;","highlight_start":1,"highlight_end":100},{"text":"                    let id_2 = w_2.idx as u64;","highlight_start":1,"highlight_end":47},{"text":"                    end_2 = (w_2.len as i32 & 0x80 != 0) as i32;","highlight_start":1,"highlight_end":65},{"text":"                    w_2.len = l_2 as u8;","highlight_start":1,"highlight_end":41},{"text":"                    if w_2.transform as i32 == 0","highlight_start":1,"highlight_end":49},{"text":"                        && IsMatch(","highlight_start":1,"highlight_end":36},{"text":"                            (*dictionary).words,","highlight_start":1,"highlight_end":49},{"text":"                            w_2,","highlight_start":1,"highlight_end":33},{"text":"                            &*data.offset(5 as isize),","highlight_start":1,"highlight_end":55},{"text":"                            max_length.wrapping_sub(5),","highlight_start":1,"highlight_end":56},{"text":"                        ) != 0","highlight_start":1,"highlight_end":31},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        AddMatch(","highlight_start":1,"highlight_end":34},{"text":"                            id_2.wrapping_add(","highlight_start":1,"highlight_end":47},{"text":"                                ((if *data.offset(0 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":85},{"text":"                                    41i32","highlight_start":1,"highlight_end":42},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    72","highlight_start":1,"highlight_end":39},{"text":"                                }) as u64)","highlight_start":1,"highlight_end":43},{"text":"                                    .wrapping_mul(n_2),","highlight_start":1,"highlight_end":56},{"text":"                            ),","highlight_start":1,"highlight_end":31},{"text":"                            l_2.wrapping_add(5),","highlight_start":1,"highlight_end":49},{"text":"                            l_2,","highlight_start":1,"highlight_end":33},{"text":"                            matches,","highlight_start":1,"highlight_end":37},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        has_found_match = 1;","highlight_start":1,"highlight_end":45},{"text":"                        if l_2.wrapping_add(5) < max_length {","highlight_start":1,"highlight_end":62},{"text":"                            let mut s_3: *const u8 =","highlight_start":1,"highlight_end":53},{"text":"                                &*data.offset(l_2.wrapping_add(5) as isize) as *const u8;","highlight_start":1,"highlight_end":90},{"text":"                            if *data.offset(0 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":79},{"text":"                                if l_2.wrapping_add(8) < max_length","highlight_start":1,"highlight_end":68},{"text":"                                    && *s_3.offset(0 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(1 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(2 as isize) as i32 == 'f' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id_2.wrapping_add(62u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":84},{"text":"                                        l_2.wrapping_add(9),","highlight_start":1,"highlight_end":61},{"text":"                                        l_2,","highlight_start":1,"highlight_end":45},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    if l_2.wrapping_add(12) < max_length","highlight_start":1,"highlight_end":73},{"text":"                                        && *s_3.offset(4 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(5 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(6 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(7 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":88},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        AddMatch(","highlight_start":1,"highlight_end":50},{"text":"                                            id_2.wrapping_add(73u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":88},{"text":"                                            l_2.wrapping_add(13),","highlight_start":1,"highlight_end":66},{"text":"                                            l_2,","highlight_start":1,"highlight_end":49},{"text":"                                            matches,","highlight_start":1,"highlight_end":53},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":50082,"byte_end":54522,"line_start":1132,"line_end":1214,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if max_length >= 9 {","highlight_start":9,"highlight_end":29},{"text":"            if *data.offset(0 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":61},{"text":"                && *data.offset(1 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":65},{"text":"                && *data.offset(2 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":65},{"text":"                && *data.offset(3 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":65},{"text":"                && *data.offset(4 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":65},{"text":"                || *data.offset(0 as isize) as i32 == '.' as i32","highlight_start":1,"highlight_end":65},{"text":"                    && *data.offset(1 as isize) as i32 == 'c' as i32","highlight_start":1,"highlight_end":69},{"text":"                    && *data.offset(2 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":69},{"text":"                    && *data.offset(3 as isize) as i32 == 'm' as i32","highlight_start":1,"highlight_end":69},{"text":"                    && *data.offset(4 as isize) as i32 == '/' as i32","highlight_start":1,"highlight_end":69},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                let mut offset_2 = *((*dictionary).buckets)","highlight_start":1,"highlight_end":60},{"text":"                    .offset(Hash(&*data.offset(5 as isize)) as isize)","highlight_start":1,"highlight_end":70},{"text":"                    as u64;","highlight_start":1,"highlight_end":28},{"text":"                let mut end_2 = (offset_2 == 0) as i32;","highlight_start":1,"highlight_end":56},{"text":"                while end_2 == 0 {","highlight_start":1,"highlight_end":35},{"text":"                    let fresh3 = offset_2;","highlight_start":1,"highlight_end":43},{"text":"                    offset_2 = offset_2.wrapping_add(1);","highlight_start":1,"highlight_end":57},{"text":"                    let mut w_2 = *((*dictionary).dict_words).offset(fresh3 as isize);","highlight_start":1,"highlight_end":87},{"text":"                    let l_2 = (w_2.len as i32 & 0x1fi32) as u64;","highlight_start":1,"highlight_end":65},{"text":"                    let n_2 = 1 << (*(*dictionary).words).size_bits_by_length[l_2 as usize] as i32;","highlight_start":1,"highlight_end":100},{"text":"                    let id_2 = w_2.idx as u64;","highlight_start":1,"highlight_end":47},{"text":"                    end_2 = (w_2.len as i32 & 0x80 != 0) as i32;","highlight_start":1,"highlight_end":65},{"text":"                    w_2.len = l_2 as u8;","highlight_start":1,"highlight_end":41},{"text":"                    if w_2.transform as i32 == 0","highlight_start":1,"highlight_end":49},{"text":"                        && IsMatch(","highlight_start":1,"highlight_end":36},{"text":"                            (*dictionary).words,","highlight_start":1,"highlight_end":49},{"text":"                            w_2,","highlight_start":1,"highlight_end":33},{"text":"                            &*data.offset(5 as isize),","highlight_start":1,"highlight_end":55},{"text":"                            max_length.wrapping_sub(5),","highlight_start":1,"highlight_end":56},{"text":"                        ) != 0","highlight_start":1,"highlight_end":31},{"text":"                    {","highlight_start":1,"highlight_end":22},{"text":"                        AddMatch(","highlight_start":1,"highlight_end":34},{"text":"                            id_2.wrapping_add(","highlight_start":1,"highlight_end":47},{"text":"                                ((if *data.offset(0 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":85},{"text":"                                    41i32","highlight_start":1,"highlight_end":42},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    72","highlight_start":1,"highlight_end":39},{"text":"                                }) as u64)","highlight_start":1,"highlight_end":43},{"text":"                                    .wrapping_mul(n_2),","highlight_start":1,"highlight_end":56},{"text":"                            ),","highlight_start":1,"highlight_end":31},{"text":"                            l_2.wrapping_add(5),","highlight_start":1,"highlight_end":49},{"text":"                            l_2,","highlight_start":1,"highlight_end":33},{"text":"                            matches,","highlight_start":1,"highlight_end":37},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        has_found_match = 1;","highlight_start":1,"highlight_end":45},{"text":"                        if l_2.wrapping_add(5) < max_length {","highlight_start":1,"highlight_end":62},{"text":"                            let mut s_3: *const u8 =","highlight_start":1,"highlight_end":53},{"text":"                                &*data.offset(l_2.wrapping_add(5) as isize) as *const u8;","highlight_start":1,"highlight_end":90},{"text":"                            if *data.offset(0 as isize) as i32 == ' ' as i32 {","highlight_start":1,"highlight_end":79},{"text":"                                if l_2.wrapping_add(8) < max_length","highlight_start":1,"highlight_end":68},{"text":"                                    && *s_3.offset(0 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(1 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(2 as isize) as i32 == 'f' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id_2.wrapping_add(62u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":84},{"text":"                                        l_2.wrapping_add(9),","highlight_start":1,"highlight_end":61},{"text":"                                        l_2,","highlight_start":1,"highlight_end":45},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    if l_2.wrapping_add(12) < max_length","highlight_start":1,"highlight_end":73},{"text":"                                        && *s_3.offset(4 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(5 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(6 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(7 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":88},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        AddMatch(","highlight_start":1,"highlight_end":50},{"text":"                                            id_2.wrapping_add(73u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":88},{"text":"                                            l_2.wrapping_add(13),","highlight_start":1,"highlight_end":66},{"text":"                                            l_2,","highlight_start":1,"highlight_end":49},{"text":"                                            matches,","highlight_start":1,"highlight_end":53},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if max_length >= 9 && (*data.offset(0 as isize) as i32 == ' ' as i32\n                && *data.offset(1 as isize) as i32 == 't' as i32\n                && *data.offset(2 as isize) as i32 == 'h' as i32\n                && *data.offset(3 as isize) as i32 == 'e' as i32\n                && *data.offset(4 as isize) as i32 == ' ' as i32 || *data.offset(0 as isize) as i32 == '.' as i32\n                    && *data.offset(1 as isize) as i32 == 'c' as i32\n                    && *data.offset(2 as isize) as i32 == 'o' as i32\n                    && *data.offset(3 as isize) as i32 == 'm' as i32\n                    && *data.offset(4 as isize) as i32 == '/' as i32) {\n            let mut offset_2 = *((*dictionary).buckets)\n                .offset(Hash(&*data.offset(5 as isize)) as isize)\n                as u64;\n            let mut end_2 = (offset_2 == 0) as i32;\n            while end_2 == 0 {\n                let fresh3 = offset_2;\n                offset_2 = offset_2.wrapping_add(1);\n                let mut w_2 = *((*dictionary).dict_words).offset(fresh3 as isize);\n                let l_2 = (w_2.len as i32 & 0x1fi32) as u64;\n                let n_2 = 1 << (*(*dictionary).words).size_bits_by_length[l_2 as usize] as i32;\n                let id_2 = w_2.idx as u64;\n                end_2 = (w_2.len as i32 & 0x80 != 0) as i32;\n                w_2.len = l_2 as u8;\n                if w_2.transform as i32 == 0\n                    && IsMatch(\n                        (*dictionary).words,\n                        w_2,\n                        &*data.offset(5 as isize),\n                        max_length.wrapping_sub(5),\n                    ) != 0\n                {\n                    AddMatch(\n                        id_2.wrapping_add(\n                            ((if *data.offset(0 as isize) as i32 == ' ' as i32 {\n                                41i32\n                            } else {\n                                72\n                            }) as u64)\n                                .wrapping_mul(n_2),\n                        ),\n                        l_2.wrapping_add(5),\n                        l_2,\n                        matches,\n                    );\n                    has_found_match = 1;\n                    if l_2.wrapping_add(5) < max_length {\n                        let mut s_3: *const u8 =\n                            &*data.offset(l_2.wrapping_add(5) as isize) as *const u8;\n                        if *data.offset(0 as isize) as i32 == ' ' as i32 {\n                            if l_2.wrapping_add(8) < max_length\n                                && *s_3.offset(0 as isize) as i32 == ' ' as i32\n                                && *s_3.offset(1 as isize) as i32 == 'o' as i32\n                                && *s_3.offset(2 as isize) as i32 == 'f' as i32\n                                && *s_3.offset(3 as isize) as i32 == ' ' as i32\n                            {\n                                AddMatch(\n                                    id_2.wrapping_add(62u64.wrapping_mul(n_2)),\n                                    l_2.wrapping_add(9),\n                                    l_2,\n                                    matches,\n                                );\n                                if l_2.wrapping_add(12) < max_length\n                                    && *s_3.offset(4 as isize) as i32 == 't' as i32\n                                    && *s_3.offset(5 as isize) as i32 == 'h' as i32\n                                    && *s_3.offset(6 as isize) as i32 == 'e' as i32\n                                    && *s_3.offset(7 as isize) as i32 == ' ' as i32\n                                {\n                                    AddMatch(\n                                        id_2.wrapping_add(73u64.wrapping_mul(n_2)),\n                                        l_2.wrapping_add(13),\n                                        l_2,\n                                        matches,\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:1132:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1132\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if max_length >= 9 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if *data.offset(0 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && *data.offset(1 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                && *data.offset(2 as isize) as i32 == 'h' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1132\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif max_length >= 9 && (*data.offset(0 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && *data.offset(1 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && *data.offset(2 as isize) as i32 == 'h' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && *data.offset(3 as isize) as i32 == 'e' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 && *data.offset(4 as isize) as i32 == ' ' as i32 || *data.offset(0 as isize) as i32 == '.' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1137\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && *data.offset(1 as isize) as i32 == 'c' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1138\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && *data.offset(2 as isize) as i32 == 'o' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && *data.offset(3 as isize) as i32 == 'm' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && *data.offset(4 as isize) as i32 == '/' as i32) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1141\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut offset_2 = *((*dictionary).buckets)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1142\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 .offset(Hash(&*data.offset(5 as isize)) as isize)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut end_2 = (offset_2 == 0) as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             while end_2 == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let fresh3 = offset_2;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 offset_2 = offset_2.wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let mut w_2 = *((*dictionary).dict_words).offset(fresh3 as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let l_2 = (w_2.len as i32 & 0x1fi32) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let n_2 = 1 << (*(*dictionary).words).size_bits_by_length[l_2 as usize] as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1151\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let id_2 = w_2.idx as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1152\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 end_2 = (w_2.len as i32 & 0x80 != 0) as i32;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 w_2.len = l_2 as u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1154\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 if w_2.transform as i32 == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     && IsMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         (*dictionary).words,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         w_2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1158\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         &*data.offset(5 as isize),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1159\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         max_length.wrapping_sub(5),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1160\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     ) != 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1161\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1162\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1163\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         id_2.wrapping_add(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ((if *data.offset(0 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1165\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 41i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1167\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 72\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }) as u64)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1169\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 .wrapping_mul(n_2),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         ),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         l_2.wrapping_add(5),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         l_2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1173\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     has_found_match = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     if l_2.wrapping_add(5) < max_length {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         let mut s_3: *const u8 =\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             &*data.offset(l_2.wrapping_add(5) as isize) as *const u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         if *data.offset(0 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1180\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if l_2.wrapping_add(8) < max_length\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && *s_3.offset(0 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1182\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && *s_3.offset(1 as isize) as i32 == 'o' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && *s_3.offset(2 as isize) as i32 == 'f' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 && *s_3.offset(3 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1185\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     id_2.wrapping_add(62u64.wrapping_mul(n_2)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l_2.wrapping_add(9),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l_2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1190\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if l_2.wrapping_add(12) < max_length\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(4 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(5 as isize) as i32 == 'h' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(6 as isize) as i32 == 'e' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1196\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(7 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         id_2.wrapping_add(73u64.wrapping_mul(n_2)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l_2.wrapping_add(13),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l_2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1207\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":52706,"byte_end":54432,"line_start":1182,"line_end":1209,"column_start":29,"column_end":30,"is_primary":true,"text":[{"text":"                            if *data.offset(0 as isize) as i32 == ' ' as i32 {","highlight_start":29,"highlight_end":79},{"text":"                                if l_2.wrapping_add(8) < max_length","highlight_start":1,"highlight_end":68},{"text":"                                    && *s_3.offset(0 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(1 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(2 as isize) as i32 == 'f' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id_2.wrapping_add(62u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":84},{"text":"                                        l_2.wrapping_add(9),","highlight_start":1,"highlight_end":61},{"text":"                                        l_2,","highlight_start":1,"highlight_end":45},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    if l_2.wrapping_add(12) < max_length","highlight_start":1,"highlight_end":73},{"text":"                                        && *s_3.offset(4 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(5 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(6 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(7 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":88},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        AddMatch(","highlight_start":1,"highlight_end":50},{"text":"                                            id_2.wrapping_add(73u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":88},{"text":"                                            l_2.wrapping_add(13),","highlight_start":1,"highlight_end":66},{"text":"                                            l_2,","highlight_start":1,"highlight_end":49},{"text":"                                            matches,","highlight_start":1,"highlight_end":53},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/enc/static_dict.rs","byte_start":52706,"byte_end":54432,"line_start":1182,"line_end":1209,"column_start":29,"column_end":30,"is_primary":true,"text":[{"text":"                            if *data.offset(0 as isize) as i32 == ' ' as i32 {","highlight_start":29,"highlight_end":79},{"text":"                                if l_2.wrapping_add(8) < max_length","highlight_start":1,"highlight_end":68},{"text":"                                    && *s_3.offset(0 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(1 as isize) as i32 == 'o' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(2 as isize) as i32 == 'f' as i32","highlight_start":1,"highlight_end":84},{"text":"                                    && *s_3.offset(3 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":84},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    AddMatch(","highlight_start":1,"highlight_end":46},{"text":"                                        id_2.wrapping_add(62u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":84},{"text":"                                        l_2.wrapping_add(9),","highlight_start":1,"highlight_end":61},{"text":"                                        l_2,","highlight_start":1,"highlight_end":45},{"text":"                                        matches,","highlight_start":1,"highlight_end":49},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    if l_2.wrapping_add(12) < max_length","highlight_start":1,"highlight_end":73},{"text":"                                        && *s_3.offset(4 as isize) as i32 == 't' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(5 as isize) as i32 == 'h' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(6 as isize) as i32 == 'e' as i32","highlight_start":1,"highlight_end":88},{"text":"                                        && *s_3.offset(7 as isize) as i32 == ' ' as i32","highlight_start":1,"highlight_end":88},{"text":"                                    {","highlight_start":1,"highlight_end":38},{"text":"                                        AddMatch(","highlight_start":1,"highlight_end":50},{"text":"                                            id_2.wrapping_add(73u64.wrapping_mul(n_2)),","highlight_start":1,"highlight_end":88},{"text":"                                            l_2.wrapping_add(13),","highlight_start":1,"highlight_end":66},{"text":"                                            l_2,","highlight_start":1,"highlight_end":49},{"text":"                                            matches,","highlight_start":1,"highlight_end":53},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"if *data.offset(0 as isize) as i32 == ' ' as i32 && l_2.wrapping_add(8) < max_length\n                                    && *s_3.offset(0 as isize) as i32 == ' ' as i32\n                                    && *s_3.offset(1 as isize) as i32 == 'o' as i32\n                                    && *s_3.offset(2 as isize) as i32 == 'f' as i32 && *s_3.offset(3 as isize) as i32 == ' ' as i32 {\n                                AddMatch(\n                                    id_2.wrapping_add(62u64.wrapping_mul(n_2)),\n                                    l_2.wrapping_add(9),\n                                    l_2,\n                                    matches,\n                                );\n                                if l_2.wrapping_add(12) < max_length\n                                    && *s_3.offset(4 as isize) as i32 == 't' as i32\n                                    && *s_3.offset(5 as isize) as i32 == 'h' as i32\n                                    && *s_3.offset(6 as isize) as i32 == 'e' as i32\n                                    && *s_3.offset(7 as isize) as i32 == ' ' as i32\n                                {\n                                    AddMatch(\n                                        id_2.wrapping_add(73u64.wrapping_mul(n_2)),\n                                        l_2.wrapping_add(13),\n                                        l_2,\n                                        matches,\n                                    );\n                                }\n                            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/static_dict.rs:1182:29\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1182\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   if *data.offset(0 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       if l_2.wrapping_add(8) < max_length\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && *s_3.offset(0 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1185\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                           && *s_3.offset(1 as isize) as i32 == 'o' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                       }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_______________________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1182\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10mif *data.offset(0 as isize) as i32 == ' ' as i32 && l_2.wrapping_add(8) < max_length\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(0 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(1 as isize) as i32 == 'o' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1185\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(2 as isize) as i32 == 'f' as i32 && *s_3.offset(3 as isize) as i32 == ' ' as i32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     id_2.wrapping_add(62u64.wrapping_mul(n_2)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l_2.wrapping_add(9),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     l_2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1190\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if l_2.wrapping_add(12) < max_length\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(4 as isize) as i32 == 't' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(5 as isize) as i32 == 'h' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(6 as isize) as i32 == 'e' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1196\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     && *s_3.offset(7 as isize) as i32 == ' ' as i32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     AddMatch(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         id_2.wrapping_add(73u64.wrapping_mul(n_2)),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l_2.wrapping_add(13),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         l_2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         matches,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"unused import: `libc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/enc/utf8_util.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"use libc;","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/enc/utf8_util.rs","byte_start":0,"byte_end":9,"line_start":1,"line_end":1,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"use libc;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `libc`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/utf8_util.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse libc;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"message":"this `else { if .. }` block can be collapsed","code":{"code":"clippy::collapsible_else_if","explanation":null},"level":"warning","spans":[{"file_name":"src/tools/brotli.rs","byte_start":25845,"byte_end":37539,"line_start":584,"line_end":785,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if strcmp(b\"keep\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":87},{"text":"                                if keep_set != 0 {","highlight_start":1,"highlight_end":51},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --rm / -j or --keep / -k already set\\n\\0\"","highlight_start":1,"highlight_end":93},{"text":"                                            as *const u8","highlight_start":1,"highlight_end":57},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                keep_set = 1;","highlight_start":1,"highlight_end":46},{"text":"                                (*params).junk_source = 0;","highlight_start":1,"highlight_end":59},{"text":"                            } else if strcmp(b\"no-copy-stat\\0\" as *const u8 as *const i8, arg) == 0","highlight_start":1,"highlight_end":100},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                if (*params).copy_stat == 0 {","highlight_start":1,"highlight_end":62},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --no-copy-stat / -n already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":101},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                };","highlight_start":1,"highlight_end":35},{"text":"                                (*params).copy_stat = 0;","highlight_start":1,"highlight_end":57},{"text":"                            } else if strcmp(b\"rm\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":92},{"text":"                                if keep_set != 0 {","highlight_start":1,"highlight_end":51},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --rm / -j or --keep / -k already set\\n\\0\"","highlight_start":1,"highlight_end":93},{"text":"                                            as *const u8","highlight_start":1,"highlight_end":57},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                keep_set = 1;","highlight_start":1,"highlight_end":46},{"text":"                                (*params).junk_source = 1;","highlight_start":1,"highlight_end":59},{"text":"                            } else if strcmp(b\"stdout\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":96},{"text":"                                if output_set != 0 {","highlight_start":1,"highlight_end":53},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"write to standard output already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":97},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                output_set = 1;","highlight_start":1,"highlight_end":48},{"text":"                                (*params).write_to_stdout = 1;","highlight_start":1,"highlight_end":63},{"text":"                            } else if strcmp(b\"test\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":94},{"text":"                                if command_set != 0 {","highlight_start":1,"highlight_end":54},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"command already set when parsing --test\\n\\0\" as *const u8","highlight_start":1,"highlight_end":100},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                command_set = 1;","highlight_start":1,"highlight_end":49},{"text":"                                command = COMMAND_TEST_INTEGRITY;","highlight_start":1,"highlight_end":66},{"text":"                            } else if strcmp(b\"verbose\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":97},{"text":"                                if (*params).verbosity > 0 {","highlight_start":1,"highlight_end":61},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --verbose / -v already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":96},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                };","highlight_start":1,"highlight_end":35},{"text":"                                (*params).verbosity = 1;","highlight_start":1,"highlight_end":57},{"text":"                            } else if strcmp(b\"version\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":97},{"text":"                                return COMMAND_VERSION;","highlight_start":1,"highlight_end":56},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                let mut value: *const i8 = strrchr(arg, '=' as i32);","highlight_start":1,"highlight_end":85},{"text":"                                let mut key_len: u64 = 0;","highlight_start":1,"highlight_end":58},{"text":"                                if value.is_null() || *value.offset(1 as isize) as i32 == 0 {","highlight_start":1,"highlight_end":94},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"must pass the parameter as --%s=value\\n\\0\" as *const u8","highlight_start":1,"highlight_end":98},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                        arg,","highlight_start":1,"highlight_end":45},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                key_len = value.offset_from(arg) as u64;","highlight_start":1,"highlight_end":73},{"text":"                                value = value.offset(1);","highlight_start":1,"highlight_end":57},{"text":"                                if strncmp(b\"lgwin\\0\" as *const u8 as *const i8, arg, key_len) == 0","highlight_start":1,"highlight_end":100},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if lgwin_set != 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"lgwin parameter already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":92},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    lgwin_set = ParseInt(value, 0, 24, &mut (*params).lgwin);","highlight_start":1,"highlight_end":94},{"text":"                                    if lgwin_set == 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"error parsing lgwin value [%s]\\n\\0\" as *const u8","highlight_start":1,"highlight_end":95},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                            value,","highlight_start":1,"highlight_end":51},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    if (*params).lgwin != 0 && (*params).lgwin < 10 {","highlight_start":1,"highlight_end":86},{"text":"                                        fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);","highlight_start":1,"highlight_end":168},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"large_window\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":81},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if lgwin_set != 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"lgwin parameter already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":92},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    lgwin_set = ParseInt(value, 0, 30, &mut (*params).lgwin);","highlight_start":1,"highlight_end":94},{"text":"                                    if lgwin_set == 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"error parsing lgwin value [%s]\\n\\0\" as *const u8","highlight_start":1,"highlight_end":95},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                            value,","highlight_start":1,"highlight_end":51},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    if (*params).lgwin != 0 && (*params).lgwin < 10 {","highlight_start":1,"highlight_end":86},{"text":"                                        fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);","highlight_start":1,"highlight_end":168},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"output\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":75},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if output_set != 0 {","highlight_start":1,"highlight_end":57},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"write to standard output already set (--output)\\n\\0\"","highlight_start":1,"highlight_end":99},{"text":"                                                as *const u8","highlight_start":1,"highlight_end":61},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    let ref mut fresh5 = (*params).output_path;","highlight_start":1,"highlight_end":80},{"text":"                                    *fresh5 = value;","highlight_start":1,"highlight_end":53},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"quality\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":76},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if quality_set != 0 {","highlight_start":1,"highlight_end":58},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"quality already set\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":98},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    quality_set = ParseInt(value, 0, 11, &mut (*params).quality);","highlight_start":1,"highlight_end":98},{"text":"                                    if quality_set == 0 {","highlight_start":1,"highlight_end":58},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"error parsing quality value [%s]\\n\\0\" as *const u8","highlight_start":1,"highlight_end":97},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                            value,","highlight_start":1,"highlight_end":51},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"suffix\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":75},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if suffix_set != 0 {","highlight_start":1,"highlight_end":57},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"suffix already set\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":97},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    suffix_set = 1;","highlight_start":1,"highlight_end":52},{"text":"                                    let ref mut fresh6 = (*params).suffix;","highlight_start":1,"highlight_end":75},{"text":"                                    *fresh6 = value;","highlight_start":1,"highlight_end":53},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"invalid parameter: [%s]\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":98},{"text":"                                        arg,","highlight_start":1,"highlight_end":45},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/tools/brotli.rs","byte_start":25845,"byte_end":37539,"line_start":584,"line_end":785,"column_start":32,"column_end":26,"is_primary":true,"text":[{"text":"                        } else {","highlight_start":32,"highlight_end":33},{"text":"                            if strcmp(b\"keep\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":87},{"text":"                                if keep_set != 0 {","highlight_start":1,"highlight_end":51},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --rm / -j or --keep / -k already set\\n\\0\"","highlight_start":1,"highlight_end":93},{"text":"                                            as *const u8","highlight_start":1,"highlight_end":57},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                keep_set = 1;","highlight_start":1,"highlight_end":46},{"text":"                                (*params).junk_source = 0;","highlight_start":1,"highlight_end":59},{"text":"                            } else if strcmp(b\"no-copy-stat\\0\" as *const u8 as *const i8, arg) == 0","highlight_start":1,"highlight_end":100},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                if (*params).copy_stat == 0 {","highlight_start":1,"highlight_end":62},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --no-copy-stat / -n already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":101},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                };","highlight_start":1,"highlight_end":35},{"text":"                                (*params).copy_stat = 0;","highlight_start":1,"highlight_end":57},{"text":"                            } else if strcmp(b\"rm\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":92},{"text":"                                if keep_set != 0 {","highlight_start":1,"highlight_end":51},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --rm / -j or --keep / -k already set\\n\\0\"","highlight_start":1,"highlight_end":93},{"text":"                                            as *const u8","highlight_start":1,"highlight_end":57},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                keep_set = 1;","highlight_start":1,"highlight_end":46},{"text":"                                (*params).junk_source = 1;","highlight_start":1,"highlight_end":59},{"text":"                            } else if strcmp(b\"stdout\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":96},{"text":"                                if output_set != 0 {","highlight_start":1,"highlight_end":53},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"write to standard output already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":97},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                output_set = 1;","highlight_start":1,"highlight_end":48},{"text":"                                (*params).write_to_stdout = 1;","highlight_start":1,"highlight_end":63},{"text":"                            } else if strcmp(b\"test\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":94},{"text":"                                if command_set != 0 {","highlight_start":1,"highlight_end":54},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"command already set when parsing --test\\n\\0\" as *const u8","highlight_start":1,"highlight_end":100},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                command_set = 1;","highlight_start":1,"highlight_end":49},{"text":"                                command = COMMAND_TEST_INTEGRITY;","highlight_start":1,"highlight_end":66},{"text":"                            } else if strcmp(b\"verbose\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":97},{"text":"                                if (*params).verbosity > 0 {","highlight_start":1,"highlight_end":61},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"argument --verbose / -v already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":96},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                };","highlight_start":1,"highlight_end":35},{"text":"                                (*params).verbosity = 1;","highlight_start":1,"highlight_end":57},{"text":"                            } else if strcmp(b\"version\\0\" as *const u8 as *const i8, arg) == 0 {","highlight_start":1,"highlight_end":97},{"text":"                                return COMMAND_VERSION;","highlight_start":1,"highlight_end":56},{"text":"                            } else {","highlight_start":1,"highlight_end":37},{"text":"                                let mut value: *const i8 = strrchr(arg, '=' as i32);","highlight_start":1,"highlight_end":85},{"text":"                                let mut key_len: u64 = 0;","highlight_start":1,"highlight_end":58},{"text":"                                if value.is_null() || *value.offset(1 as isize) as i32 == 0 {","highlight_start":1,"highlight_end":94},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"must pass the parameter as --%s=value\\n\\0\" as *const u8","highlight_start":1,"highlight_end":98},{"text":"                                            as *const i8,","highlight_start":1,"highlight_end":58},{"text":"                                        arg,","highlight_start":1,"highlight_end":45},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                key_len = value.offset_from(arg) as u64;","highlight_start":1,"highlight_end":73},{"text":"                                value = value.offset(1);","highlight_start":1,"highlight_end":57},{"text":"                                if strncmp(b\"lgwin\\0\" as *const u8 as *const i8, arg, key_len) == 0","highlight_start":1,"highlight_end":100},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if lgwin_set != 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"lgwin parameter already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":92},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    lgwin_set = ParseInt(value, 0, 24, &mut (*params).lgwin);","highlight_start":1,"highlight_end":94},{"text":"                                    if lgwin_set == 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"error parsing lgwin value [%s]\\n\\0\" as *const u8","highlight_start":1,"highlight_end":95},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                            value,","highlight_start":1,"highlight_end":51},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    if (*params).lgwin != 0 && (*params).lgwin < 10 {","highlight_start":1,"highlight_end":86},{"text":"                                        fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);","highlight_start":1,"highlight_end":168},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"large_window\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":81},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if lgwin_set != 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"lgwin parameter already set\\n\\0\" as *const u8","highlight_start":1,"highlight_end":92},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    lgwin_set = ParseInt(value, 0, 30, &mut (*params).lgwin);","highlight_start":1,"highlight_end":94},{"text":"                                    if lgwin_set == 0 {","highlight_start":1,"highlight_end":56},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"error parsing lgwin value [%s]\\n\\0\" as *const u8","highlight_start":1,"highlight_end":95},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                            value,","highlight_start":1,"highlight_end":51},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    if (*params).lgwin != 0 && (*params).lgwin < 10 {","highlight_start":1,"highlight_end":86},{"text":"                                        fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);","highlight_start":1,"highlight_end":168},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"output\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":75},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if output_set != 0 {","highlight_start":1,"highlight_end":57},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"write to standard output already set (--output)\\n\\0\"","highlight_start":1,"highlight_end":99},{"text":"                                                as *const u8","highlight_start":1,"highlight_end":61},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    let ref mut fresh5 = (*params).output_path;","highlight_start":1,"highlight_end":80},{"text":"                                    *fresh5 = value;","highlight_start":1,"highlight_end":53},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"quality\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":76},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if quality_set != 0 {","highlight_start":1,"highlight_end":58},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"quality already set\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":98},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    quality_set = ParseInt(value, 0, 11, &mut (*params).quality);","highlight_start":1,"highlight_end":98},{"text":"                                    if quality_set == 0 {","highlight_start":1,"highlight_end":58},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"error parsing quality value [%s]\\n\\0\" as *const u8","highlight_start":1,"highlight_end":97},{"text":"                                                as *const i8,","highlight_start":1,"highlight_end":62},{"text":"                                            value,","highlight_start":1,"highlight_end":51},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                } else if strncmp(","highlight_start":1,"highlight_end":51},{"text":"                                    b\"suffix\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":75},{"text":"                                    arg,","highlight_start":1,"highlight_end":41},{"text":"                                    key_len,","highlight_start":1,"highlight_end":45},{"text":"                                ) == 0","highlight_start":1,"highlight_end":39},{"text":"                                {","highlight_start":1,"highlight_end":34},{"text":"                                    if suffix_set != 0 {","highlight_start":1,"highlight_end":57},{"text":"                                        fprintf(","highlight_start":1,"highlight_end":49},{"text":"                                            stderr,","highlight_start":1,"highlight_end":52},{"text":"                                            b\"suffix already set\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":97},{"text":"                                        );","highlight_start":1,"highlight_end":43},{"text":"                                        return COMMAND_INVALID;","highlight_start":1,"highlight_end":64},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                    suffix_set = 1;","highlight_start":1,"highlight_end":52},{"text":"                                    let ref mut fresh6 = (*params).suffix;","highlight_start":1,"highlight_end":75},{"text":"                                    *fresh6 = value;","highlight_start":1,"highlight_end":53},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    fprintf(","highlight_start":1,"highlight_end":45},{"text":"                                        stderr,","highlight_start":1,"highlight_end":48},{"text":"                                        b\"invalid parameter: [%s]\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":98},{"text":"                                        arg,","highlight_start":1,"highlight_end":45},{"text":"                                    );","highlight_start":1,"highlight_end":39},{"text":"                                    return COMMAND_INVALID;","highlight_start":1,"highlight_end":60},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":"if strcmp(b\"keep\\0\" as *const u8 as *const i8, arg) == 0 {\n                            if keep_set != 0 {\n                                fprintf(\n                                    stderr,\n                                    b\"argument --rm / -j or --keep / -k already set\\n\\0\"\n                                        as *const u8\n                                        as *const i8,\n                                );\n                                return COMMAND_INVALID;\n                            }\n                            keep_set = 1;\n                            (*params).junk_source = 0;\n                        } else if strcmp(b\"no-copy-stat\\0\" as *const u8 as *const i8, arg) == 0\n                        {\n                            if (*params).copy_stat == 0 {\n                                fprintf(\n                                    stderr,\n                                    b\"argument --no-copy-stat / -n already set\\n\\0\" as *const u8\n                                        as *const i8,\n                                );\n                                return COMMAND_INVALID;\n                            };\n                            (*params).copy_stat = 0;\n                        } else if strcmp(b\"rm\\0\" as *const u8 as *const i8, arg) == 0 {\n                            if keep_set != 0 {\n                                fprintf(\n                                    stderr,\n                                    b\"argument --rm / -j or --keep / -k already set\\n\\0\"\n                                        as *const u8\n                                        as *const i8,\n                                );\n                                return COMMAND_INVALID;\n                            }\n                            keep_set = 1;\n                            (*params).junk_source = 1;\n                        } else if strcmp(b\"stdout\\0\" as *const u8 as *const i8, arg) == 0 {\n                            if output_set != 0 {\n                                fprintf(\n                                    stderr,\n                                    b\"write to standard output already set\\n\\0\" as *const u8\n                                        as *const i8,\n                                );\n                                return COMMAND_INVALID;\n                            }\n                            output_set = 1;\n                            (*params).write_to_stdout = 1;\n                        } else if strcmp(b\"test\\0\" as *const u8 as *const i8, arg) == 0 {\n                            if command_set != 0 {\n                                fprintf(\n                                    stderr,\n                                    b\"command already set when parsing --test\\n\\0\" as *const u8\n                                        as *const i8,\n                                );\n                                return COMMAND_INVALID;\n                            }\n                            command_set = 1;\n                            command = COMMAND_TEST_INTEGRITY;\n                        } else if strcmp(b\"verbose\\0\" as *const u8 as *const i8, arg) == 0 {\n                            if (*params).verbosity > 0 {\n                                fprintf(\n                                    stderr,\n                                    b\"argument --verbose / -v already set\\n\\0\" as *const u8\n                                        as *const i8,\n                                );\n                                return COMMAND_INVALID;\n                            };\n                            (*params).verbosity = 1;\n                        } else if strcmp(b\"version\\0\" as *const u8 as *const i8, arg) == 0 {\n                            return COMMAND_VERSION;\n                        } else {\n                            let mut value: *const i8 = strrchr(arg, '=' as i32);\n                            let mut key_len: u64 = 0;\n                            if value.is_null() || *value.offset(1 as isize) as i32 == 0 {\n                                fprintf(\n                                    stderr,\n                                    b\"must pass the parameter as --%s=value\\n\\0\" as *const u8\n                                        as *const i8,\n                                    arg,\n                                );\n                                return COMMAND_INVALID;\n                            }\n                            key_len = value.offset_from(arg) as u64;\n                            value = value.offset(1);\n                            if strncmp(b\"lgwin\\0\" as *const u8 as *const i8, arg, key_len) == 0\n                            {\n                                if lgwin_set != 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"lgwin parameter already set\\n\\0\" as *const u8\n                                            as *const i8,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                                lgwin_set = ParseInt(value, 0, 24, &mut (*params).lgwin);\n                                if lgwin_set == 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"error parsing lgwin value [%s]\\n\\0\" as *const u8\n                                            as *const i8,\n                                        value,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                                if (*params).lgwin != 0 && (*params).lgwin < 10 {\n                                    fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);\n                                    return COMMAND_INVALID;\n                                }\n                            } else if strncmp(\n                                b\"large_window\\0\" as *const u8 as *const i8,\n                                arg,\n                                key_len,\n                            ) == 0\n                            {\n                                if lgwin_set != 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"lgwin parameter already set\\n\\0\" as *const u8\n                                            as *const i8,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                                lgwin_set = ParseInt(value, 0, 30, &mut (*params).lgwin);\n                                if lgwin_set == 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"error parsing lgwin value [%s]\\n\\0\" as *const u8\n                                            as *const i8,\n                                        value,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                                if (*params).lgwin != 0 && (*params).lgwin < 10 {\n                                    fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);\n                                    return COMMAND_INVALID;\n                                }\n                            } else if strncmp(\n                                b\"output\\0\" as *const u8 as *const i8,\n                                arg,\n                                key_len,\n                            ) == 0\n                            {\n                                if output_set != 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"write to standard output already set (--output)\\n\\0\"\n                                            as *const u8\n                                            as *const i8,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                                let ref mut fresh5 = (*params).output_path;\n                                *fresh5 = value;\n                            } else if strncmp(\n                                b\"quality\\0\" as *const u8 as *const i8,\n                                arg,\n                                key_len,\n                            ) == 0\n                            {\n                                if quality_set != 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"quality already set\\n\\0\" as *const u8 as *const i8,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                                quality_set = ParseInt(value, 0, 11, &mut (*params).quality);\n                                if quality_set == 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"error parsing quality value [%s]\\n\\0\" as *const u8\n                                            as *const i8,\n                                        value,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                            } else if strncmp(\n                                b\"suffix\\0\" as *const u8 as *const i8,\n                                arg,\n                                key_len,\n                            ) == 0\n                            {\n                                if suffix_set != 0 {\n                                    fprintf(\n                                        stderr,\n                                        b\"suffix already set\\n\\0\" as *const u8 as *const i8,\n                                    );\n                                    return COMMAND_INVALID;\n                                }\n                                suffix_set = 1;\n                                let ref mut fresh6 = (*params).suffix;\n                                *fresh6 = value;\n                            } else {\n                                fprintf(\n                                    stderr,\n                                    b\"invalid parameter: [%s]\\n\\0\" as *const u8 as *const i8,\n                                    arg,\n                                );\n                                return COMMAND_INVALID;\n                            }\n                        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `else { if .. }` block can be collapsed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tools/brotli.rs:584:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m584\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                        } else {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m585\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            if strcmp(b\"keep\\0\" as *const u8 as *const i8, arg) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                if keep_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m587\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                    fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m784\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m785\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m584\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        } else \u001b[0m\u001b[0m\u001b[38;5;10mif strcmp(b\"keep\\0\" as *const u8 as *const i8, arg) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m585\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if keep_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m587\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m588\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"argument --rm / -j or --keep / -k already set\\n\\0\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m589\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m590\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m591\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m592\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m593\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m594\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             keep_set = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m595\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*params).junk_source = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m596\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else if strcmp(b\"no-copy-stat\\0\" as *const u8 as *const i8, arg) == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m597\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m598\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if (*params).copy_stat == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m599\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m600\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m601\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"argument --no-copy-stat / -n already set\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m602\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m603\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m604\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m605\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m606\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*params).copy_stat = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m607\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else if strcmp(b\"rm\\0\" as *const u8 as *const i8, arg) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m608\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if keep_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m609\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m610\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m611\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"argument --rm / -j or --keep / -k already set\\n\\0\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m612\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m613\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m614\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m615\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m616\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m617\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             keep_set = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m618\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*params).junk_source = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m619\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else if strcmp(b\"stdout\\0\" as *const u8 as *const i8, arg) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m620\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if output_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m621\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m622\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m623\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"write to standard output already set\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m624\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m625\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m626\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m627\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m628\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             output_set = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m629\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*params).write_to_stdout = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m630\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else if strcmp(b\"test\\0\" as *const u8 as *const i8, arg) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if command_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m632\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m633\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m634\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"command already set when parsing --test\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m635\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m636\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m637\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m638\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m639\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             command_set = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m640\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             command = COMMAND_TEST_INTEGRITY;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m641\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else if strcmp(b\"verbose\\0\" as *const u8 as *const i8, arg) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m642\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if (*params).verbosity > 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m643\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m644\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m645\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"argument --verbose / -v already set\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m646\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m647\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m648\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m649\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             };\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m650\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             (*params).verbosity = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m651\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else if strcmp(b\"version\\0\" as *const u8 as *const i8, arg) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m652\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             return COMMAND_VERSION;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m653\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m654\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let mut value: *const i8 = strrchr(arg, '=' as i32);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m655\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             let mut key_len: u64 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m656\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if value.is_null() || *value.offset(1 as isize) as i32 == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m657\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m658\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m659\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"must pass the parameter as --%s=value\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m660\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m661\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     arg,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m662\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m663\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m664\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m665\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             key_len = value.offset_from(arg) as u64;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m666\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             value = value.offset(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m667\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             if strncmp(b\"lgwin\\0\" as *const u8 as *const i8, arg, key_len) == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m668\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m669\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if lgwin_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m670\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m671\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m672\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"lgwin parameter already set\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m673\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                             as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m674\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m675\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m676\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m677\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 lgwin_set = ParseInt(value, 0, 24, &mut (*params).lgwin);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m678\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if lgwin_set == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m679\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m680\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m681\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"error parsing lgwin value [%s]\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m682\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                             as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m683\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         value,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m684\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m685\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m686\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m687\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if (*params).lgwin != 0 && (*params).lgwin < 10 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m688\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m689\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m690\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m691\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else if strncmp(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m692\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 b\"large_window\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m693\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 arg,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m694\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 key_len,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m695\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ) == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m696\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m697\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if lgwin_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m698\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m699\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m700\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"lgwin parameter already set\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m701\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                             as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m702\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m703\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m704\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m705\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 lgwin_set = ParseInt(value, 0, 30, &mut (*params).lgwin);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m706\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if lgwin_set == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m707\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m708\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m709\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"error parsing lgwin value [%s]\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m710\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                             as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m711\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         value,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m712\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m713\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m714\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m715\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if (*params).lgwin != 0 && (*params).lgwin < 10 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m716\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf (stderr, b\"lgwin parameter (%d) smaller than the minimum (%d)\\n\\0\" as * const u8 as * const i8, (* params).lgwin, 10,);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m717\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m718\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m719\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else if strncmp(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m720\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 b\"output\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m721\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 arg,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m722\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 key_len,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m723\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ) == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m724\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m725\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if output_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m726\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m727\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m728\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"write to standard output already set (--output)\\n\\0\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m729\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                             as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m730\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                             as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m731\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m732\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m733\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m734\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let ref mut fresh5 = (*params).output_path;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m735\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 *fresh5 = value;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m736\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else if strncmp(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m737\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 b\"quality\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m738\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 arg,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m739\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 key_len,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m740\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ) == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m741\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m742\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if quality_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m743\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m744\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m745\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"quality already set\\n\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m746\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m747\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m748\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m749\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 quality_set = ParseInt(value, 0, 11, &mut (*params).quality);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m750\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if quality_set == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m751\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m752\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m753\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"error parsing quality value [%s]\\n\\0\" as *const u8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m754\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                             as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m755\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         value,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m756\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m757\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m758\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m759\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else if strncmp(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m760\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 b\"suffix\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m761\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 arg,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m762\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 key_len,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m763\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             ) == 0\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m764\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m765\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 if suffix_set != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m766\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m767\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m768\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                         b\"suffix already set\\n\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m769\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m770\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m771\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m772\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 suffix_set = 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m773\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 let ref mut fresh6 = (*params).suffix;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m774\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 *fresh6 = value;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m775\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m776\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m777\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m778\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     b\"invalid parameter: [%s]\\n\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m779\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                     arg,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m780\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m781\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                                 return COMMAND_INVALID;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m782\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m783\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/tools/brotli.rs","byte_start":51107,"byte_end":51575,"line_start":1165,"line_end":1177,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if !((*context).fin).is_null() {","highlight_start":9,"highlight_end":41},{"text":"            if fclose((*context).fin) != 0 {","highlight_start":1,"highlight_end":45},{"text":"                if is_ok != 0 {","highlight_start":1,"highlight_end":32},{"text":"                    fprintf(","highlight_start":1,"highlight_end":29},{"text":"                        stderr,","highlight_start":1,"highlight_end":32},{"text":"                        b\"fclose failed [%s]: %s\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":81},{"text":"                        PrintablePath((*context).current_input_path),","highlight_start":1,"highlight_end":70},{"text":"                        strerror(*__errno_location()),","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                is_ok = 0;","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/tools/brotli.rs","byte_start":51107,"byte_end":51575,"line_start":1165,"line_end":1177,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if !((*context).fin).is_null() {","highlight_start":9,"highlight_end":41},{"text":"            if fclose((*context).fin) != 0 {","highlight_start":1,"highlight_end":45},{"text":"                if is_ok != 0 {","highlight_start":1,"highlight_end":32},{"text":"                    fprintf(","highlight_start":1,"highlight_end":29},{"text":"                        stderr,","highlight_start":1,"highlight_end":32},{"text":"                        b\"fclose failed [%s]: %s\\n\\0\" as *const u8 as *const i8,","highlight_start":1,"highlight_end":81},{"text":"                        PrintablePath((*context).current_input_path),","highlight_start":1,"highlight_end":70},{"text":"                        strerror(*__errno_location()),","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                is_ok = 0;","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if !((*context).fin).is_null() && fclose((*context).fin) != 0 {\n            if is_ok != 0 {\n                fprintf(\n                    stderr,\n                    b\"fclose failed [%s]: %s\\n\\0\" as *const u8 as *const i8,\n                    PrintablePath((*context).current_input_path),\n                    strerror(*__errno_location()),\n                );\n            }\n            is_ok = 0;\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tools/brotli.rs:1165:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1165\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if !((*context).fin).is_null() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if fclose((*context).fin) != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1167\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if is_ok != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1165\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif !((*context).fin).is_null() && fclose((*context).fin) != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if is_ok != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1167\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 fprintf(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     stderr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1169\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     b\"fclose failed [%s]: %s\\n\\0\" as *const u8 as *const i8,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     PrintablePath((*context).current_input_path),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     strerror(*__errno_location()),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 );\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1173\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             is_ok = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/tools/brotli.rs","byte_start":60864,"byte_end":61009,"line_start":1457,"line_end":1461,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if (*context).available_out == 0 {","highlight_start":13,"highlight_end":47},{"text":"                if ProvideOutput(context) == 0 {","highlight_start":1,"highlight_end":49},{"text":"                    return 0;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/tools/brotli.rs","byte_start":60864,"byte_end":61009,"line_start":1457,"line_end":1461,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            if (*context).available_out == 0 {","highlight_start":13,"highlight_end":47},{"text":"                if ProvideOutput(context) == 0 {","highlight_start":1,"highlight_end":49},{"text":"                    return 0;","highlight_start":1,"highlight_end":30},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"if (*context).available_out == 0 && ProvideOutput(context) == 0 {\n                return 0;\n            }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tools/brotli.rs:1457:13\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1457\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if (*context).available_out == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if ProvideOutput(context) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1460\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1457\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif (*context).available_out == 0 && ProvideOutput(context) == 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 return 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"this `if` statement can be collapsed","code":{"code":"clippy::collapsible_if","explanation":null},"level":"warning","spans":[{"file_name":"src/tools/brotli.rs","byte_start":66364,"byte_end":67306,"line_start":1614,"line_end":1632,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if command as u32 == COMMAND_COMPRESS as u32","highlight_start":9,"highlight_end":53},{"text":"            || command as u32 == COMMAND_DECOMPRESS as u32","highlight_start":1,"highlight_end":59},{"text":"            || command as u32 == COMMAND_TEST_INTEGRITY as u32","highlight_start":1,"highlight_end":63},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            if is_ok != 0 {","highlight_start":1,"highlight_end":28},{"text":"                let mut modified_path_len = (context.longest_path_len)","highlight_start":1,"highlight_end":71},{"text":"                    .wrapping_add(strlen(context.suffix))","highlight_start":1,"highlight_end":58},{"text":"                    .wrapping_add(1);","highlight_start":1,"highlight_end":38},{"text":"                context.modified_path = malloc(modified_path_len) as *mut i8;","highlight_start":1,"highlight_end":78},{"text":"                context.buffer = malloc(kFileBufferSize.wrapping_mul(2)) as *mut u8;","highlight_start":1,"highlight_end":85},{"text":"                if (context.modified_path).is_null() || (context.buffer).is_null() {","highlight_start":1,"highlight_end":85},{"text":"                    fprintf(stderr, b\"out of memory\\n\\0\" as *const u8 as *const i8);","highlight_start":1,"highlight_end":85},{"text":"                    is_ok = 0;","highlight_start":1,"highlight_end":31},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    context.input = context.buffer;","highlight_start":1,"highlight_end":52},{"text":"                    context.output = (context.buffer).offset(kFileBufferSize as isize);","highlight_start":1,"highlight_end":88},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"collapse nested if block","code":null,"level":"help","spans":[{"file_name":"src/tools/brotli.rs","byte_start":66364,"byte_end":67306,"line_start":1614,"line_end":1632,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        if command as u32 == COMMAND_COMPRESS as u32","highlight_start":9,"highlight_end":53},{"text":"            || command as u32 == COMMAND_DECOMPRESS as u32","highlight_start":1,"highlight_end":59},{"text":"            || command as u32 == COMMAND_TEST_INTEGRITY as u32","highlight_start":1,"highlight_end":63},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            if is_ok != 0 {","highlight_start":1,"highlight_end":28},{"text":"                let mut modified_path_len = (context.longest_path_len)","highlight_start":1,"highlight_end":71},{"text":"                    .wrapping_add(strlen(context.suffix))","highlight_start":1,"highlight_end":58},{"text":"                    .wrapping_add(1);","highlight_start":1,"highlight_end":38},{"text":"                context.modified_path = malloc(modified_path_len) as *mut i8;","highlight_start":1,"highlight_end":78},{"text":"                context.buffer = malloc(kFileBufferSize.wrapping_mul(2)) as *mut u8;","highlight_start":1,"highlight_end":85},{"text":"                if (context.modified_path).is_null() || (context.buffer).is_null() {","highlight_start":1,"highlight_end":85},{"text":"                    fprintf(stderr, b\"out of memory\\n\\0\" as *const u8 as *const i8);","highlight_start":1,"highlight_end":85},{"text":"                    is_ok = 0;","highlight_start":1,"highlight_end":31},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    context.input = context.buffer;","highlight_start":1,"highlight_end":52},{"text":"                    context.output = (context.buffer).offset(kFileBufferSize as isize);","highlight_start":1,"highlight_end":88},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"if (command as u32 == COMMAND_COMPRESS as u32\n            || command as u32 == COMMAND_DECOMPRESS as u32 || command as u32 == COMMAND_TEST_INTEGRITY as u32) && is_ok != 0 {\n            let mut modified_path_len = (context.longest_path_len)\n                .wrapping_add(strlen(context.suffix))\n                .wrapping_add(1);\n            context.modified_path = malloc(modified_path_len) as *mut i8;\n            context.buffer = malloc(kFileBufferSize.wrapping_mul(2)) as *mut u8;\n            if (context.modified_path).is_null() || (context.buffer).is_null() {\n                fprintf(stderr, b\"out of memory\\n\\0\" as *const u8 as *const i8);\n                is_ok = 0;\n            } else {\n                context.input = context.buffer;\n                context.output = (context.buffer).offset(kFileBufferSize as isize);\n            }\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this `if` statement can be collapsed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tools/brotli.rs:1614:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1614\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if command as u32 == COMMAND_COMPRESS as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1615\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            || command as u32 == COMMAND_DECOMPRESS as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1616\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            || command as u32 == COMMAND_TEST_INTEGRITY as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1617\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1632\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_________^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: collapse nested if block\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1614\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mif (command as u32 == COMMAND_COMPRESS as u32\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1615\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             || command as u32 == COMMAND_DECOMPRESS as u32 || command as u32 == COMMAND_TEST_INTEGRITY as u32) && is_ok != 0 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1616\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             let mut modified_path_len = (context.longest_path_len)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1617\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 .wrapping_add(strlen(context.suffix))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1618\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 .wrapping_add(1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1619\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             context.modified_path = malloc(modified_path_len) as *mut i8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1620\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             context.buffer = malloc(kFileBufferSize.wrapping_mul(2)) as *mut u8;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1621\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             if (context.modified_path).is_null() || (context.buffer).is_null() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1622\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 fprintf(stderr, b\"out of memory\\n\\0\" as *const u8 as *const i8);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1623\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 is_ok = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1624\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1625\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 context.input = context.buffer;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1626\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 context.output = (context.buffer).offset(kFileBufferSize as isize);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1627\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1628\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"the feature `label_break_value` has been stable since 1.65.0 and no longer requires an attribute to enable","code":{"code":"stable_features","explanation":null},"level":"warning","spans":[{"file_name":"lib.rs","byte_start":232,"byte_end":249,"line_start":9,"line_end":9,"column_start":12,"column_end":29,"is_primary":true,"text":[{"text":"#![feature(label_break_value)]","highlight_start":12,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(stable_features)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: the feature `label_break_value` has been stable since 1.65.0 and no longer requires an attribute to enable\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:9:12\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(label_break_value)]\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(stable_features)]` on by default\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"lib.rs","byte_start":347,"byte_end":362,"line_start":13,"line_end":13,"column_start":12,"column_end":27,"is_primary":true,"text":[{"text":"#![feature(core_intrinsics)]","highlight_start":12,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mlib.rs:13:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(core_intrinsics)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dec/decode.rs","byte_start":14259,"byte_end":14271,"line_start":385,"line_end":385,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                ndistbits = ndistbits.wrapping_add(1);","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":13842,"byte_end":13842,"line_start":375,"line_end":375,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            let mut ndistbits = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:385:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m385\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                ndistbits = ndistbits.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m375\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut ndistbits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dec/decode.rs","byte_start":14356,"byte_end":14368,"line_start":388,"line_end":388,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"            ndistbits = ndistbits.wrapping_sub(1);","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":13842,"byte_end":13842,"line_start":375,"line_end":375,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            let mut ndistbits = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:388:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ndistbits = ndistbits.wrapping_sub(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m375\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut ndistbits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dec/decode.rs","byte_start":14447,"byte_end":14459,"line_start":390,"line_end":390,"column_start":31,"column_end":43,"is_primary":true,"text":[{"text":"            group = ndistbits.wrapping_sub(1) << 1 | half;","highlight_start":31,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":13842,"byte_end":13842,"line_start":375,"line_end":375,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            let mut ndistbits = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:390:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m390\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            group = ndistbits.wrapping_sub(1) << 1 | half;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m375\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut ndistbits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dec/decode.rs","byte_start":244829,"byte_end":244841,"line_start":8976,"line_end":8976,"column_start":25,"column_end":37,"is_primary":true,"text":[{"text":"        result = result.wrapping_add(1);","highlight_start":25,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":244763,"byte_end":244763,"line_start":8973,"line_end":8973,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    let mut result = 0;","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:8976:25\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8976\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        result = result.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8973\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let mut result\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dec/decode.rs","byte_start":266009,"byte_end":266021,"line_start":9511,"line_end":9511,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"            i = i.wrapping_add(1);","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":265382,"byte_end":265382,"line_start":9496,"line_end":9496,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"        let mut i = 1;","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:9511:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9511\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            i = i.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9496\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut i\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dec/decode.rs","byte_start":293347,"byte_end":293359,"line_start":10254,"line_end":10254,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"            i = i.wrapping_add(1);","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":293167,"byte_end":293167,"line_start":10249,"line_end":10249,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"        let mut i = 16;","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10254:19\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10254\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            i = i.wrapping_add(1);\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10249\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut i\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 16;\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dec/decode.rs","byte_start":293910,"byte_end":293922,"line_start":10268,"line_end":10268,"column_start":25,"column_end":37,"is_primary":true,"text":[{"text":"            bits = bits.wrapping_add(half);","highlight_start":25,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/dec/decode.rs","byte_start":293118,"byte_end":293118,"line_start":10247,"line_end":10247,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"        let mut bits = 1;","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/dec/decode.rs:10268:25\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            bits = bits.wrapping_add(half);\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut bits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":53534,"byte_end":53546,"line_start":1622,"line_end":1622,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"            num_commands = num_commands.wrapping_add(1);","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":52983,"byte_end":52983,"line_start":1611,"line_end":1611,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"        let mut num_commands = 0;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:1622:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1622\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            num_commands = num_commands.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1611\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut num_commands\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":54318,"byte_end":54330,"line_start":1649,"line_end":1649,"column_start":36,"column_end":48,"is_primary":true,"text":[{"text":"                &*nodes.offset(pos.wrapping_add(offset as u64) as isize) as *const ZopfliNode;","highlight_start":36,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":54073,"byte_end":54073,"line_start":1642,"line_end":1642,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        let mut pos = 0;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:1649:36\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1649\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &*nodes.offset(pos.wrapping_add(offset as u64) as isize) as *const ZopfliNode;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1642\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":69167,"byte_end":69179,"line_start":2067,"line_end":2067,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"            if matches_size < cur_match_pos.wrapping_add(128).wrapping_add(shadow_matches) {","highlight_start":45,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":67620,"byte_end":67620,"line_start":2029,"line_end":2029,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut cur_match_pos = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:2067:45\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2067\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if matches_size < cur_match_pos.wrapping_add(128).wrapping_add(shadow_matches) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cur_match_pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":69309,"byte_end":69321,"line_start":2069,"line_end":2069,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"                    cur_match_pos.wrapping_add(128).wrapping_add(shadow_matches)","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":67620,"byte_end":67620,"line_start":2029,"line_end":2029,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut cur_match_pos = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:2069:35\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2069\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    cur_match_pos.wrapping_add(128).wrapping_add(shadow_matches)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cur_match_pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":69542,"byte_end":69554,"line_start":2074,"line_end":2074,"column_start":49,"column_end":61,"is_primary":true,"text":[{"text":"                while _new_size < cur_match_pos.wrapping_add(128).wrapping_add(shadow_matches) {","highlight_start":49,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":67620,"byte_end":67620,"line_start":2029,"line_end":2029,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut cur_match_pos = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:2074:49\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2074\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while _new_size < cur_match_pos.wrapping_add(128).wrapping_add(shadow_matches) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cur_match_pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":71027,"byte_end":71039,"line_start":2110,"line_end":2110,"column_start":52,"column_end":64,"is_primary":true,"text":[{"text":"                &mut *matches.offset(cur_match_pos.wrapping_add(shadow_matches) as isize),","highlight_start":52,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":67620,"byte_end":67620,"line_start":2029,"line_end":2029,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut cur_match_pos = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:2110:52\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &mut *matches.offset(cur_match_pos.wrapping_add(shadow_matches) as isize),\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cur_match_pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":71124,"byte_end":71136,"line_start":2112,"line_end":2112,"column_start":43,"column_end":55,"is_primary":true,"text":[{"text":"            cur_match_end = cur_match_pos.wrapping_add(num_found_matches);","highlight_start":43,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/backward_references_hq.rs","byte_start":67620,"byte_end":67620,"line_start":2029,"line_end":2029,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut cur_match_pos = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/backward_references_hq.rs:2112:43\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cur_match_end = cur_match_pos.wrapping_add(num_found_matches);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2029\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cur_match_pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":6858,"byte_end":6870,"line_start":210,"line_end":210,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                    reps = reps.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":6668,"byte_end":6668,"line_start":206,"line_end":206,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                let mut reps = 1;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/bit_cost.rs:210:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    reps = reps.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut reps\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":11670,"byte_end":11682,"line_start":329,"line_end":329,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                    reps = reps.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":11480,"byte_end":11480,"line_start":325,"line_end":325,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                let mut reps = 1;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/bit_cost.rs:329:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m329\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    reps = reps.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut reps\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":16482,"byte_end":16494,"line_start":448,"line_end":448,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                    reps = reps.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/bit_cost.rs","byte_start":16292,"byte_end":16292,"line_start":444,"line_end":444,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                let mut reps = 1;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/bit_cost.rs:448:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m448\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    reps = reps.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m444\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut reps\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":27782,"byte_end":27794,"line_start":912,"line_end":912,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":45,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":23931,"byte_end":23931,"line_start":816,"line_end":816,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"        let mut num_blocks = 1;","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:912:45\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m912\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    num_blocks = num_blocks.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m816\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut num_blocks\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":32241,"byte_end":32253,"line_start":1031,"line_end":1031,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":45,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":28390,"byte_end":28390,"line_start":935,"line_end":935,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"        let mut num_blocks = 1;","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1031:45\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1031\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    num_blocks = num_blocks.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m935\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut num_blocks\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":36704,"byte_end":36716,"line_start":1150,"line_end":1150,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"                    num_blocks = num_blocks.wrapping_add(1);","highlight_start":45,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":32853,"byte_end":32853,"line_start":1054,"line_end":1054,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"        let mut num_blocks = 1;","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1150:45\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    num_blocks = num_blocks.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1054\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut num_blocks\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":37477,"byte_end":37489,"line_start":1178,"line_end":1178,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"                next_id = next_id.wrapping_add(1);","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":37080,"byte_end":37080,"line_start":1167,"line_end":1167,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"        let mut next_id = 0;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1178:35\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                next_id = next_id.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1167\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut next_id\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":38502,"byte_end":38514,"line_start":1212,"line_end":1212,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"                next_id = next_id.wrapping_add(1);","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":38105,"byte_end":38105,"line_start":1201,"line_end":1201,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"        let mut next_id = 0;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1212:35\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                next_id = next_id.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut next_id\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":39528,"byte_end":39540,"line_start":1246,"line_end":1246,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"                next_id = next_id.wrapping_add(1);","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":39131,"byte_end":39131,"line_start":1235,"line_end":1235,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"        let mut next_id = 0;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1246:35\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                next_id = next_id.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut next_id\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":45247,"byte_end":45259,"line_start":1420,"line_end":1420,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                block_idx = block_idx.wrapping_add(1);","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":44844,"byte_end":44844,"line_start":1411,"line_end":1411,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"        let mut block_idx = 0;","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1420:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1420\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                block_idx = block_idx.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1411\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut block_idx\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":45879,"byte_end":45891,"line_start":1436,"line_end":1436,"column_start":31,"column_end":43,"is_primary":true,"text":[{"text":"                    pos = pos.wrapping_add(1);","highlight_start":31,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":44152,"byte_end":44152,"line_start":1393,"line_end":1393,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        let mut pos = 0;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1436:31\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1436\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    pos = pos.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":46906,"byte_end":46918,"line_start":1461,"line_end":1461,"column_start":62,"column_end":74,"is_primary":true,"text":[{"text":"            if all_histograms_capacity < all_histograms_size.wrapping_add(num_new_clusters) {","highlight_start":62,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42531,"byte_end":42531,"line_start":1352,"line_end":1352,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1461:62\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if all_histograms_capacity < all_histograms_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1352\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":47049,"byte_end":47061,"line_start":1463,"line_end":1463,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"                    all_histograms_size.wrapping_add(num_new_clusters)","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42531,"byte_end":42531,"line_start":1352,"line_end":1352,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1463:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1463\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    all_histograms_size.wrapping_add(num_new_clusters)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1352\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":47286,"byte_end":47298,"line_start":1468,"line_end":1468,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                while _new_size < all_histograms_size.wrapping_add(num_new_clusters) {","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42531,"byte_end":42531,"line_start":1352,"line_end":1352,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1468:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1468\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while _new_size < all_histograms_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1352\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":48454,"byte_end":48466,"line_start":1492,"line_end":1492,"column_start":58,"column_end":70,"is_primary":true,"text":[{"text":"            if cluster_size_capacity < cluster_size_size.wrapping_add(num_new_clusters) {","highlight_start":58,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42979,"byte_end":42979,"line_start":1363,"line_end":1363,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1492:58\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1492\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if cluster_size_capacity < cluster_size_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1363\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":48595,"byte_end":48607,"line_start":1494,"line_end":1494,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                    cluster_size_size.wrapping_add(num_new_clusters)","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42979,"byte_end":42979,"line_start":1363,"line_end":1363,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1494:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    cluster_size_size.wrapping_add(num_new_clusters)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1363\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":48819,"byte_end":48831,"line_start":1499,"line_end":1499,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                while _new_size_0 < cluster_size_size.wrapping_add(num_new_clusters) {","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42979,"byte_end":42979,"line_start":1363,"line_end":1363,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1499:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while _new_size_0 < cluster_size_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1363\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":50069,"byte_end":50081,"line_start":1528,"line_end":1528,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                all_histograms_size = all_histograms_size.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42531,"byte_end":42531,"line_start":1352,"line_end":1352,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1528:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1528\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                all_histograms_size = all_histograms_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1352\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":50323,"byte_end":50335,"line_start":1532,"line_end":1532,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                cluster_size_size = cluster_size_size.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":42979,"byte_end":42979,"line_start":1363,"line_end":1363,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1532:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1532\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                cluster_size_size = cluster_size_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1363\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":53845,"byte_end":53857,"line_start":1632,"line_end":1632,"column_start":27,"column_end":39,"is_primary":true,"text":[{"text":"                pos = pos.wrapping_add(1);","highlight_start":27,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":44152,"byte_end":44152,"line_start":1393,"line_end":1393,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        let mut pos = 0;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1632:27\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1632\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                pos = pos.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":55086,"byte_end":55098,"line_start":1660,"line_end":1660,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"                next_index = next_index.wrapping_add(1);","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":53324,"byte_end":53324,"line_start":1617,"line_end":1617,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"        let mut next_index = 0;","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1660:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1660\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                next_index = next_index.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1617\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut next_index\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":58967,"byte_end":58979,"line_start":1751,"line_end":1751,"column_start":43,"column_end":55,"is_primary":true,"text":[{"text":"                block_idx_0 = block_idx_0.wrapping_add(1);","highlight_start":43,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":58208,"byte_end":58208,"line_start":1737,"line_end":1737,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"        let mut block_idx_0 = 0;","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1751:43\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1751\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                block_idx_0 = block_idx_0.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1737\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut block_idx_0\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":63081,"byte_end":63093,"line_start":1862,"line_end":1862,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                block_idx = block_idx.wrapping_add(1);","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":62678,"byte_end":62678,"line_start":1853,"line_end":1853,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"        let mut block_idx = 0;","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1862:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1862\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                block_idx = block_idx.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1853\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut block_idx\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":63714,"byte_end":63726,"line_start":1878,"line_end":1878,"column_start":31,"column_end":43,"is_primary":true,"text":[{"text":"                    pos = pos.wrapping_add(1);","highlight_start":31,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":61986,"byte_end":61986,"line_start":1835,"line_end":1835,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        let mut pos = 0;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1878:31\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1878\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    pos = pos.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":64744,"byte_end":64756,"line_start":1903,"line_end":1903,"column_start":62,"column_end":74,"is_primary":true,"text":[{"text":"            if all_histograms_capacity < all_histograms_size.wrapping_add(num_new_clusters) {","highlight_start":62,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60359,"byte_end":60359,"line_start":1794,"line_end":1794,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1903:62\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1903\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if all_histograms_capacity < all_histograms_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1794\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":64887,"byte_end":64899,"line_start":1905,"line_end":1905,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"                    all_histograms_size.wrapping_add(num_new_clusters)","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60359,"byte_end":60359,"line_start":1794,"line_end":1794,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1905:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1905\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    all_histograms_size.wrapping_add(num_new_clusters)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1794\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":65125,"byte_end":65137,"line_start":1910,"line_end":1910,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                while _new_size < all_histograms_size.wrapping_add(num_new_clusters) {","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60359,"byte_end":60359,"line_start":1794,"line_end":1794,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1910:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1910\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while _new_size < all_histograms_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1794\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":66298,"byte_end":66310,"line_start":1934,"line_end":1934,"column_start":58,"column_end":70,"is_primary":true,"text":[{"text":"            if cluster_size_capacity < cluster_size_size.wrapping_add(num_new_clusters) {","highlight_start":58,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60810,"byte_end":60810,"line_start":1805,"line_end":1805,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1934:58\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1934\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if cluster_size_capacity < cluster_size_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1805\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":66439,"byte_end":66451,"line_start":1936,"line_end":1936,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                    cluster_size_size.wrapping_add(num_new_clusters)","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60810,"byte_end":60810,"line_start":1805,"line_end":1805,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1936:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1936\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    cluster_size_size.wrapping_add(num_new_clusters)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1805\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":66663,"byte_end":66675,"line_start":1941,"line_end":1941,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                while _new_size_0 < cluster_size_size.wrapping_add(num_new_clusters) {","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60810,"byte_end":60810,"line_start":1805,"line_end":1805,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1941:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1941\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while _new_size_0 < cluster_size_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1805\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":67913,"byte_end":67925,"line_start":1970,"line_end":1970,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                all_histograms_size = all_histograms_size.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60359,"byte_end":60359,"line_start":1794,"line_end":1794,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1970:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1970\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                all_histograms_size = all_histograms_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1794\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":68167,"byte_end":68179,"line_start":1974,"line_end":1974,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                cluster_size_size = cluster_size_size.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":60810,"byte_end":60810,"line_start":1805,"line_end":1805,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:1974:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1974\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                cluster_size_size = cluster_size_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1805\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":71693,"byte_end":71705,"line_start":2074,"line_end":2074,"column_start":27,"column_end":39,"is_primary":true,"text":[{"text":"                pos = pos.wrapping_add(1);","highlight_start":27,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":61986,"byte_end":61986,"line_start":1835,"line_end":1835,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        let mut pos = 0;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2074:27\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2074\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                pos = pos.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1835\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":72937,"byte_end":72949,"line_start":2102,"line_end":2102,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"                next_index = next_index.wrapping_add(1);","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":71170,"byte_end":71170,"line_start":2059,"line_end":2059,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"        let mut next_index = 0;","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2102:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                next_index = next_index.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2059\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut next_index\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":76819,"byte_end":76831,"line_start":2193,"line_end":2193,"column_start":43,"column_end":55,"is_primary":true,"text":[{"text":"                block_idx_0 = block_idx_0.wrapping_add(1);","highlight_start":43,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":76060,"byte_end":76060,"line_start":2179,"line_end":2179,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"        let mut block_idx_0 = 0;","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2193:43\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                block_idx_0 = block_idx_0.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut block_idx_0\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":80926,"byte_end":80938,"line_start":2304,"line_end":2304,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                block_idx = block_idx.wrapping_add(1);","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":80523,"byte_end":80523,"line_start":2295,"line_end":2295,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"        let mut block_idx = 0;","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2304:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                block_idx = block_idx.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2295\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut block_idx\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":81558,"byte_end":81570,"line_start":2320,"line_end":2320,"column_start":31,"column_end":43,"is_primary":true,"text":[{"text":"                    pos = pos.wrapping_add(1);","highlight_start":31,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":79831,"byte_end":79831,"line_start":2277,"line_end":2277,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        let mut pos = 0;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2320:31\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2320\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    pos = pos.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2277\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":82585,"byte_end":82597,"line_start":2345,"line_end":2345,"column_start":62,"column_end":74,"is_primary":true,"text":[{"text":"            if all_histograms_capacity < all_histograms_size.wrapping_add(num_new_clusters) {","highlight_start":62,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78210,"byte_end":78210,"line_start":2236,"line_end":2236,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2345:62\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2345\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if all_histograms_capacity < all_histograms_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":82728,"byte_end":82740,"line_start":2347,"line_end":2347,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"                    all_histograms_size.wrapping_add(num_new_clusters)","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78210,"byte_end":78210,"line_start":2236,"line_end":2236,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2347:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2347\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    all_histograms_size.wrapping_add(num_new_clusters)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":82965,"byte_end":82977,"line_start":2352,"line_end":2352,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                while _new_size < all_histograms_size.wrapping_add(num_new_clusters) {","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78210,"byte_end":78210,"line_start":2236,"line_end":2236,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2352:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2352\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while _new_size < all_histograms_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":84133,"byte_end":84145,"line_start":2376,"line_end":2376,"column_start":58,"column_end":70,"is_primary":true,"text":[{"text":"            if cluster_size_capacity < cluster_size_size.wrapping_add(num_new_clusters) {","highlight_start":58,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78658,"byte_end":78658,"line_start":2247,"line_end":2247,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2376:58\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2376\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if cluster_size_capacity < cluster_size_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":84274,"byte_end":84286,"line_start":2378,"line_end":2378,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                    cluster_size_size.wrapping_add(num_new_clusters)","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78658,"byte_end":78658,"line_start":2247,"line_end":2247,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2378:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2378\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    cluster_size_size.wrapping_add(num_new_clusters)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":84498,"byte_end":84510,"line_start":2383,"line_end":2383,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                while _new_size_0 < cluster_size_size.wrapping_add(num_new_clusters) {","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78658,"byte_end":78658,"line_start":2247,"line_end":2247,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2383:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2383\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while _new_size_0 < cluster_size_size.wrapping_add(num_new_clusters) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":85748,"byte_end":85760,"line_start":2412,"line_end":2412,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                all_histograms_size = all_histograms_size.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78210,"byte_end":78210,"line_start":2236,"line_end":2236,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut all_histograms_size = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2412:59\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                all_histograms_size = all_histograms_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut all_histograms_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":86002,"byte_end":86014,"line_start":2416,"line_end":2416,"column_start":55,"column_end":67,"is_primary":true,"text":[{"text":"                cluster_size_size = cluster_size_size.wrapping_add(1);","highlight_start":55,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":78658,"byte_end":78658,"line_start":2247,"line_end":2247,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"        let mut cluster_size_size = 0;","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2416:55\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2416\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                cluster_size_size = cluster_size_size.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut cluster_size_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":89524,"byte_end":89536,"line_start":2516,"line_end":2516,"column_start":27,"column_end":39,"is_primary":true,"text":[{"text":"                pos = pos.wrapping_add(1);","highlight_start":27,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":79831,"byte_end":79831,"line_start":2277,"line_end":2277,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        let mut pos = 0;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2516:27\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                pos = pos.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2277\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut pos\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":90765,"byte_end":90777,"line_start":2544,"line_end":2544,"column_start":41,"column_end":53,"is_primary":true,"text":[{"text":"                next_index = next_index.wrapping_add(1);","highlight_start":41,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":89003,"byte_end":89003,"line_start":2501,"line_end":2501,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"        let mut next_index = 0;","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2544:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2544\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                next_index = next_index.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut next_index\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":94646,"byte_end":94658,"line_start":2635,"line_end":2635,"column_start":43,"column_end":55,"is_primary":true,"text":[{"text":"                block_idx_0 = block_idx_0.wrapping_add(1);","highlight_start":43,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":93887,"byte_end":93887,"line_start":2621,"line_end":2621,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"        let mut block_idx_0 = 0;","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:2635:43\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2635\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                block_idx_0 = block_idx_0.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2621\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut block_idx_0\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":123756,"byte_end":123768,"line_start":3397,"line_end":3397,"column_start":23,"column_end":35,"is_primary":true,"text":[{"text":"                j = j.wrapping_add(1);","highlight_start":23,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/block_splitter.rs","byte_start":123386,"byte_end":123386,"line_start":3387,"line_end":3387,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"        let mut j = 0;","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/block_splitter.rs:3397:23\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                j = j.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3387\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut j\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":55940,"byte_end":55952,"line_start":1215,"line_end":1215,"column_start":31,"column_end":43,"is_primary":true,"text":[{"text":"                count = count.wrapping_add(1);","highlight_start":31,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":55545,"byte_end":55545,"line_start":1203,"line_end":1203,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"        let mut count = 0;","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1215:31\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1215\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                count = count.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut count\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":56188,"byte_end":56200,"line_start":1222,"line_end":1222,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"            max_bits = max_bits.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":55642,"byte_end":55642,"line_start":1206,"line_end":1206,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"        let mut max_bits = 0;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1222:33\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            max_bits = max_bits.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut max_bits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":57974,"byte_end":57986,"line_start":1278,"line_end":1278,"column_start":31,"column_end":43,"is_primary":true,"text":[{"text":"                count = count.wrapping_add(1);","highlight_start":31,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":57638,"byte_end":57638,"line_start":1269,"line_end":1269,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"        let mut count = 0;","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1278:31\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1278\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                count = count.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut count\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":62299,"byte_end":62311,"line_start":1392,"line_end":1392,"column_start":38,"column_end":50,"is_primary":true,"text":[{"text":"            BrotliWriteBits(2, count.wrapping_sub(1), storage_ix, storage);","highlight_start":38,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":57638,"byte_end":57638,"line_start":1269,"line_end":1269,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"        let mut count = 0;","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1392:38\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1392\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            BrotliWriteBits(2, count.wrapping_sub(1), storage_ix, storage);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut count\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":64737,"byte_end":64749,"line_start":1443,"line_end":1443,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                    reps = reps.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":64527,"byte_end":64527,"line_start":1439,"line_end":1439,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                let mut reps = 1;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1443:33\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1443\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    reps = reps.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut reps\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":68789,"byte_end":68801,"line_start":1565,"line_end":1565,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"                reps = reps.wrapping_add(1);","highlight_start":29,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":68578,"byte_end":68578,"line_start":1560,"line_end":1560,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"            let mut reps = 0;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1565:29\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1565\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                reps = reps.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1560\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut reps\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":69749,"byte_end":69761,"line_start":1590,"line_end":1590,"column_start":37,"column_end":49,"is_primary":true,"text":[{"text":"                    reps_0 = reps_0.wrapping_add(1);","highlight_start":37,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":69566,"byte_end":69566,"line_start":1586,"line_end":1586,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                let mut reps_0 = 1;","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1590:37\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1590\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    reps_0 = reps_0.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut reps_0\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":70106,"byte_end":70118,"line_start":1597,"line_end":1597,"column_start":49,"column_end":61,"is_primary":true,"text":[{"text":"                        let extra_bits = reps_0.wrapping_sub(1 << run_length_prefix);","highlight_start":49,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/brotli_bit_stream.rs","byte_start":69566,"byte_end":69566,"line_start":1586,"line_end":1586,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                let mut reps_0 = 1;","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/brotli_bit_stream.rs:1597:49\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1597\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        let extra_bits = reps_0.wrapping_sub(1 << run_length_prefix);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1586\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut reps_0\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":17857,"byte_end":17869,"line_start":519,"line_end":519,"column_start":51,"column_end":63,"is_primary":true,"text":[{"text":"                        copy_to_idx = copy_to_idx.wrapping_add(1);","highlight_start":51,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":16967,"byte_end":16967,"line_start":502,"line_end":502,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"                let mut copy_to_idx = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:519:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        copy_to_idx = copy_to_idx.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut copy_to_idx\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":22751,"byte_end":22763,"line_start":639,"line_end":639,"column_start":51,"column_end":63,"is_primary":true,"text":[{"text":"                        copy_to_idx = copy_to_idx.wrapping_add(1);","highlight_start":51,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":21861,"byte_end":21861,"line_start":622,"line_end":622,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"                let mut copy_to_idx = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:639:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m639\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        copy_to_idx = copy_to_idx.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m622\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut copy_to_idx\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":27642,"byte_end":27654,"line_start":759,"line_end":759,"column_start":51,"column_end":63,"is_primary":true,"text":[{"text":"                        copy_to_idx = copy_to_idx.wrapping_add(1);","highlight_start":51,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":26752,"byte_end":26752,"line_start":742,"line_end":742,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"                let mut copy_to_idx = 0;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:759:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m759\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        copy_to_idx = copy_to_idx.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m742\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut copy_to_idx\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_mul` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":42957,"byte_end":42969,"line_start":1224,"line_end":1224,"column_start":14,"column_end":26,"is_primary":true,"text":[{"text":"            .wrapping_mul(max_input_histograms)","highlight_start":14,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":42883,"byte_end":42883,"line_start":1222,"line_end":1222,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"        let max_input_histograms = 64;","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_mul` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:1224:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .wrapping_mul(max_input_histograms)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let max_input_histograms\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":44311,"byte_end":44323,"line_start":1261,"line_end":1261,"column_start":47,"column_end":59,"is_primary":true,"text":[{"text":"                *clusters.offset(num_clusters.wrapping_add(j) as isize) = i.wrapping_add(j) as u32;","highlight_start":47,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":42845,"byte_end":42845,"line_start":1221,"line_end":1221,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"        let mut num_clusters = 0;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:1261:47\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1261\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                *clusters.offset(num_clusters.wrapping_add(j) as isize) = i.wrapping_add(j) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut num_clusters\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_mul` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":48170,"byte_end":48182,"line_start":1371,"line_end":1371,"column_start":14,"column_end":26,"is_primary":true,"text":[{"text":"            .wrapping_mul(max_input_histograms)","highlight_start":14,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":48096,"byte_end":48096,"line_start":1369,"line_end":1369,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"        let max_input_histograms = 64;","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_mul` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:1371:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1371\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .wrapping_mul(max_input_histograms)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1369\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let max_input_histograms\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":49523,"byte_end":49535,"line_start":1408,"line_end":1408,"column_start":47,"column_end":59,"is_primary":true,"text":[{"text":"                *clusters.offset(num_clusters.wrapping_add(j) as isize) = i.wrapping_add(j) as u32;","highlight_start":47,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":48058,"byte_end":48058,"line_start":1368,"line_end":1368,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"        let mut num_clusters = 0;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:1408:47\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1408\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                *clusters.offset(num_clusters.wrapping_add(j) as isize) = i.wrapping_add(j) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1368\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut num_clusters\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_mul` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":53378,"byte_end":53390,"line_start":1518,"line_end":1518,"column_start":14,"column_end":26,"is_primary":true,"text":[{"text":"            .wrapping_mul(max_input_histograms)","highlight_start":14,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":53304,"byte_end":53304,"line_start":1516,"line_end":1516,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"        let max_input_histograms = 64;","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_mul` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:1518:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .wrapping_mul(max_input_histograms)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let max_input_histograms\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 64;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/cluster.rs","byte_start":54731,"byte_end":54743,"line_start":1555,"line_end":1555,"column_start":47,"column_end":59,"is_primary":true,"text":[{"text":"                *clusters.offset(num_clusters.wrapping_add(j) as isize) = i.wrapping_add(j) as u32;","highlight_start":47,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/cluster.rs","byte_start":53266,"byte_end":53266,"line_start":1515,"line_end":1515,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"        let mut num_clusters = 0;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/cluster.rs:1555:47\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1555\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                *clusters.offset(num_clusters.wrapping_add(j) as isize) = i.wrapping_add(j) as u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut num_clusters\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":25319,"byte_end":25331,"line_start":769,"line_end":769,"column_start":36,"column_end":48,"is_primary":true,"text":[{"text":"        BrotliWriteBits(2, nibbles.wrapping_sub(4), storage_ix, storage);","highlight_start":36,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":25079,"byte_end":25079,"line_start":762,"line_end":762,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"        let mut nibbles = 6;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/compress_fragment.rs:769:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m769\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        BrotliWriteBits(2, nibbles.wrapping_sub(4), storage_ix, storage);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m762\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut nibbles\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 6;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_mul` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":25403,"byte_end":25415,"line_start":771,"line_end":771,"column_start":21,"column_end":33,"is_primary":true,"text":[{"text":"            nibbles.wrapping_mul(4),","highlight_start":21,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":25079,"byte_end":25079,"line_start":762,"line_end":762,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"        let mut nibbles = 6;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_mul` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/compress_fragment.rs:771:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m771\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            nibbles.wrapping_mul(4),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m762\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut nibbles\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 6;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":32973,"byte_end":32985,"line_start":976,"line_end":976,"column_start":37,"column_end":49,"is_primary":true,"text":[{"text":"                        skip = skip.wrapping_add(1);","highlight_start":37,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/compress_fragment.rs","byte_start":32711,"byte_end":32711,"line_start":970,"line_end":970,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                    let mut skip = 32;","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/compress_fragment.rs:976:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m976\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        skip = skip.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m970\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    let mut skip\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/compress_fragment_two_pass.rs","byte_start":17693,"byte_end":17705,"line_start":534,"line_end":534,"column_start":36,"column_end":48,"is_primary":true,"text":[{"text":"        BrotliWriteBits(2, nibbles.wrapping_sub(4), storage_ix, storage);","highlight_start":36,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/compress_fragment_two_pass.rs","byte_start":17453,"byte_end":17453,"line_start":527,"line_end":527,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"        let mut nibbles = 6;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/compress_fragment_two_pass.rs:534:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m534\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        BrotliWriteBits(2, nibbles.wrapping_sub(4), storage_ix, storage);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut nibbles\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 6;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_mul` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/compress_fragment_two_pass.rs","byte_start":17777,"byte_end":17789,"line_start":536,"line_end":536,"column_start":21,"column_end":33,"is_primary":true,"text":[{"text":"            nibbles.wrapping_mul(4),","highlight_start":21,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/compress_fragment_two_pass.rs","byte_start":17453,"byte_end":17453,"line_start":527,"line_end":527,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"        let mut nibbles = 6;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_mul` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/compress_fragment_two_pass.rs:536:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m536\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            nibbles.wrapping_mul(4),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m527\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut nibbles\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 6;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/compress_fragment_two_pass.rs","byte_start":19268,"byte_end":19280,"line_start":581,"line_end":581,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                    skip = skip.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/compress_fragment_two_pass.rs","byte_start":19031,"byte_end":19031,"line_start":575,"line_end":575,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                let mut skip = 32;","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/compress_fragment_two_pass.rs:581:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m581\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    skip = skip.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m575\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut skip\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":123470,"byte_end":123482,"line_start":3917,"line_end":3917,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"                    total = total.wrapping_add(1);","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":122364,"byte_end":122364,"line_start":3897,"line_end":3897,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            let mut total = 0;","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:3917:35\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3917\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    total = total.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3897\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut total\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_div` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":164413,"byte_end":164425,"line_start":5037,"line_end":5037,"column_start":61,"column_end":73,"is_primary":true,"text":[{"text":"        let max_literals_per_metablock = max_metablock_size.wrapping_div(8);","highlight_start":61,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":164332,"byte_end":164332,"line_start":5036,"line_end":5036,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"        let max_metablock_size = 1 << lgmetablock;","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_div` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5037:61\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5037\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let max_literals_per_metablock = max_metablock_size.wrapping_div(8);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5036\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let max_metablock_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1 << lgmetablock;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_div` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":164490,"byte_end":164502,"line_start":5038,"line_end":5038,"column_start":61,"column_end":73,"is_primary":true,"text":[{"text":"        let max_commands_per_metablock = max_metablock_size.wrapping_div(8);","highlight_start":61,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":164332,"byte_end":164332,"line_start":5036,"line_end":5036,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"        let max_metablock_size = 1 << lgmetablock;","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_div` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5038:61\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5038\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let max_commands_per_metablock = max_metablock_size.wrapping_div(8);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5036\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let max_metablock_size\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1 << lgmetablock;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":170632,"byte_end":170644,"line_start":5181,"line_end":5181,"column_start":46,"column_end":58,"is_primary":true,"text":[{"text":"                                num_commands.wrapping_add(path_size).wrapping_add(1),","highlight_start":46,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":167097,"byte_end":167097,"line_start":5113,"line_end":5113,"column_start":45,"column_end":45,"is_primary":true,"text":[{"text":"                        let mut num_commands = 0;","highlight_start":45,"highlight_end":45}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5181:46\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   num_commands.wrapping_add(path_size).wrapping_add(1),\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        let mut num_commands\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":186539,"byte_end":186551,"line_start":5494,"line_end":5494,"column_start":25,"column_end":37,"is_primary":true,"text":[{"text":"        result = result.wrapping_add(1);","highlight_start":25,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":186346,"byte_end":186346,"line_start":5487,"line_end":5487,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let mut result = 0;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5494:25\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        result = result.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut result\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":186659,"byte_end":186671,"line_start":5497,"line_end":5497,"column_start":25,"column_end":37,"is_primary":true,"text":[{"text":"        result = result.wrapping_add(1);","highlight_start":25,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":186346,"byte_end":186346,"line_start":5487,"line_end":5487,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let mut result = 0;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5497:25\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        result = result.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut result\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":187353,"byte_end":187365,"line_start":5515,"line_end":5515,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"            result = result.wrapping_add(1);","highlight_start":29,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":186346,"byte_end":186346,"line_start":5487,"line_end":5487,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let mut result = 0;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5515:29\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            result = result.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut result\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":187491,"byte_end":187503,"line_start":5518,"line_end":5518,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"            result = result.wrapping_add(1);","highlight_start":29,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":186346,"byte_end":186346,"line_start":5487,"line_end":5487,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let mut result = 0;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5518:29\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            result = result.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut result\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":187639,"byte_end":187651,"line_start":5521,"line_end":5521,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"            result = result.wrapping_add(1);","highlight_start":29,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":186346,"byte_end":186346,"line_start":5487,"line_end":5487,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let mut result = 0;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5521:29\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            result = result.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut result\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/encode.rs","byte_start":187827,"byte_end":187839,"line_start":5525,"line_end":5525,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                result = result.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/encode.rs","byte_start":186346,"byte_end":186346,"line_start":5487,"line_end":5487,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let mut result = 0;","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/encode.rs:5525:33\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5525\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                result = result.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5487\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut result\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":5376,"byte_end":5388,"line_start":175,"line_end":175,"column_start":27,"column_end":39,"is_primary":true,"text":[{"text":"                    n = n.wrapping_add(1);","highlight_start":27,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":4979,"byte_end":4979,"line_start":165,"line_end":165,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"            let mut n = 0;","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:175:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    n = n.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m165\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut n\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":12327,"byte_end":12339,"line_start":365,"line_end":365,"column_start":47,"column_end":59,"is_primary":true,"text":[{"text":"                nonzero_count = nonzero_count.wrapping_add(1);","highlight_start":47,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":12028,"byte_end":12028,"line_start":356,"line_end":356,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let mut nonzero_count = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:365:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m365\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                nonzero_count = nonzero_count.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m356\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut nonzero_count\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":12872,"byte_end":12884,"line_start":383,"line_end":383,"column_start":37,"column_end":49,"is_primary":true,"text":[{"text":"                nonzeros = nonzeros.wrapping_add(1);","highlight_start":37,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":12683,"byte_end":12683,"line_start":378,"line_end":378,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"        let mut nonzeros = 0;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:383:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m383\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                nonzeros = nonzeros.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m378\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut nonzeros\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":18134,"byte_end":18146,"line_start":525,"line_end":525,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"                reps = reps.wrapping_add(1);","highlight_start":29,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":17950,"byte_end":17950,"line_start":521,"line_end":521,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"            let mut reps = 1;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:525:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m525\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                reps = reps.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut reps\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":18388,"byte_end":18400,"line_start":530,"line_end":530,"column_start":51,"column_end":63,"is_primary":true,"text":[{"text":"                count_reps_zero = count_reps_zero.wrapping_add(1);","highlight_start":51,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":17758,"byte_end":17758,"line_start":515,"line_end":515,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"        let mut count_reps_zero = 1;","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:530:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m530\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                count_reps_zero = count_reps_zero.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut count_reps_zero\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":18619,"byte_end":18631,"line_start":534,"line_end":534,"column_start":59,"column_end":71,"is_primary":true,"text":[{"text":"                count_reps_non_zero = count_reps_non_zero.wrapping_add(1);","highlight_start":59,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":17799,"byte_end":17799,"line_start":516,"line_end":516,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut count_reps_non_zero = 1;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:534:59\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m534\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                count_reps_non_zero = count_reps_non_zero.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut count_reps_non_zero\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_mul` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":18784,"byte_end":18796,"line_start":538,"line_end":538,"column_start":78,"column_end":90,"is_primary":true,"text":[{"text":"        *use_rle_for_non_zero = if total_reps_non_zero > count_reps_non_zero.wrapping_mul(2) {","highlight_start":78,"highlight_end":90}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":17799,"byte_end":17799,"line_start":516,"line_end":516,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        let mut count_reps_non_zero = 1;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_mul` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:538:78\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m538\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        *use_rle_for_non_zero = if total_reps_non_zero > count_reps_non_zero.wrapping_mul(2) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut count_reps_non_zero\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_mul` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":18923,"byte_end":18935,"line_start":543,"line_end":543,"column_start":66,"column_end":78,"is_primary":true,"text":[{"text":"        *use_rle_for_zero = if total_reps_zero > count_reps_zero.wrapping_mul(2) {","highlight_start":66,"highlight_end":78}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":17758,"byte_end":17758,"line_start":515,"line_end":515,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"        let mut count_reps_zero = 1;","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_mul` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:543:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m543\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        *use_rle_for_zero = if total_reps_zero > count_reps_zero.wrapping_mul(2) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut count_reps_zero\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":20340,"byte_end":20352,"line_start":591,"line_end":591,"column_start":33,"column_end":45,"is_primary":true,"text":[{"text":"                    reps = reps.wrapping_add(1);","highlight_start":33,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/entropy_encode.rs","byte_start":19998,"byte_end":19998,"line_start":584,"line_end":584,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"            let mut reps = 1;","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/entropy_encode.rs:591:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m591\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    reps = reps.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m584\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut reps\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/metablock.rs","byte_start":9016,"byte_end":9028,"line_start":304,"line_end":304,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                ndistbits = ndistbits.wrapping_add(1);","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/metablock.rs","byte_start":8599,"byte_end":8599,"line_start":294,"line_end":294,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            let mut ndistbits = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/metablock.rs:304:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                ndistbits = ndistbits.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut ndistbits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/metablock.rs","byte_start":9113,"byte_end":9125,"line_start":307,"line_end":307,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"            ndistbits = ndistbits.wrapping_sub(1);","highlight_start":35,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/metablock.rs","byte_start":8599,"byte_end":8599,"line_start":294,"line_end":294,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            let mut ndistbits = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/metablock.rs:307:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m307\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ndistbits = ndistbits.wrapping_sub(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut ndistbits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_sub` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/enc/metablock.rs","byte_start":9204,"byte_end":9216,"line_start":309,"line_end":309,"column_start":31,"column_end":43,"is_primary":true,"text":[{"text":"            group = ndistbits.wrapping_sub(1) << 1 | half;","highlight_start":31,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/enc/metablock.rs","byte_start":8599,"byte_end":8599,"line_start":294,"line_end":294,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            let mut ndistbits = 0;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_sub` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/enc/metablock.rs:309:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m309\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            group = ndistbits.wrapping_sub(1) << 1 | half;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut ndistbits\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/tools/brotli.rs","byte_start":10716,"byte_end":10728,"line_start":317,"line_end":317,"column_start":47,"column_end":59,"is_primary":true,"text":[{"text":"                    input_count = input_count.wrapping_add(1);","highlight_start":47,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/tools/brotli.rs","byte_start":9493,"byte_end":9493,"line_start":287,"line_end":287,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"        let mut input_count = 0;","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tools/brotli.rs:317:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m317\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    input_count = input_count.wrapping_add(1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let mut input_count\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"can't call method `wrapping_add` on ambiguous numeric type `{integer}`","code":{"code":"E0689","explanation":"A method was called on an ambiguous numeric type.\n\nErroneous code example:\n\n```compile_fail,E0689\n2.0.neg(); // error!\n```\n\nThis error indicates that the numeric value for the method being passed exists\nbut the type of the numeric value or binding could not be identified.\n\nThe error happens on numeric literals and on numeric bindings without an\nidentified concrete type:\n\n```compile_fail,E0689\nlet x = 2.0;\nx.neg();  // same error as above\n```\n\nBecause of this, you must give the numeric literal or binding a type:\n\n```\nuse std::ops::Neg;\n\nlet _ = 2.0_f32.neg(); // ok!\nlet x: f32 = 2.0;\nlet _ = x.neg(); // ok!\nlet _ = (2.0 as f32).neg(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/tools/brotli.rs","byte_start":62516,"byte_end":62528,"line_start":1497,"line_end":1497,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"                        lgwin = lgwin.wrapping_add(1);","highlight_start":39,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you must specify a type for this binding, like `i32`","code":null,"level":"help","spans":[{"file_name":"src/tools/brotli.rs","byte_start":62285,"byte_end":62285,"line_start":1493,"line_end":1493,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"                let mut lgwin = 24;","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":": i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0689]\u001b[0m\u001b[0m\u001b[1m: can't call method `wrapping_add` on ambiguous numeric type `{integer}`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/tools/brotli.rs:1497:39\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1497\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        lgwin = lgwin.wrapping_add(1);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you must specify a type for this binding, like `i32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1493\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                let mut lgwin\u001b[0m\u001b[0m\u001b[38;5;10m: i32\u001b[0m\u001b[0m = 24;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++\u001b[0m\n\n"}
{"message":"aborting due to 117 previous errors; 114 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 117 previous errors; 114 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0554, E0689.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0554, E0689.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0554`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0554`.\u001b[0m\n"}
